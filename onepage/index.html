<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>
      Exploring Lift
    </title>
    <!-- scripts for highlighter -->
    <script type="text/javascript" src="scripts/shCore.js"></script>
    <script type="text/javascript" src="scripts/shBrushXml.js"></script>
    <script type="text/javascript" src="scripts/shBrushScala.js"></script>
    <script type="text/javascript" src="scripts/shBrushBash.js"></script>
    <!-- CSS for highlighter -->
    <link href="css/shCore.css" rel="stylesheet" type="text/css" />
    <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="css/lyx.css" type="text/css" media="screen"/>
  </head>
  <body>
    <div id="globalWrapper">
      <h1 class="title">
<span class="giant">Exploring Lift</span>
</h1>
<h2 class="author">
Lift 2.0 Edition
</h2>
<h2 class="author">
Written by 
</h2>
<h2 class="author">
Derek Chen-Becker, Marius Danciu and Tyler Weir
</h2>
<div class="Unindented">
Copyright © 2008, 2009, 2010, 2011 by Derek Chen-Becker, Marius Danciu, David Pollak, and Tyler Weir.<br/>
This work is licensed under the Creative Commons Attribution-No Derivative Works 3.0 Unported License.
</div>
<div class="Indented">
The home page for <i>Exploring Lift</i> is at <a class="FlexURL" href="http://exploring.liftweb.net">http://exploring.liftweb.net</a>. Here you can find up-to-date copies of the text, as well as links to the mailing list, issue tracking, and source code. 
</div>
<div class="fulltoc">
<div class="tocheader">
Table of Contents
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Chapter--1">Chapter: Dedication</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter--2">Chapter: Acknowledgements</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Part-I">Part I: The Basics</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Chapter-1">Chapter 1: Welcome to Lift!</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-1.1">Section 1.1: Why Lift?</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-1.2">Section 1.2: What You Should Know before Starting</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-1.3">Section 1.3: Typographical Conventions</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-1.4">Section 1.4: For More Information about Lift</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-1.5">Section 1.5: Your First Lift Application</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-2">Chapter 2: PocketChange</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-2.1">Section 2.1: Defining the Model</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-2.2">Section 2.2: Our First Template</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-2.3">Section 2.3: Writing Snippets</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-2.4">Section 2.4: A Little AJAX Spice</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-2.5">Section 2.5: Conclusion</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-3">Chapter 3: Lift Fundamentals</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-3.1">Section 3.1: Entry into Lift</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-3.2">Section 3.2: Bootstrap</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-3.2.1">Subsection 3.2.1: Class Resolution</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-3.3">Section 3.3: A Note on Standard Imports</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-3.4">Section 3.4: Lift’s Main Objects</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-3.4.1">Subsection 3.4.1: S object</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.4.2">Subsection 3.4.2: SHtml</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-3.4.3">Subsection 3.4.3: LiftRules</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-3.5">Section 3.5: The Rendering Process</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-3.6">Section 3.6: Notices, Warnings, and Error Messages</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-3.7">Section 3.7: URL Rewriting </a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-3.8">Section 3.8: Custom Dispatch Functions </a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-3.9">Section 3.9: HTTP Redirects </a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-3.10">Section 3.10: Cookies</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-3.11">Section 3.11: Session and Request State</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-3.12">Section 3.12: Conclusion</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-4">Chapter 4: Templates in Lift</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-4.1">Section 4.1: Template XML</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-4.1.1">Subsection 4.1.1: Locating Template XML</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.1.2">Subsection 4.1.2: Processing Template XML</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-4.2">Section 4.2: Designer-Friendly Templates</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-4.2.1">Subsection 4.2.1: Determining the Content Element</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.2.2">Subsection 4.2.2: Invoking Snippets Via the Class Attribute</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.2.3">Subsection 4.2.3: Binding via CSS transforms</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-4.3">Section 4.3: HTML5 Support</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-4.4">Section 4.4: Views</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-4.5">Section 4.5: Tags</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.1">Subsection 4.5.1: a</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.2">Subsection 4.5.2: bind</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.3">Subsection 4.5.3: bind-at</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.4">Subsection 4.5.4: children</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.5">Subsection 4.5.5: comet</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.6">Subsection 4.5.6: CSS</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.7">Subsection 4.5.7: embed </a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.8">Subsection 4.5.8: form</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.9">Subsection 4.5.9: HTML5</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.10">Subsection 4.5.10: ignore</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.11">Subsection 4.5.11: lazy-load</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.12">Subsection 4.5.12: loc</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.13">Subsection 4.5.13: Menu</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.14">Subsection 4.5.14: Msgs</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.15">Subsection 4.5.15: SkipDocType</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.16">Subsection 4.5.16: snippet</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.17">Subsection 4.5.17: surround</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.18">Subsection 4.5.18: tail</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.19">Subsection 4.5.19: TestCond</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.20">Subsection 4.5.20: with-param</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.21">Subsection 4.5.21: with-resource-id</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.22">Subsection 4.5.22: VersionInfo</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-4.5.23">Subsection 4.5.23: XmlGroup</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-4.6">Section 4.6: Head and Tail Merge</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-4.7">Section 4.7: Binding</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-5">Chapter 5: Snippets</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-5.1">Section 5.1: The Snippet Tag</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-5.2">Section 5.2: Snippet Dispatch</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-5.2.1">Subsection 5.2.1: Implicit Dispatch Via Reflection</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-5.2.2">Subsection 5.2.2: Explicit Dispatch</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-5.2.3">Subsection 5.2.3: Per-request Remapping</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-5.3">Section 5.3: Snippet Methods</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-5.3.1">Subsection 5.3.1: Binding Values in Snippets</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-5.3.2">Subsection 5.3.2: CSS Selector Transforms</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-5.3.3">Subsection 5.3.3: Stateless versus Stateful Snippets</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-5.3.4">Subsection 5.3.4: Eager Evaluation</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-5.4">Section 5.4: Handling XHTML Attributes in Snippets</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-5.4.1">Subsection 5.4.1: Direct Manipulation in Code</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-5.4.2">Subsection 5.4.2: XHTML Attribute Pass-through</a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-6">Chapter 6: Forms in Lift</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-6.1">Section 6.1: Form Fundamentals</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-6.2">Section 6.2: Attributes for Form Elements</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-6.3">Section 6.3: An Overview of Form Elements</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-6.3.1">Subsection 6.3.1: checkbox</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-6.3.2">Subsection 6.3.2: hidden</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-6.3.3">Subsection 6.3.3: link</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-6.3.4">Subsection 6.3.4: text and password</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-6.3.5">Subsection 6.3.5: textarea</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-6.3.6">Subsection 6.3.6: submit</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-6.3.7">Subsection 6.3.7: multiselect</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-6.3.8">Subsection 6.3.8: radio</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-6.3.9">Subsection 6.3.9: select</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-6.3.10">Subsection 6.3.10: selectObj</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-6.3.11">Subsection 6.3.11: untrustedSelect</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-6.4">Section 6.4: File Uploads</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-7">Chapter 7: SiteMap</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-7.1">Section 7.1: Basic SiteMap Definition</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-7.1.1">Subsection 7.1.1: The Link Class</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.1.2">Subsection 7.1.2: ExtLink</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.1.3">Subsection 7.1.3: Creating Menu Entries</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.1.4">Subsection 7.1.4: Nested Menus</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.1.5">Subsection 7.1.5: Setting the Global SiteMap</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-7.2">Section 7.2: Customizing Display</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-7.2.1">Subsection 7.2.1: Hidden</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.2.2">Subsection 7.2.2: Controlling the Menu Text</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.2.3">Subsection 7.2.3: Using &lt;lift:Menu&gt;</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-7.3">Section 7.3: Access Control</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-7.3.1">Subsection 7.3.1: If</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.3.2">Subsection 7.3.2: Unless</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-7.4">Section 7.4: Page-Specific Rendering</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-7.4.1">Subsection 7.4.1: The Template Parameter</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.4.2">Subsection 7.4.2: The Snippet and LocSnippets Parameters</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.4.3">Subsection 7.4.3: Title</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-7.5">Section 7.5: Miscellaneous Menu Functionality</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-7.5.1">Subsection 7.5.1: Test</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.5.2">Subsection 7.5.2: LocGroup</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-7.6">Section 7.6: Writing Your Own Loc</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-7.6.1">Subsection 7.6.1: Corresponding Functions</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.6.2">Subsection 7.6.2: Type Safe Parameters</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.6.3">Subsection 7.6.3: Dynamically Adding Child Menus</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-7.6.4">Subsection 7.6.4: Binding Your Custom Loc</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-7.7">Section 7.7: Conclusion</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-8">Chapter 8: The Mapper and Record Frameworks</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-8.1">Section 8.1: Introduction to Mapper and MetaMapper</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-8.1.1">Subsection 8.1.1: Adding Mapper to Your Project</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.1.2">Subsection 8.1.2: Setting Up the Database Connection</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.1.3">Subsection 8.1.3: Constructing a Mapper-enabled Class</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.1.4">Subsection 8.1.4: Object Relationships</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.1.5">Subsection 8.1.5: Indexing</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.1.6">Subsection 8.1.6: Schema Mapping</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.1.7">Subsection 8.1.7: Persistence Operations on an Entity</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.1.8">Subsection 8.1.8: Querying for Entities</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.1.9">Subsection 8.1.9: Comparison QueryParams</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.1.10">Subsection 8.1.10: Control QueryParams</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.1.11">Subsection 8.1.11: Making Joins a Little Friendlier</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-8.2">Section 8.2: Utility Functionality</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-8.2.1">Subsection 8.2.1: Display Generation</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.2.2">Subsection 8.2.2: Form Generation</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.2.3">Subsection 8.2.3: Validation</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.2.4">Subsection 8.2.4: CRUD Support</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.2.5">Subsection 8.2.5: Lifecycle Callbacks</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.2.6">Subsection 8.2.6: Base Field Types</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.2.7">Subsection 8.2.7: Defining Custom Field Types in Mapper</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.2.8">Subsection 8.2.8: ProtoUser and MegaProtoUser</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-8.3">Section 8.3: Advanced Features</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-8.3.1">Subsection 8.3.1: Using Multiple Databases </a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.3.2">Subsection 8.3.2: Database Sharding</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-8.3.3">Subsection 8.3.3: SQL-based Queries</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-8.4">Section 8.4: Logging</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-8.5">Section 8.5: Summary </a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Part-II">Part II: Advanced Topics</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Chapter-9">Chapter 9: Advanced Lift Architecture</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-9.1">Section 9.1: Architectural Overview</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-9.2">Section 9.2: The Request/Response Lifecycle</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-9.3">Section 9.3: Lift Function Mapping</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-9.4">Section 9.4: LiftResponse in Detail</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-9.4.1">Subsection 9.4.1: InMemoryResponse</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-9.4.2">Subsection 9.4.2: StreamingResponse</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-9.4.3">Subsection 9.4.3: Hierarchy</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-9.4.4">Subsection 9.4.4: RedirectWithState</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-9.4.5">Subsection 9.4.5: XmlResponse</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-9.5">Section 9.5: Session Management </a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-9.5.1">Subsection 9.5.1: Lift garbage collection</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-9.6">Section 9.6: Miscellaneous Lift Features</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-9.6.1">Subsection 9.6.1: Wrapping Lift’s processing logic</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-9.6.2">Subsection 9.6.2: Passing Template Parameters to Snippets </a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-9.6.3">Subsection 9.6.3: Computing Attributes with Snippets</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-9.6.4">Subsection 9.6.4: Processing Element Attributes</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-9.7">Section 9.7: Advanced S Object Features</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-9.7.1">Subsection 9.7.1: Managing cookies</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-9.7.2">Subsection 9.7.2: Localization and Internationalization</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-9.7.3">Subsection 9.7.3: Managing the Timezone</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-9.7.4">Subsection 9.7.4: Per-session DispatchPF functions </a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-9.7.5">Subsection 9.7.5: Session re-writers</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-9.7.6">Subsection 9.7.6: Access to HTTP headers</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-9.7.7">Subsection 9.7.7: Manage the document type</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-9.7.8">Subsection 9.7.8: Other functions </a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-9.8">Section 9.8: ResourceServer</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-9.9">Section 9.9: HTTP Authentication</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-9.9.1">Subsection 9.9.1: Determining which Resources to Protect</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-9.9.2">Subsection 9.9.2: Providing the Authentication Hook</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-9.9.3">Subsection 9.9.3: Role Hierarchies</a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-10">Chapter 10: Lift and JavaScript</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-10.1">Section 10.1: JavaScript high level abstractions</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-10.1.1">Subsection 10.1.1: JsCmd and JsExp overview</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-10.1.2">Subsection 10.1.2: JavaScript Abstraction Examples</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-10.2">Section 10.2: JQuery and other JavaScript frameworks</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-10.3">Section 10.3: XML and JavaScript</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-10.4">Section 10.4: JSON</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-10.4.1">Subsection 10.4.1: JSON forms</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-10.5">Section 10.5: JqSHtml object</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-10.6">Section 10.6: A recap</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-11">Chapter 11: AJAX and Comet in Lift</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-11.1">Section 11.1: What are AJAX and Comet, really?</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-11.2">Section 11.2: Using AJAX in Lift</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-11.3">Section 11.3: A more complex AJAX example</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-11.4">Section 11.4: AJAX Generators in Detail</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-11.5">Section 11.5: Comet and Lift</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-11.5.1">Subsection 11.5.1: Actors in Scala</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-11.5.2">Subsection 11.5.2: Building a Comet Application in Lift</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-11.6">Section 11.6: Coordinating Between Multiple Comet Clients</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-11.7">Section 11.7: Summary</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-12">Chapter 12: JPA Integration</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-12.1">Section 12.1: Introducing JPA</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-12.1.1">Subsection 12.1.1: Using Entity Classes in Scala</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-12.1.2">Subsection 12.1.2: Using the orm.xml descriptor</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-12.1.3">Subsection 12.1.3: Working with Attached and Detached Objects</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-12.2">Section 12.2: Obtaining a Per-Session EntityManager</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-12.3">Section 12.3: Handling Transactions</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-12.4">Section 12.4: ScalaEntityManager and ScalaQuery</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-12.5">Section 12.5: Operating on Entities</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-12.5.1">Subsection 12.5.1: Persisting, Merging and Removing Entities</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-12.5.2">Subsection 12.5.2: Loading an Entity</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-12.5.3">Subsection 12.5.3: Loading Many Entities</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-12.5.4">Subsection 12.5.4: Using Queries Wisely</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-12.5.5">Subsection 12.5.5: Converting Collection Properties</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-12.5.6">Subsection 12.5.6: The importance of flush() and Exceptions</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-12.5.7">Subsection 12.5.7: Validating Entities</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-12.6">Section 12.6: Supporting User Types</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-12.7">Section 12.7: Running the Application</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-12.8">Section 12.8: Summing Up</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-13">Chapter 13: Third Party Integrations</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-13.1">Section 13.1: OpenID Integration</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-13.2">Section 13.2: AMQP </a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-13.3">Section 13.3: PayPal</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-13.4">Section 13.4: Facebook</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-13.5">Section 13.5: XMPP</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-13.6">Section 13.6: Lucene/Compass Integration</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-14">Chapter 14: Lift Widgets</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-14.1">Section 14.1: Current Lift Widgets</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-14.1.1">Subsection 14.1.1: TableSorter widget</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-14.1.2">Subsection 14.1.2: Calendar widgets</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-14.1.3">Subsection 14.1.3: RSS Feed widget</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-14.1.4">Subsection 14.1.4: Gravatar widget</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-14.1.5">Subsection 14.1.5: TreeView widget</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-14.1.6">Subsection 14.1.6: Sparklines widget</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-14.2">Section 14.2: How to build a widget</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-15">Chapter 15: RESTful Web Services</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-15.1">Section 15.1: Some Background on REST</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-15.1.1">Subsection 15.1.1: A Little Bit about HTTP</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-15.1.2">Subsection 15.1.2: Defining REST</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-15.1.3">Subsection 15.1.3: Comparing XML-RPC to REST Architectures</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-15.2">Section 15.2: A Simple API for PocketChange</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-15.3">Section 15.3: Adding REST Helper Methods to our Entities</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-15.4">Section 15.4: Multiple Approaches to REST Handling</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-15.4.1">Subsection 15.4.1: Using Custom Dispatch</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-15.4.2">Subsection 15.4.2: Using the RestHelper Trait</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-15.5">Section 15.5: Processing Expense PUTs</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-15.6">Section 15.6: The Request and Response Cycles for Our API</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-15.7">Section 15.7: Extending the API to Return Atom Feeds</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-15.7.1">Subsection 15.7.1: An Example Atom Request</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-15.7.2">Subsection 15.7.2: Add a feed tag for the account page</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-15.8">Section 15.8: Conclusion</a>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Part-III">Part III: Appendices</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Appendix-A">Appendix A: A Brief Tour of Maven</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-A.1">Section A.1: What is Maven?</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-A.2">Section A.2: Lifecycles, Phases and Goals</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-A.3">Section A.3: Repositories</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-A.4">Section A.4: Plugins</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-A.5">Section A.5: Dependencies</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-A.5.1">Subsection A.5.1: Adding a Dependency</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-A.6">Section A.6: Further Resources</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-A.7">Section A.7: Project Layout</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Appendix-B">Appendix B: Message Handling</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-B.1">Section B.1: Sending Messages</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-B.2">Section B.2: Displaying Messages</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Appendix-C">Appendix C: Lift Helpers</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-C.1">Section C.1: Introduction</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-C.2">Section C.2: Box (or Scala’s Option class on steroids)</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-C.3">Section C.3: ActorPing</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-C.4">Section C.4: ClassHelpers</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-C.5">Section C.5: CodeHelpers</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-C.6">Section C.6: ControlHelpers</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-C.7">Section C.7: CSSHelpers</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-C.8">Section C.8: BindHelpers</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-C.9">Section C.9: HttpHelpers</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-C.10">Section C.10: JSON</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-C.11">Section C.11: LD</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-C.12">Section C.12: ListHelpers</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-C.13">Section C.13: NamedPartialFunctions</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-C.14">Section C.14: SecurityHelpers</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-C.15">Section C.15: TimeHelpers</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Appendix-D">Appendix D: Internationalization</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-D.1">Section D.1: Localized Templates</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-D.2">Section D.2: Resource Bundles</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-D.3">Section D.3: An Important Note on Resource Bundle Resolution</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-D.4">Section D.4: Localized Strings in Scala Code</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-D.5">Section D.5: Formatting Localized Strings</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-D.6">Section D.6: Localized Strings in Templates</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-D.7">Section D.7: Calculating Locale</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Appendix-E">Appendix E: Logging in Lift</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-E.1">Section E.1: Logging Backend</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-E.2">Section E.2: Basic Logging</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-E.2.1">Subsection E.2.1: Logging Setup</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-E.2.2">Subsection E.2.2: Obtaining a Logger</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-E.2.3">Subsection E.2.3: Logging Methods</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-E.3">Section E.3: Log Level Guards</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-E.4">Section E.4: Logging Mapper Queries</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Appendix-F">Appendix F: Sending Email</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-F.1">Section F.1: Setup</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Section-F.2">Section F.2: Sending Emails</a>
</div>
</div>
<div class="toc">
<a class="Link" href="#toc-Appendix-G">Appendix G: JPA Code Listings</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Section-G.1">Section G.1: JPA Library Demo</a>
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Subsection-G.1.1">Subsection G.1.1: Author Entity</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-G.1.2">Subsection G.1.2: orm.xml Mapping</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-G.1.3">Subsection G.1.3: Enumv Trait</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-G.1.4">Subsection G.1.4: EnumerationType</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Subsection-G.1.5">Subsection G.1.5: JPA web.xml</a>
</div>
</div>
</div>
</div>
<div class="toc">
<a class="Link" href="#Index">Index</a>
</div>

</div>
<div class="fulltoc">
<div class="tocheader">
List of Figures
</div>
<div class="toc">
<a class="Link" href="#Figure-2.1">Figure 2.1: The PocketChange App</a>
</div>
<div class="toc">
<a class="Link" href="#fig:Architecture-diagram">Figure 9.1: Architecture</a>
</div>
<div class="toc">
<a class="Link" href="#Figure-9.2">Figure 9.2: Lift Global Request Processing</a>
</div>
<div class="toc">
<a class="Link" href="#Figure-9.3">Figure 9.3: Lift HTTP Request Processing</a>
</div>
<div class="toc">
<a class="Link" href="#fig:Roles-hierarchy-example">Figure 9.4: Roles hierarchy example</a>
</div>
<div class="toc">
<a class="Link" href="#fig:model-comparisons">Figure 11.1: Application Model Comparisons</a>
</div>
<div class="toc">
<a class="Link" href="#Figure-14.1">Figure 14.1: TableSorter widget</a>
</div>
<div class="toc">
<a class="Link" href="#Figure-14.2">Figure 14.2: Calendar Month-View</a>
</div>
<div class="toc">
<a class="Link" href="#Figure-14.3">Figure 14.3: Calendar Week-View</a>
</div>
<div class="toc">
<a class="Link" href="#Figure-14.4">Figure 14.4: Calendar Day-View </a>
</div>
<div class="toc">
<a class="Link" href="#Figure-14.5">Figure 14.5: RSSFeed widget</a>
</div>
<div class="toc">
<a class="Link" href="#fig:TreeView-widget">Figure 14.6: TreeView widget</a>
</div>
<div class="toc">
<a class="Link" href="#fig:Sparklines-bar-chart">Figure 14.7: Sparklines bar chart</a>
</div>

</div>
<h1 class="Chapter-">
<a class="toc" name="toc-Chapter--1"></a>Dedication
</h1>
<div class="Unindented">
Derek would like to thank his wife, Debbie, for her patience and support while writing this book. He would also like to thank his two young sons, Dylan and Dean, for keeping things interesting and in perspective.<br/>

</div>
<div class="Indented">
Tyler would like to thank his wife, Laura, for encouraging him.<br/>

</div>
<div class="Indented">
Marius would like to thank his wife, Alina, for her patience during long weekends and bearing with his monosyllabic answers while working on the book.
</div>
<h1 class="Chapter-">
<a class="toc" name="toc-Chapter--2"></a>Acknowledgements
</h1>
<div class="Unindented">
This book would not have been possible without the Lift Developers and especially David Pollak: without him, we wouldn’t have this opportunity.
</div>
<div class="Indented">
We would also like to thank the Lift community, as well as the following individuals, for valuable feedback on the content of this book: Adam Cimarosti, Malcolm Gorman, Doug Holton, Hunter Kelly, James Matlik, Larry Morroni, Jorge Ortiz, Tim Perrett, Tim Pigden, Dennis Przytarski, Thomas Sant Ana, Heiko Seeberger, and Eric Willigers.
</div>
<div class="Indented">
A huge thanks to Charles Munat for editing this work, and to Tim Perrett for helping with the REST API in Chapter 13.
</div>
<h1 class="Part">
<a class="toc" name="toc-Part-I">Part I.</a> The Basics
</h1>
<div class="Unindented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-1">1</a> Welcome to Lift!<a class="Label" name="cha:Welcome-to-Lift!"> </a>
</h1>
<div class="Unindented">
Welcome to <i>Exploring Lift</i>. We’ve created this book to educate you about Lift, which we think is a great framework for building compelling web applications. Lift is designed to make powerful techniques easily accessible while keeping the overall framework simple and flexible. It may sound like a cliché, but in our experience Lift makes it fun to develop because it lets you focus on the interesting parts of coding. Our goal for this book is that by the end, you’ll be able to create and extend any web application you can think of.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-1.1">1.1</a> Why Lift?
</h2>
<div class="Unindented">
For those of you have experience with other web frameworks such as Struts, Tapestry, Rails, et cetera, you must be asking yourself, "Why another framework? Does Lift really solve problems any differently or more effectively than the ones I’ve used before?" Based on our experience (and that of others in the growing Lift community), the answer is an emphatic, "Yes!" Lift has cherry-picked the best ideas from a number of other frameworks, while creating some novel ideas of its own. It’s this combination of a solid foundation and new techniques that makes Lift so powerful. At the same time, Lift has been able to avoid the mistakes made in the past by other frameworks. In the spirit of “convention over configuration,” Lift has sensible defaults for everything while making it easy to customize precisely what you need to: no more and no less. Gone are the days of XML file after XML file providing <i>basic configuration</i> for your application. Instead, a simple Lift app requires only that you add the LiftFilter to your web.xml and add one or more lines telling Lift what package your classes sit in (Section <a class="Reference" href="#sec:Bootstrap">3.2↓</a>). The methods you code aren’t required to implement a specific interface (called a trait), although there are support traits that make things that much simpler. In short, you don’t need to write anything that isn’t explicitly necessary for the task at hand. Lift is intended to work out of the box, and to make you as efficient and productive as possible.
</div>
<div class="Indented">
One of the key strengths of Lift is the clean separation of presentation content and logic, based on the bedrock concept of the Model-View-Controller<a class="IndexReference" name="entry-MVC-0" href="#index-MVC">↓</a> pattern<span class="FootOuter"><span class="SupFootMarker"> [A] </span><span class="HoverFoot"><span class="SupFootMarker"> [A] </span><a class="FlexURL" href="http://java.sun.com/blueprints/patterns/MVC.html">http://java.sun.com/blueprints/patterns/MVC.html</a></span></span>. One of the original Java web application technologies that’s still in use today is JSP, or Java Server Pages<span class="FootOuter"><span class="SupFootMarker"> [B] </span><span class="HoverFoot"><span class="SupFootMarker"> [B] </span><a class="FlexURL" href="http://java.sun.com/products/jsp/">http://java.sun.com/products/jsp/</a></span></span>. JSP allows you to mix HTML and Java code directly within the page. While this may have seemed like a good idea at the start, it has proven to be painful in practice. Putting code in your presentation layer makes it more difficult to debug and understand what is going on within a page, and makes it more difficult for the people writing the HTML portion because the contents aren’t valid HTML. While many modern programming and HTML editors have been modified to accomodate this mess, proper syntax highlighting and validation don’t make up for having to switch back and forth between one or more files to follow the page flow. Lift takes the approach that there should be no code in the presentation layer, but that the presentation layer has to be flexible enough to accomodate any conceivable use. To that end, Lift uses a powerful templating system, à la Wicket<span class="FootOuter"><span class="SupFootMarker"> [C] </span><span class="HoverFoot"><span class="SupFootMarker"> [C] </span><a class="FlexURL" href="http://wicket.apache.org/">http://wicket.apache.org/</a></span></span>, to bind user-generated data into the presentation layer. Lift’s templating is built on the XML processing capabilities of the Scala language<span class="FootOuter"><span class="SupFootMarker"> [D] </span><span class="HoverFoot"><span class="SupFootMarker"> [D] </span>Not only does Scala have extensive library support for XML, but XML syntax is actually part of the language. We’ll cover this in more detail as we go through the book.</span></span>, and allows such things as nested templates, simple injection of user-generated content, and advanced data binding capabilities. For those coming from JSP, Lift’s advanced template and XML processing allows you essentially to write custom tag libraries at a fraction of the cost in time and effort.
</div>
<div class="Indented">
Lift has another advantage over many other web frameworks: it’s designed specifically to leverage the Scala<a class="IndexReference" name="entry-Scala-0" href="#index-Scala">↓</a> programming language. Scala is a relatively new language developed by Martin Odersky<span class="FootOuter"><span class="SupFootMarker"> [E] </span><span class="HoverFoot"><span class="SupFootMarker"> [E] </span>Martin created the Pizza programming language, which led to the Generic Java (GJ) project that was eventually incorporated into Java 1.5. His home page is at <a class="FlexURL" href="http://lamp.epfl.ch/~odersky/">http://lamp.epfl.ch/~odersky/</a></span></span> and his programming language research group at EPFL Switzerland. It compiles to Java bytecode and runs on the JVM, which means that you can leverage the vast ecosystem of Java libraries just as you would with any other Java web framework. At the same time, Scala introduces some very powerful features designed to make you, the developer, more productive. Among these features are an extremely rich type system along with powerful type inference, native XML processing, full support for closures and functions as objects, and an extensive high-level library. The power of the type system together with type inference has led people to call it “the statically-typed dynamic language”<span class="FootOuter"><span class="SupFootMarker"> [F] </span><span class="HoverFoot"><span class="SupFootMarker"> [F] </span><a class="FlexURL" href="http://scala-blogs.org/2007/12/scala-statically-typed-dynamic-language.html">http://scala-blogs.org/2007/12/scala-statically-typed-dynamic-language.html</a></span></span>. That means you can write code as quickly as you can with dynamically-typed languages (e.g. Python, Ruby, etc.), but you have the compile-time type safety of a statically-typed language such as Java. Scala is also a hybrid functional (FP) and object-oriented (OO) language, which means that you can get the power of higher-level functional languages such as Haskell or Scheme while retaining the modularity and reusability of OO components. In particular, the FP concept of immutability is encouraged by Scala, making it well-suited for writing highly-concurrent programs that achieve high throughput scalability. The hybrid model also means that if you haven’t touched FP before, you can gradually ease into it. In our experience, Scala allows you to do more in Lift with fewer lines of code. Remember, Lift is all about making you more productive!
</div>
<div class="Indented">
Lift strives to encompass advanced features in a very concise and straightforward manner. Lift’s powerful support for AJAX and Comet allows you to use Web 2.0 features with very little effort. Lift leverages Scala’s Actor library to provide a message-driven framework for Comet updates. In most cases, adding Comet support to a page involves nothing more than extending a trait<span class="FootOuter"><span class="SupFootMarker"> [G] </span><span class="HoverFoot"><span class="SupFootMarker"> [G] </span>A trait is a Scala construct that’s almost like a Java interface. The main difference is that traits may implement methods and have fields.</span></span> to define the rendering method of your page and adding an extra function call to your links to dispatch the update message. Lift handles all of the back-end and page-side coding to provide the Comet polling. AJAX support includes special handlers for doing AJAX form submission via JSON, and almost any link function can easily be turned into an AJAX version with a few keystrokes. In order to perform all of this client-side goodness, Lift has a class hierarchy for encapsulating JavaScript calls via direct JavaScript, jQuery, and YUI. The nice part is that you, too, can utilize these support classes so that code can be generated for you and you don’t have to put JavaScript logic into your templates.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-1.2">1.2</a> What You Should Know before Starting
</h2>
<div class="Unindented">
First and foremost, this is a book on the Lift framework. There are several things we expect you to be familiar with before continuing:
</div>
<ul>
<li>
The Scala language and standard library. This book is not intended to be an introduction to Scala: there are several very good books available that fill that role. You can find a list of Scala books at the Scala website, <a class="URL" href="http://www.scala-lang.org/node/959">http://www.scala-lang.org/node/959</a>.
</li>
<li>
HTML and XML. Lift relies heavily on XHTML for its template support, so you should understand such things as DocTypes, elements, attributes, and namespaces.
</li>
<li>
General HTTP processing, including GET and POST submission, response codes, and content types.
</li>

</ul>
<h2 class="Section">
<a class="toc" name="toc-Section-1.3">1.3</a> Typographical Conventions
</h2>
<div class="Unindented">
In order to better communicate concepts and techniques in this book, we have adopted the following typographical conventions:
</div>
<div class="List">
<span class="List-entry"><tt>ClassName</tt></span><span class="List-contents">Monospaced typewriter text is used to indicate types, class names, and other code-related information.</span>
</div>
<div class="List">
<span class="List-entry">...</span><span class="List-contents">Ellipses within code listings are used to indicate omission of code to condense listings. Unless otherwise noted, the example code in this book comes from the PocketChange app (Chapter <a class="Reference" href="#cha:PocketChange">2 on page 1↓</a>), which has full source code available on GitHub.</span>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-1.4">1.4</a> For More Information about Lift<a class="Label" name="sec:For-more-information"> </a>
</h2>
<div class="Unindented">
Lift has a very active community of users and developers. Since its inception in early 2007 the community has grown to hundreds of members from all over the world. The project’s leader, David Pollak<span class="FootOuter"><span class="SupFootMarker"> [H] </span><span class="HoverFoot"><span class="SupFootMarker"> [H] </span><a class="FlexURL" href="http://blog.lostlake.org/">http://blog.lostlake.org/</a></span></span>, is constantly attending to the mailing list, answering questions, and taking feature requests. There is a core group of developers who work on the project, but submissions are taken from anyone who makes a good case and can turn in good code. While we strive to cover everything you’ll need to know in this book, there are several additional resources available for information on Lift:
</div>
<ol>
<li>
The first place to look is the Lift website at <a class="FlexURL" href="http://liftweb.net/">http://liftweb.net/</a>. There are links to lots of information on the site. In particular:<ol>
<li>
The Lift Wiki is hosted at <a class="FlexURL" href="http://www.assembla.com/wiki/show/liftweb">http://www.assembla.com/wiki/show/liftweb</a>. The Wiki is maintained not only by David, but also by many active members of the Lift community, including the authors. Portions of this book are inspired by and borrow from content on the Wiki. In particular, it has links to all of the generated documentation not only for the stable branch, but also for the unstable head, if you’re feeling adventurous. There’s also an extensive section of HowTos and articles on advanced topics that cover a wealth of information.
</li>
<li>
The mailing list at <a class="FlexURL" href="http://groups.google.com/group/liftweb">http://groups.google.com/group/liftweb</a> is very active, and if there are things that this book doesn’t cover, you should feel free to ask questions there. There are plenty of very knowledgeable people on the list that should be able to answer your questions. Please post specific questions about the book to the Lift Book Google Group at <a class="FlexURL" href="http://groups.google.com/group/the-lift-book">http://groups.google.com/group/the-lift-book</a>. Anything else that is Lift-specific is fair game for the mailing list.
</li>

</ol>

</li>
<li>
Tim Perrett, another Lift committer, is writing a book on Lift for Manning called <i>Lift in Action</i>. More details can be found at the book’s site at <a class="FlexURL" href="http://www.manning.com/perrett/">http://www.manning.com/perrett/</a>.
</li>
<li>
Lift has an IRC channel at <a class="FlexURL" href="irc://irc.freenode.net/lift">irc://irc.freenode.net/lift</a> that usually has several people on it at any given time. It’s a great place to chat about issues and ideas concerning Lift.
</li>

</ol>
<h2 class="Section">
<a class="toc" name="toc-Section-1.5">1.5</a> Your First Lift Application
</h2>
<div class="Unindented">
We’ve talked a lot about Lift and its capabilities, so now let’s get hands-on and try out an application. Before we start, though, we need to take care of some prerequisites:
</div>
<div class="Description">
<span class="Description-entry">Java 1.5 JDK</span> Lift runs on Scala, which runs on top of the JVM. The first thing you’ll need to install is a modern version of the Java SE JVM, available at <a class="FlexURL" href="http://java.sun.com/">http://java.sun.com/</a>. Recently Scala’s compiler was changed to target Java version 1.5. Version 1.4 is still available as a target, but we’re going to assume you’re using 1.5. Examples in this book have only been tested with Sun’s version of the JDK, although most likely other versions (e.g. Blackdown or OpenJDK) should work with little or no modification. 
</div>
<div class="Description">
<span class="Description-entry">Maven 2</span> Maven<a class="IndexReference" name="entry-Maven-0" href="#index-Maven">↓</a> is a project management tool that has extensive capabilities for building, dependency management, testing, and reporting. We assume that you are familiar with basic Maven usage for compilation, packaging, and testing. If you haven’t used Maven before, you can get a brief overview in appendix <a class="Reference" href="#cha:Maven">A↓</a>. You can download the latest version of Maven from <a class="FlexURL" href="http://maven.apache.org/">http://maven.apache.org/</a>. Brief installation instructions (enough to get us started) are on the download page, at <a class="FlexURL" href="http://maven.apache.org/download.html">http://maven.apache.org/download.html</a>.
</div>
<div class="Description">
<span class="Description-entry">A programming editor</span> This isn’t a strict requirement for this example, but when we start getting into coding, it’s very helpful to have something a little more capable than Notepad. If you’d like a full-blown IDE with support for such things as debugging, continuous compile checking, etc., then there are plugins available on the Scala website at <a class="FlexURL" href="http://www.scala-lang.org/node/91">http://www.scala-lang.org/node/91</a>. The plugins support:
</div>
<ul>
<li class="nested">
<div class="List">
<span class="List-entry">Eclipse</span><span class="List-contents"><a class="FlexURL" href="http://www.eclipse.org/">http://www.eclipse.org/</a> The Scala Plugin developer recommends using the Eclipse Classic version of the IDE</span>
</div>
<div class="List">
<span class="List-entry">NetBeans</span><span class="List-contents"><a class="FlexURL" href="http://www.netbeans.org">http://www.netbeans.org</a> Requires using NetBeans 6.5</span>
</div>
<div class="List">
<span class="List-entry">IntelliJ</span><span class="List-contents">IDEA <a class="FlexURL" href="http://www.jetbrains.com/idea/index.html">http://www.jetbrains.com/idea/index.html</a> Requires Version 8 Beta</span>
</div>
<div class="Unindented">
If you’d like something more lightweight, the Scala language distribution comes with plugins for editors such as Vim, Emacs, jEdit, etc. You can either download the full Scala distribution from <a class="FlexURL" href="http://www.scala-lang.org/">http://www.scala-lang.org/</a> and use the files under <tt>misc/scala-tool-support</tt>, or you can access the latest versions directly via the SVN (Subversion) interface at <a class="FlexURL" href="https://lampsvn.epfl.ch/trac/scala/browser/scala-tool-support/trunk/src">https://lampsvn.epfl.ch/trac/scala/browser/scala-tool-support/trunk/src</a>. Getting these plugins to work in your IDE or editor of choice is beyond the scope of this book.
</div>

</li>

</ul>
<div class="Unindented">
Now that we have the prerequisites out of the way, it’s time to get started. We’re going to leverage Maven’s archetypes<span class="FootOuter"><span class="SupFootMarker"> [I] </span><span class="HoverFoot"><span class="SupFootMarker"> [I] </span>An archetype is essentially a project template for Maven that provides prompt-driven customization of basic attributes.</span></span> to do 99% of the work for us in this example. First, change to whatever directory you’d like to work in:
</div>
<pre class="LyX-Code">
cd work
</pre>
<div class="Unindented">
Next, we use Maven’s <tt>archetype:generate</tt> command to create the skeleton of our project:
</div>
<pre class="LyX-Code">
mvn archetype:generate -U \
  -DarchetypeGroupId=net.liftweb \
  -DarchetypeArtifactId=lift-archetype-blank \
  -DarchetypeVersion=2.0 \
  -DarchetypeRepository=http://scala-tools.org/repo-releases \
  -DgroupId=demo.helloworld \
  -DartifactId=helloworld \
  -Dversion=1.0-SNAPSHOT
</pre>
<div class="Unindented">
Maven should output several pages of text. It may stop and ask you to confirm the properties configuration, in which case you can just hit <tt>&lt;enter&gt;</tt>. At the end you should get a message that says <tt>BUILD SUCCESSFUL</tt>. You’ve now successfully created your first project! Don’t believe us? Let’s run it to confirm:
</div>
<pre class="LyX-Code">
cd helloworld
mvn jetty:run
</pre>
<div class="Unindented">
Maven should produce more output, ending with
</div>
<pre class="LyX-Code">
[INFO] Starting scanner at interval of 5 seconds.
</pre>
<div class="Unindented">
This means that you now have a web server (Jetty<span class="FootOuter"><span class="SupFootMarker"> [J] </span><span class="HoverFoot"><span class="SupFootMarker"> [J] </span><a class="FlexURL" href="http://www.mortbay.org/jetty/">http://www.mortbay.org/jetty/</a></span></span>) running on port 8080 of your machine. Just go to <a class="FlexURL" href="http://localhost:8080/">http://localhost:8080/</a> and you’ll see your first Lift page, the standard “Hello, world!” With just a few simple commands, we’ve built a functional (albeit limited) web app. Let’s go into a little more detail and see exactly how these pieces fit together. First, let’s examine the index page. Whenever Lift serves up a request in which the URL ends with a forward slash, Lift automatically looks for a file called <tt>index.html</tt><span class="FootOuter"><span class="SupFootMarker"> [K] </span><span class="HoverFoot"><span class="SupFootMarker"> [K] </span>Technically, it also searches for some variations on index.html, including any localized versions of the page, but we’ll cover that later in section </span></span> in that directory. For instance, if you tried to go to <tt>http://localhost:8080/test/</tt>, Lift would look for <tt>index.html</tt> under the <tt>test/</tt> directory in your project. The HTML sources will be located under <tt>src/main/webapp/</tt> in your project directory. Here’s the <tt>index.html</tt> file from our Hello World project:
</div>
<div class="Indented">
<div class="listing">
<pre class="listing brush: xml">&lt;lift:surround with="default" at="content"&gt;
  &lt;h2&gt;Welcome to your project!&lt;/h2&gt;
  &lt;p&gt;&lt;lift:helloWorld.howdy /&gt;&lt;/p&gt;
&lt;/lift:surround&gt;
</pre>
</div>

</div>
<div class="Indented">
This may look a little strange at first. For those with some XML experience, you may recognize the use of prefixed elements here. For those who don’t know what a prefixed element is, it’s an XML element of the form
</div>
<pre class="LyX-Code">
&lt;prefix:element&gt;
</pre>
<div class="Unindented">
In our case we have two elements in use: <tt>&lt;lift:surround&gt;</tt> and<tt><br/>
&lt;lift:helloWorld.howdy /&gt;</tt>. Lift assigns special meaning to elements that use the “lift” prefix: they form the basis of lift’s extensive templating support, which we will cover in more detail in section <a class="Reference" href="#sec:Templates">4.1↓</a>. When lift processes an XML template<a class="IndexReference" name="entry-template-0" href="#index-template">↓</a>, it does so from the outermost element inward. In our case, the outermost element is <tt>&lt;lift:surround with=”default” at=”content”&gt;</tt>. The <tt>&lt;lift:surround&gt;</tt> element basically tells Lift to find the template named by the <i>with</i> attribute (<i>default</i>, in our case) and to put the contents of our element inside of that template. The <i>at</i> attribute tells Lift where in the template to place our content. In Lift, this “filling in the blanks” is called <i>binding</i><a class="IndexReference" name="entry-binding-0" href="#index-binding">↓</a>, and it’s a fundamental concept of Lift’s template system. Just about everything at the HTML/XML level can be thought of as a series of nested binds. Before we move on to the <tt>&lt;lift:helloWorld.howdy/&gt;</tt> element, let’s look at the default template. You can find it in the <tt>templates-hidden</tt> directory of the web app. Much like the <tt>WEB-INF</tt> and <tt>META-INF</tt> directories in a Java web application, the contents of <tt>templates-hidden</tt> cannot be accessed directly by clients; they can, however, be accessed when they’re referenced by a <tt>&lt;lift:surround&gt;</tt> element. Here is the <tt>default.html</tt> file:
</div>
<div class="Indented">
<div class="listing">
<pre class="listing brush: scala">&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:lift="http://liftweb.net/"&gt;
  &lt;head&gt;
    &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8" /&gt;
    &lt;meta name="description" content="" /&gt;
    &lt;meta name="keywords" content="" /&gt;
                
    &lt;title&gt;demo.helloworld:helloworld:1.0-SNAPSHOT&lt;/title&gt;
    &lt;script id="jquery" src="/classpath/jquery.js" type="text/javascript"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;lift:bind name="content" /&gt;
    &lt;lift:Menu.builder /&gt;
    &lt;lift:msgs/&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

</div>
<div class="Indented">
As you can see in the listing, this is a proper XHTML file, with <tt>&lt;html&gt;</tt>, <tt>&lt;head&gt;</tt>, and <tt>&lt;body&gt;</tt> tags. This is required since Lift doesn’t add these itself. Lift simply processes the XML from each template it encounters. The <tt>&lt;head&gt;</tt> element and its contents are boilerplate; the interesting things happen inside the <tt>&lt;body&gt;</tt> element. There are three elements here:
</div>
<ol>
<li>
The <tt>&lt;lift:bind name=”content” /&gt;</tt> element determines where the contents of our <tt>index.html</tt> file are bound (inserted). The <i>name</i> attribute should match the corresponding <i>at</i> attribute from our <tt>&lt;lift:surround&gt;</tt> element.
</li>
<li>
The <tt>&lt;lift:Menu.builder /&gt;</tt> element is a special element that builds a menu based on the SiteMap<a class="IndexReference" name="entry-SiteMap-0" href="#index-SiteMap">↓</a> (to be covered in chapter <a class="Reference" href="#cha:SiteMap">7↓</a>). The SiteMap is a high-level site directory component that not only provides a centralized place to define a site menu, but allows you to control when certain links are displayed (based on, say, whether users are logged in or what roles they have) and provides a page-level access control mechanism.
</li>
<li>
The <tt>&lt;lift:msgs /&gt;</tt> element allows Lift (or your code) to display messages on a page as it’s rendered. These could be status messages, error messages, etc. Lift has facilities to set one or more messages from inside your logic code.
</li>

</ol>
<div class="Unindented">
Now let’s look back at the <tt>&lt;lift:helloWorld.howdy /&gt;</tt> element from the <tt>index.html</tt> file. This element (and the <tt>&lt;lift:Menu.builder /&gt;</tt> element, actually) is called a <i>snippet</i>, and it’s of the form
</div>
<pre class="LyX-Code">
&lt;lift:class.method&gt;
</pre>
<div class="Unindented">
Where <tt>class</tt> is the name of a Scala class defined in our project in the <tt>demo.helloworld.snippets</tt> package and <tt>method</tt> is a method defined on that class. Lift does a little translation on the class name to change camel-case back into title-case and then locates the class. In our demo the class is located under <tt>src/main/scala/demo/helloworld/snippet/HelloWorld.scala</tt>, and is shown here:
</div>
<div class="Indented">
<div class="listing">
<pre class="listing brush: scala">package demo.helloworld.snippet
​
class HelloWorld {
  def howdy = &lt;span&gt;Welcome to helloworld at 
    {new _root_.java.util.Date}&lt;/span&gt;
}
</pre>
</div>

</div>
<div class="Indented">
As you can see, the howdy method is pretty straightforward. Lift binds the result of executing the method (in this case a <tt>span</tt>) into the location of the snippet element. It’s interesting to note that a method may itself return other <tt>&lt;lift:...&gt;</tt> elements in its content and they will be processed as well. This recursive nature of template composition is part of the fundamental power of Lift; it means that reusing snippets and template pieces across your application is essentially free. You should never have to write the same functionality more than once.
</div>
<div class="Indented">
Now that we’ve covered all of the actual content elements, the final piece of the puzzle is the <tt>Boot<a class="IndexReference" name="entry-Boot-0" href="#index-Boot">↓</a></tt> class. The <tt>Boot</tt> class is responsible for the configuration and setup of the Lift framework. As we’ve stated earlier in the chapter, most of Lift has sensible defaults, so the <tt>Boot</tt> class generally contains only the extras that you need. The <tt>Boot</tt> class is always located in the <tt>bootstrap.liftweb</tt> package and is shown here (we’ve skipped imports, etc):
</div>
<div class="Indented">
<div class="listing">
<pre class="listing brush: scala">package bootstrap.liftweb
​
import net.liftweb.util._
import net.liftweb.http._
import net.liftweb.sitemap._
import net.liftweb.sitemap.Loc._
import Helpers._
 
/**
  * A class that’s instantiated early and run.  It allows the application
  * to modify Lift’s environment
  */
class Boot {
  def boot {
    // where to search snippet
    LiftRules.addToPackages("demo.helloworld")     
​
    // Build SiteMap
    val entries = 
      Menu(Loc("Home", List("index"), "Home")) :: 
      Nil 
    LiftRules.setSiteMap(SiteMap(entries:_*))
  }
}
</pre>
</div>

</div>
<div class="Indented">
There are two basic configuration elements, placed in the <tt>boot </tt>method. The first is the 
</div>
<div class="Indented">
<tt>LiftRules.addToPackages</tt> method. It tells lift to base its searches in the <tt>demo.helloworld</tt> package. That means that snippets would be located in the <tt>demo.helloworld.snippets</tt> package, views (section <a class="Reference" href="#sec:Views">4.4↓</a>) would be located in the <tt>demo.helloworld.views</tt> package, etc. If you have more than one hierarchy (i.e. multiple packages), you can just call <tt>addToPackages</tt> multiple times. The second item in the Boot class is the SiteMenu setup. Obviously this is a pretty simple menu in this demo, but we’ll cover more interesting examples in the SiteMap chapter.
</div>
<div class="Indented">
Now that we’ve covered a basic example we hope you’re beginning to see why Lift is so powerful and why it can make you more productive. We’ve barely scratched the surface of Lift’s templating and binding capabilities, but what we’ve shown here is already a big step. In roughly ten lines of Scala code and about thirty in XML, we have a functional site. If we wanted to add more pages, we’ve already got our default template set up so we don’t need to write the same boilerplate HTML multiple times. In our example we’re directly generating the content for our <tt>helloWorld.howdy</tt> snippet, but in later examples we’ll show just how easy it is to pull content <i>from the template itself</i> into the snippet and modify it as needed.
</div>
<div class="Indented">
In the following chapters we’ll be covering
</div>
<ul>
<li>
Much more complex templating and snippet binding, including input forms and programmatic template selection
</li>
<li>
How to use SiteMap and its ancillary classes to provide a context-aware site menu and access control layer
</li>
<li>
How to handle state within your application
</li>
<li>
Lift’s ORM layer, Mapper (Chapter <a class="Reference" href="#cha:mapper_and_record">8↓</a>), which provides a powerful yet lightweight interface to databases
</li>
<li>
Advanced AJAX and Comet support in Lift for Web 2.0 style applications
</li>

</ul>
<div class="Unindented">
We hope you’re as excited about getting started with Lift as we are!
</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-2">2</a> PocketChange<a class="Label" name="cha:PocketChange"> </a>
</h1>
<div class="Unindented">
As a way to demonstrate the concepts in the book, we’re going to build a basic application and then build on it as we go along. As it evolves, so will your understanding of Lift. The application we’ve picked is an Expense Tracker. We call it <i>PocketChange.</i>
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="Figure-2.1"> </a><div class="figure">
<div class="center">
<img class="embedded" src="images/pocketchange.png" alt="figure images/pocketchange.png" style="width: 6in; max-width: 966px; height: auto; max-height: 488px;"/>

</div>
<div class="caption">
Figure 2.1 The PocketChange App
</div>

</div>

</div>

</div>
<div class="Indented">
PocketChange will track your expenses, keep a running total of what you’ve spent, allow you to organize your data using tags, and help you to visualize the data. During the later chapters of the book we’ll add a few fun features, such as AJAX charting and allowing multiple people per account (with Comet update of entries). Above all, we want to keep the interface lean and clean.
</div>
<div class="Indented">
We’re going to be using the <i>View First</i> pattern for the design of our app, because Lift’s separation of presentation and logic via templating, views, and snippets lends itself to the <i>View First</i> pattern so well. For an excellent article on the design decisions behind Lift’s approach to templating and logic, read David Pollak’s <i>Lift View First </i>article on the Wiki<span class="FootOuter"><span class="SupFootMarker"> [L] </span><span class="HoverFoot"><span class="SupFootMarker"> [L] </span><a class="FlexURL" href="http://www.assembla.com/wiki/show/liftweb/View_First">http://www.assembla.com/wiki/show/liftweb/View_First</a></span></span>.
</div>
<div class="Indented">
Another important thing to note is that we’re going to breeze through the app and touch on a lot of details. We’ll provide plenty of references to the chapters where things are covered. This chapter is really intended just to give you a taste of Lift, so feel free to read ahead if you want more information on how something works. The full source for the entire PocketChange application is available at GitHub<span class="FootOuter"><span class="SupFootMarker"> [M] </span><span class="HoverFoot"><span class="SupFootMarker"> [M] </span><a class="FlexURL" href="http://github.com/tjweir/pocketchangeapp">http://github.com/tjweir/pocketchangeapp</a></span></span>. Enough chatter, let’s go!
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-2.1">2.1</a> Defining the Model
</h2>
<div class="Unindented">
The first step we’ll take is to define the database entities that we’re going to use for our app. The base functionality of a categorized expense tracker is covered by the following items:
</div>
<ul>
<li>
User: A user of the application
</li>
<li>
Account: A specific expense account - we want to support more than one per user
</li>
<li>
Expense: A specific expense transaction tied to a particular account
</li>
<li>
Tag: A word or phrase that permits us a to categorize each expense for later searching and reporting
</li>

</ul>
<div class="Unindented">
We’ll start out with the User, as shown in listing <a class="Reference" href="#lst:PocketChange-User-entity">2.1↓</a>. We leverage Lift’s MegaProtoUser (Section <a class="Reference" href="#sub:ProtoUser-and-MegaProtoUser">8.2.8 on page 1↓</a>) class to handle pretty much everything we need for user management. For example, with just the code you see, we define an entire user management function for our site, including a signup page, a lost password page, and a login page. The accompanying SiteMap (Section <a class="Reference" href="#cha:SiteMap">7 on page 1↓</a>) menus are generated with a single call to <tt>User.siteMap</tt>. As you can see, we can customize the XHTML that’s generated for the user management pages with a few simple defs. The opportunities for customization provided by MetaMegaProtoUser are extensive.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
The PocketChange User Entity<a class="Label" name="lst:PocketChange-User-entity"> </a>
</div>
<pre class="listing brush: scala">package com.pocketchangeapp.model
​
// Import all of the mapper classes
import _root_.net.liftweb.mapper._
​
// Create a User class extending the Mapper base class
// MegaProtoUser, which provides default fields and methods
// for a site user.
class User extends MegaProtoUser[User] {
  def getSingleton = User // reference to the companion object below
  def allAccounts : List[Account] = 
    Account.findAll(By(Account.owner, this.id))
}
​
// Create a "companion object" to the User class (above).
// The companion object is a "singleton" object that shares the same
// name as its companion class. It provides global (i.e. non-instance)
// methods and fields, such as find, dbTableName, dbIndexes, etc.
// For more, see the Scala documentation on singleton objects
object User extends User with MetaMegaProtoUser[User] {
  override def dbTableName = "users" // define the DB table name
​
  // Provide our own login page template.
  override def loginXhtml =
    &lt;lift:surround with="default" at="content"&gt;
      { super.loginXhtml }
    &lt;/lift:surround&gt;
​
  // Provide our own signup page template.
  override def signupXhtml(user: User) = 
    &lt;lift:surround with="default" at="content"&gt;
      { super.signupXhtml(user) }
    &lt;/lift:surround&gt;
}
</pre>
</div>

</div>
<div class="Indented">
Note that we’ve also added a utility method, <tt>allAccounts</tt>, to the User class to retrieve all of the accounts for a given user. We use the MetaMapper.findAll method to do a query by owner ID (Section <a class="Reference" href="#sub:Querying-for-Entities">8.1.8 on page 1↓</a>) supplying this user’s ID as the owner ID.
</div>
<div class="Indented">
Defining the Account entity is a little more involved, as shown in Listing <a class="Reference" href="#lst:PocketChange-Account-entity">2.1↓</a>. Here we define a class with a Long primary key and some fields associated with the accounts. We also define some helper methods for object relationship joins (Section <a class="Reference" href="#sub:helper-joins">8.1.11 on page 1↓</a>). The Expense and Tag entities (along with some ancillary entities) follow suit, so we won’t cover them here.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
The PocketChange Account Entity<a class="Label" name="lst:PocketChange-Account-entity"> </a>
</div>
<pre class="listing brush: scala">package com.pocketchangeapp.model
​
import _root_.java.math.MathContext
import _root_.net.liftweb.mapper._
import _root_.net.liftweb.util.Empty
​
// Create an Account class extending the LongKeyedMapper superclass
// (which is a "mapped" (to the database) trait that uses a Long primary key)
// and mixes in trait IdPK, which adds a primary key called "id".
class Account extends LongKeyedMapper[Account] with IdPK {
  // Define the singleton, as in the "User" class
  def getSingleton = Account
​
  // Define a many-to-one (foreign key) relationship to the User class
  object owner extends MappedLongForeignKey(this, User) {
    // Change the default behavior to add a database index 
    // for this column.
    override def dbIndexed_? = true
  }
​
  // Define an "access control" field that defaults to false. We’ll
  // use this in the SiteMap chapter to allow the Account owner to
  // share out an account view.
  object is_public extends MappedBoolean(this) {
    override def defaultValue = false
  }
​
  // Define the field to hold the actual account balance with up to 16
  // digits (DECIMAL64) and 2 decimal places
  object balance extends MappedDecimal(this, MathContext.DECIMAL64, 2)
​
  
  object name extends MappedString(this,100)
  object description extends MappedString(this, 300)
  
  // Define utility methods for simplifying access to related classes. We’ll 
  // cover how these methods work in the Mapper chapter
  def admins = AccountAdmin.findAll(By(AccountAdmin.account, this.id))
  def addAdmin (user : User) = 
    AccountAdmin.create.account(this).administrator(user).save
  def viewers = AccountViewer.findAll(By(AccountViewer.account, this.id))
  def entries = Expense.getByAcct(this, Empty, Empty, Empty)
  def tags = Tag.findAll(By(Tag.account, this.id))
  def notes = AccountNote.findAll(By(AccountNote.account, this.id))
}
​
// The companion object to the above Class
object Account extends Account with LongKeyedMetaMapper[Account] {
  // Define a utility method for locating an account by owner and name
  def findByName (owner : User, name : String) : List[Account] = 
    Account.findAll(By(Account.owner, owner.id.is), By(Account.name, name))
​
  ... more utility methods ...
}
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-2.2">2.2</a> Our First Template
</h2>
<div class="Unindented">
Our next step is to figure out how we’ll present this data to the user. We’d like to have a home page on the site that shows, depending on whether the user is logged in, either a welcome message or a summary of account balances with a place to enter new expenses. Listing <a class="Reference" href="#lst:The-welcome-template">2.2↓</a> shows a basic template to handle this. We’ll save this as <tt>index.html</tt>. The astute reader will notice that we have a head element but no body. This is XHTML, so how does that work? This template uses the <tt>&lt;lift:surround&gt;</tt> tag (Section <a class="Reference" href="#sub:surround-tag">4.5.17 on page 1↓</a>) to embed itself into a master template (<tt>/templates_hidden/default</tt>). Lift actually does what’s called a “head merge” (Section <a class="Reference" href="#sec:Head-Merge"> on page 1↓</a>) to merge the contents of the <tt>head</tt> tag in our template below with the <tt>head</tt> element of the master template. The <tt>&lt;lift:HomePage.summary&gt;</tt> and <tt>&lt;lift:AddEntry.addentry&gt;</tt> tags are calls to snippet methods. Snippets are the backing Scala code that provides the actual page logic. We’ll be covering them in the next section.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
The Welcome Template<a class="Label" name="lst:The-welcome-template"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:surround with="default" at="content"&gt;
&lt;head&gt;
  &lt;!-- include the required plugins --&gt;
  &lt;script type="text/javascript" src="/scripts/date.js"&gt;&lt;/script&gt;
  &lt;!--[if IE]&gt;
  &lt;script type="text/javascript" src="/scripts/jquery.bgiframe.js"&gt;
  &lt;/script&gt;
  &lt;![endif]--&gt;
​
  &lt;!-- include the jQuery DatePicker JavaScript and CSS --&gt;
  &lt;script type="text/javascript" src="/scripts/jquery.datePicker.js"&gt;
  &lt;/script&gt;
  &lt;link rel="stylesheet" type="text/css" href="/style/datePicker.css" /&gt;
&lt;/head&gt;
    &lt;!-- The contents of this element will be passed to the summary method
         in the HomePage snippet. The call to bind in that method will 
         replace the XML tags below (e.g. account:name) with the account 
         data and return a NodeSeq to replace the lift:HomePage.summary 
         element. --&gt;
    &lt;lift:HomePage.summary&gt;
      &lt;div class="column span-24 bordered"&gt;
        &lt;h2&gt;Summary of accounts:&lt;/h2&gt;
        &lt;account:entry&gt;
          &lt;acct:name /&gt; : &lt;acct:balance /&gt; &lt;br/&gt;
        &lt;/account:entry&gt;
      &lt;/div&gt;   
      &lt;hr /&gt;
    &lt;/lift:HomePage.summary&gt;
​
    &lt;div class="column span-24"&gt;
      &lt;!-- The contents of this element will be passed into the add method 
           in the AddEntry snippet. A form element with method "POST" will
           be created and the XML tags (e.g. e:account) below will be
           replaced with form elements via the call to bind in the add 
           method. This form will replace the lift:AddEntry.addentry element
           below. --&gt;
      &lt;lift:AddEntry.addentry form="POST"&gt;
        &lt;div id="entryform"&gt;
          &lt;div class="column span-24"&gt;&lt;h3&gt;Entry Form&lt;/h3&gt;
            &lt;e:account /&gt; &lt;e:dateOf /&gt; &lt;e:desc /&gt; &lt;e:value /&gt;
            &lt;e:tags/&gt;&lt;button&gt;Add $&lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/lift:AddEntry.addentry&gt;
    &lt;/div&gt;
​
    &lt;script type="text/javascript"&gt;
      Date.format = ’yyyy/mm/dd’;
      jQuery(function () {
        jQuery(’#entrydate’).datePicker({startDate:’00010101’, 
                                        clickInput:true});
      })
    &lt;/script&gt;
&lt;/lift:surround&gt;
</pre>
</div>

</div>
<div class="Indented">
As you can see, there’s no control logic at all in our template, just well-formed XML and some JavaScript to activate the jQuery datePicker functionality.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-2.3">2.3</a> Writing Snippets
</h2>
<div class="Unindented">
Now that we have a template, we need to write the HomePage and AddEntry snippets so that we can actually do something with the site. First, let’s look at the HomePage snippet, shown in Listing <a class="Reference" href="#lst:Defining-the-summary-snippet">2.3↓</a>. We’ve skipped the standard Lift imports (Listing <a class="Reference" href="#lst:Standard-import-statements">3.3↓</a>) to save space, but we’ve specifically imported <tt>java.util.Date</tt> and all of our Model classes.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Defining the Summary Snippet<a class="Label" name="lst:Defining-the-summary-snippet"> </a>
</div>
<pre class="listing brush: scala">package com.pocketchangeapp.snippet
​
import ... standard imports ...
import _root_.com.pocketchangeapp.model._
import _root_.java.util.Date
​
class HomePage {
  // User.currentUser returns a "Box" object, which is either Full
  // (i.e. contains a User), Failure (contains error data), or Empty.
  // The Scala match method is used to select an action to take based
  // on whether the Box is Full, or not ("case _" catches anything
  // not caught by "case Full(user)". See Box in the Lift API. We also
  // briefly discuss Box in Appendix C.
  def summary (xhtml : NodeSeq) : NodeSeq = User.currentUser match {
    case Full(user) =&gt; {
      val entries : NodeSeq = user.allAccounts match {
        case Nil =&gt; Text("You have no accounts set up") 
        case accounts =&gt; accounts.flatMap({account =&gt; 
          bind("acct", chooseTemplate("account", "entry", xhtml),
               "name" -&gt; &lt;a href={"/account/" + account.name.is}&gt;
                           {account.name.is}&lt;/a&gt;,
               "balance" -&gt; Text(account.balance.toString))
        })
      }
      bind("account", xhtml, "entry" -&gt; entries)
    }
    case _ =&gt; &lt;lift:embed what="welcome_msg" /&gt;
  }
}
</pre>
</div>

</div>
<div class="Indented">
Our first step is to use the <tt>User.currentUser</tt> method (this method is provided by the <tt>MetaMegaProtoUser</tt> trait) to determine if someone is logged in. This method returns a “Box,” which is either Full (with a User) or Empty. (A third possibility is a Failure, but we’ll ignore that for now.) If it is full, then a user is logged in and we use the <tt>User.allAccounts</tt> method to retrieve a <tt>List</tt> of all of the user’s accounts. If the user doesn’t have accounts, we return an XML text node saying so that will be bound where our tag was placed in the template. If the user does have accounts, then we map the accounts into XHTML using the bind function. For each account, we bind the name of the account where we’ve defined the <tt>&lt;acct:name&gt;</tt> tag in the template, and the balance where we defined <tt>&lt;acct:balance&gt;</tt>. The resulting List of XML NodeSeq entities is used to replace the <tt>&lt;lift:HomePage.summary&gt;</tt> element in the template. Finally, we match the case where a user isn’t logged in by embedding the contents of a welcome template (which may be further processed). Note that we can nest Lift tags in this manner and they will be recursively parsed.
</div>
<div class="Indented">
Of course, it doesn’t do us any good to display account balances if we can’t add expenses, so let’s define the <tt>AddEntry</tt> snippet. The code is shown in Listing <a class="Reference" href="#lst:The-addEntry-snippet">2.3↓</a>. This looks different from the HomePage snippet primarily because we’re using a <tt>StatefulSnippet</tt> (Section <a class="Reference" href="#sub:Stateless-versus-Stateful">5.3.3 on page 1↓</a>). The primary difference is that with a <tt>StatefulSnippet</tt> the same “instance” of the snippet is used for each page request in a given session, so we can keep the variables around in case we need the user to fix something in the form. The basic structure of the snippet is the same as for our summary: we do some work (we’ll cover the <tt>doTagsAndSubmit</tt> function in a moment) and then bind values back into the template. In this snippet, however, we use the <tt>SHtml.select</tt> and <tt>SHtml.text</tt> methods to generate form fields. The <tt>text</tt> fields simply take an initial value and a function (closure) to process the value on submission. The <tt>select</tt> field is a little more complex because we give it a list of options, but otherwise it is the same concept.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
The AddEntry Snippet<a class="Label" name="lst:The-addEntry-snippet"> </a>
</div>
<pre class="listing brush: scala">package com.pocketchangeapp.snippet
​
import ... standard imports ...
import com.pocketchangeapp.model._
import com.pocketchangeapp.util.Util
​
import java.util.Date
​
/* date | desc | tags | value */ 
class AddEntry extends StatefulSnippet {
  // This maps the "addentry" XML element to the "add" method below
  def dispatch = {
    case "addentry" =&gt; add _
  }
​
  var account : Long = _
  var date = ""
  var desc = ""
  var value = ""
  // S.param("tag") returns a "Box" and the "openOr" method returns
  // either the contents of that box (if it is "Full"), or the empty
  // String passed to it, if the Box is "Empty". The S.param method
  // returns parameters passed by the browser. In this instance, the
  // name of the parameter is "tag".
  var tags = S.param("tag") openOr ""
  
  def add(in: NodeSeq): NodeSeq = User.currentUser match {
    case Full(user) if user.editable.size &gt; 0 =&gt; {
      def doTagsAndSubmit(t: String) {
        tags = t
        if (tags.trim.length == 0) 
          S.error("We’re going to need at least one tag.")
        else {
          // Get the date correctly, comes in as yyyy/mm/dd
          val entryDate = Util.slashDate.parse(date)
          val amount = BigDecimal(value)
          val currentAccount = Account.find(account).open_!
​
          // We need to determine the last serial number and balance
          // for the date in question. This method returns two values
          // which are placed in entrySerial and entryBalance
          // respectively
          val (entrySerial, entryBalance) = 
            Expense.getLastExpenseData(currentAccount, entryDate)
      
          val e = Expense.create.account(account)
                    .dateOf(entryDate)
                    .serialNumber(entrySerial + 1)
                    .description(desc)
                    .amount(BigDecimal(value)).tags(tags)
                    .currentBalance(entryBalance + amount)
​
          // The validate method returns Nil if there are no errors,
          // or an error message if errors are found.
          e.validate match {
            case Nil =&gt; {
              Expense.updateEntries(entrySerial + 1, amount)
              e.save
              val acct = Account.find(account).open_!
              val newBalance = acct.balance.is + e.amount.is
              acct.balance(newBalance).save
              S.notice("Entry added!")
              // remove the statefullness of this snippet
              unregisterThisSnippet() 
            }
            case x =&gt; error(x)
          }
        }
      }
​
      val allAccounts =
        user.allAccounts.map(acct =&gt; (acct.id.toString, acct.name))
​
      // Parse through the NodeSeq passed as "in" looking for tags
      // prefixed with "e". When found, replace the tag with a NodeSeq
      // according to the map below (name -&gt; NodeSeq)
      bind("e", in, 
        "account" -&gt; select(allAccounts, Empty,
                            id =&gt; account = id.toLong),
        "dateOf" -&gt; text(Util.slashDate.format(new Date()).toString,
                         date = _,
                         "id" -&gt; "entrydate"),
        "desc" -&gt; text("Item Description", desc = _),
        "value" -&gt; text("Value", value = _),
        "tags" -&gt; text(tags, doTagsAndSubmit))
    }
    // If no user logged in, return a blank Text node
    case _ =&gt; Text("")
  }
}
</pre>
</div>

</div>
<div class="Indented">
The <tt>doTagsAndSubmit</tt> function is a new addition. Its primary purpose is to process all of the submitted data, create and validate an <tt>Expense</tt> entry, and then return to the user. This pattern of defining a local function to handle form submission is quite common as opposed to defining a method on your class. The main reason is that by defining the function locally, it becomes a closure on any variables defined in the scope of your snippet function.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-2.4">2.4</a> A Little AJAX Spice
</h2>
<div class="Unindented">
So far this is all pretty standard fare, so let’s push things a bit and show you some more advanced functionality. Listing <a class="Reference" href="#lst:Displaying-an-Expense-table">2.4↓</a> shows a template for displaying a table of Expenses for the user with an optional start and end date. The <tt>Accounts.detail</tt> snippet will be defined later in this section.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Displaying an Expense Table<a class="Label" name="lst:Displaying-an-Expense-table"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:surround with="default" at="content"&gt;
  &lt;lift:Accounts.detail eager_eval="true"&gt; 
  &lt;div class="column span-24"&gt;
  &lt;h2&gt;Summary&lt;/h2&gt;
    &lt;table&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Balance&lt;/th&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;td&gt;&lt;acct:name /&gt;&lt;/td&gt;&lt;td&gt;&lt;acct:balance /&gt;&lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;
  &lt;div&gt;
    &lt;h3&gt;Filters:&lt;/h3&gt;
    &lt;table&gt;&lt;tr&gt;&lt;th&gt;Start Date&lt;/th&gt;&lt;td&gt;&lt;acct:startDate /&gt;&lt;/td&gt;
               &lt;th&gt;End Date&lt;/th&gt;&lt;td&gt;&lt;acct:endDate /&gt;&lt;/td&gt;&lt;/tr&gt;
    &lt;/table&gt;
  &lt;/div&gt;
​
  &lt;div class="column span-24" &gt;
    &lt;h2&gt;Transactions&lt;/h2&gt;
    &lt;lift:embed what="entry_table" /&gt;
  &lt;/div&gt;
  &lt;/lift:Accounts.detail&gt;
&lt;/lift:surround&gt;
</pre>
</div>

</div>
<div class="Indented">
The &lt;lift:embed&gt; tag (Section <a class="Reference" href="#sub:embed-tag">4.5.7 on page 1↓</a>) allows you to include another template at that point. In our case, the entry_table template is shown in Listing <a class="Reference" href="#lst:Embedded-Expense-table">2.4↓</a>. This is really just a fragment and is not intended to be used alone, since it’s not a full XHTML document and it doesn’t surround itself with a master template. It does, however, provide binding sites that we can fill in.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
The Embedded Expense Table<a class="Label" name="lst:Embedded-Expense-table"> </a>
</div>
<pre class="listing brush: xml">&lt;table class="" border="0" cellpadding="0" cellspacing="1" 
    width="100%"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Date&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;th&gt;Tags&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;
      &lt;th&gt;Balance&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody id="entry_table"&gt;
    &lt;acct:table&gt;
      &lt;acct:tableEntry&gt;
    &lt;tr&gt;&lt;td&gt;&lt;entry:date /&gt;&lt;/td&gt;&lt;td&gt;&lt;entry:desc /&gt;&lt;/td&gt;
        &lt;td&gt;&lt;entry:tags /&gt;&lt;/td&gt;&lt;td&gt;&lt;entry:amt /&gt;&lt;/td&gt;
        &lt;td&gt;&lt;entry:balance /&gt;&lt;/td&gt;
    &lt;/tr&gt;
      &lt;/acct:tableEntry&gt;
    &lt;/acct:table&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</pre>
</div>

</div>
<div class="Indented">
Before we get into the AJAX portion of the code, let’s define a helper method in our Accounts snippet class, shown in Listing <a class="Reference" href="#lst:The-table-helper-function">2.4↓</a>, to generate the XHTML table entries that we’ll be displaying (assuming normal imports). Essentially, this function pulls the contents of the <tt>&lt;acct:tableEntry&gt;</tt> tag (via the <tt>Helpers.chooseTemplate</tt> method, Section <a class="Reference" href="#sec:BindHelpers">C.8 on page 1↓</a>) and binds each <tt>Expense</tt> from the provided list into it. As you can see in the <tt>entry_table</tt> template, that corresponds to one table row for each entry.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
The Table Helper Function<a class="Label" name="lst:The-table-helper-function"> </a>
</div>
<pre class="listing brush: scala">package com.pocketchangeapp.snippet
... imports ...
​
class Accounts {
  ...
  def buildExpenseTable(entries : List[Expense], template : NodeSeq) = {
    // Calls bind repeatedly, once for each Entry in entries
    entries.flatMap({ entry =&gt;
      bind("entry", chooseTemplate("acct", "tableEntry", template),
           "date" -&gt; Text(Util.slashDate.format(entry.dateOf.is)),
           "desc" -&gt; Text(entry.description.is),
           "tags" -&gt; Text(entry.tags.map(_.tag.is).mkString(", ")),
           "amt" -&gt; Text(entry.amount.toString),
           "balance" -&gt; Text(entry.currentBalance.toString))
   })
  }
  ...
}
</pre>
</div>

</div>
<div class="Indented">
The final piece is our <tt>Accounts.detail</tt> snippet, shown in Listing <a class="Reference" href="#lst:Our-Ajax-snippet">2.4↓</a>. We start off with some boilerplate calls to match to locate the <tt>Account</tt> to be viewed, then we define some vars to hold state. It’s important that they’re vars so that they can be captured by the <tt>entryTable</tt>, <tt>updateStartDate</tt>, and <tt>updateEndDate</tt> closures, as well as the AJAX form fields that we define. The only magic we have to use is the <tt>SHtml.ajaxText</tt> form field generator (Chapter <a class="Reference" href="#cha:AJAX-and-COMET">11 on page 1↓</a>), which will turn our update closures into AJAX callbacks. The values returned from these callbacks are JavaScript code that will be run on the client side. You can see that in a few lines of code we now have a page that will automatically update our Expense table when you set the start or end dates!
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Our AJAX Snippet<a class="Label" name="lst:Our-Ajax-snippet"> </a>
</div>
<pre class="listing brush: scala">package com.pocketchangeapp.snippet
​
import ... standard imports ...
import com.pocketchangeapp.model._
import com.pocketchangeapp.util.Util
​
class Accounts {
  def detail (xhtml: NodeSeq) : NodeSeq = S.param("name") match {
    // If the "name" param was passed by the browser...
    case Full(acctName) =&gt; {
      // Look for an account by that name for the logged in user
      Account.findByName(User.currentUser.open_!, acctName) match {
        // If an account is returned (as a List)
        case acct :: Nil =&gt; {
          // Some closure state for the AJAX calls
          // Here is Lift’s "Box" in action: we are creating
          // variables to hold Date Boxes and initializing them
          // to "Empty" (Empty is a subclass of Box)
          var startDate : Box[Date] = Empty
          var endDate : Box[Date] = Empty
​
          // AJAX utility methods. Defined here to capture the closure
          // vars defined above
          def entryTable = buildExpenseTable(
            Expense.getByAcct(acct, startDate, endDate, Empty),
            xhtml)
​
          def updateStartDate (date : String) = {
            startDate = Util.parseDate(date, Util.slashDate.parse)
            JsCmds.SetHtml("entry_table", entryTable)
          }
​
          def updateEndDate (date : String) = {
            endDate = Util.parseDate(date, Util.slashDate.parse)
            JsCmds.SetHtml("entry_table", entryTable)
          }
​
          // Bind the data to the passed in XML elements with
          // prefix "acct" according to the map below.
          bind("acct", xhtml, 
            "name" -&gt; acct.name.asHtml,
            "balance" -&gt; acct.balance.asHtml,
            "startDate" -&gt; SHtml.ajaxText("", updateStartDate),
            "endDate" -&gt; SHtml.ajaxText("", updateEndDate),
            "table" -&gt; entryTable)
        }
        // An account name was provided but did not match any of
        // the logged in user’s accounts
        case _ =&gt; Text("Could not locate account " + acctName)
      }
    }
    // The S.param "name" was empty
    case _ =&gt; Text("No account name provided")
  }
}
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-2.5">2.5</a> Conclusion
</h2>
<div class="Unindented">
We hope that this chapter has demonstrated how powerful Lift can be while remaining concise and easy to use. Don’t worry if there’s something you didn’t understand, we’ll be explaining in more detail as we go along. We’ll continue to expand on this example app throughout the book, so feel free to make this chapter a base reference, or pull your own version of PocketChange from the git repository with the following command (assuming you have git installed):
</div>
<pre class="LyX-Code">
git clone <a class="FlexURL" href="git://github.com/tjweir/pocketchangeapp.git">git://github.com/tjweir/pocketchangeapp.git</a>
</pre>
<div class="Unindented">
Now let’s dive in!
</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-3">3</a> Lift Fundamentals<a class="Label" name="cha:Lift-Architecture"> </a>
</h1>
<div class="Unindented">
In this chapter we will cover some of the fundamental aspects of writing a lift application, including the architecture of the Lift library and how it processes requests.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.1">3.1</a> Entry into Lift<a class="Label" name="sec:Entry-into-Lift"> </a>
</h2>
<div class="Unindented">
The first step in Lift’s request processing is intercepting the HTTP request. Originally, Lift used a <tt>java.servlet.Servlet</tt> instance to process incoming requests. This was changed to use a <tt>java.servlet.Filter</tt> instance<span class="FootOuter"><span class="SupFootMarker"> [N] </span><span class="HoverFoot"><span class="SupFootMarker"> [N] </span>You can see the discussion on the Lift mailing list that led to this change here: <a class="FlexURL" href="http://tinyurl.com/dy9u9d">http://tinyurl.com/dy9u9d</a></span></span> because this allows the container to handle any requests that Lift does not (in particular, static content). The filter acts as a thin wrapper on top of the existing <tt>LiftServlet</tt> (which still does all of the work), so don’t be confused when you look at the Lift API and see both classes (<tt>LiftFilter</tt> and <tt>LiftServlet</tt>). The main thing to remember is that your <tt>web.xml</tt><a class="IndexReference" name="entry-web.xml-0" href="#index-web.xml">↓</a> should specify the filter and not the servlet, as shown in Listing <a class="Reference" href="#lst:LiftFilter-setup-in-web.xml">3.1↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:LiftFilter-setup-in-web.xml"> </a>LiftFilter Setup in web.xml
</div>
<pre class="listing brush: xml">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;!DOCTYPE web-app
  PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
  "http://java.sun.com/j2ee/dtds/web-app_2_3.dtd"&gt;
&lt;web-app&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;LiftFilter&lt;/filter-name&gt;
    &lt;display-name&gt;Lift Filter&lt;/display-name&gt;
    &lt;description&gt;The Filter that intercepts lift calls&lt;/description&gt;
    &lt;filter-class&gt;net.liftweb.http.LiftFilter&lt;/filter-class&gt;
  &lt;/filter&gt;      
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;LiftFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</pre>
</div>

</div>
<div class="Indented">
A full <tt>web.xml</tt> example is shown in Section <a class="Reference" href="#lst:JPA-web.xml">G.1.5 on page 1↓</a>. In particular, the filter-mapping (lines 13-16) specifies that the Filter is responsible for everything. When the filter receives the request, it checks a set of rules to see if it can handle it. If the request is one that Lift handles, it passes it on to an internal <tt>LiftServlet</tt> instance for processing; otherwise, it chains the request and allows the container to handle it.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.2">3.2</a> Bootstrap<a class="Label" name="sec:Bootstrap"> </a><a class="IndexReference" name="entry-Bootstrap-0" href="#index-Bootstrap">↓</a>
</h2>
<div class="Unindented">
When Lift starts up an application there are a number of things that you’ll want to set up before any requests are processed. These things include setting up a site Menu (called SiteMap, Chapter <a class="Reference" href="#cha:SiteMap">7↓</a>), URL rewriting (Section <a class="Reference" href="#sec:URL-Rewriting">3.7↓</a>), custom dispatch (Section <a class="Reference" href="#sec:Custom-dispatch-func">3.8↓</a>), and classpath search (Section <a class="Reference" href="#sub:Class-Resolution">3.2.1↓</a>). The Lift servlet looks for the <tt>bootstrap.liftweb.Boot</tt><a class="IndexReference" name="entry-Boot-1" href="#index-Boot">↓</a> class and executes the <tt>boot</tt> method in the class. You can also specify your own Boot instance by using the <tt>bootloader<a class="IndexReference" name="entry-bootloader-0" href="#index-bootloader">↓</a></tt> init param for the <tt>LiftFilter</tt> as shown in Listing <a class="Reference" href="#lst:Overriding-bootloader">3.2↓</a>
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Overriding the Boot Loader Class<a class="Label" name="lst:Overriding-bootloader"> </a>
</div>
<pre class="listing brush: xml">&lt;filter&gt;
  ... filter setup here ...
  &lt;init-param&gt;     
    &lt;param-name&gt;bootloader&lt;/param-name&gt;
    &lt;param-value&gt;foo.bar.baz.MyBoot&lt;/param-value&gt;
  &lt;/init-param&gt; 
&lt;/filter&gt;
</pre>
</div>

</div>
<div class="Indented">
Your custom boot class class must subclass <tt>Bootable</tt><span class="FootOuter"><span class="SupFootMarker"> [O] </span><span class="HoverFoot"><span class="SupFootMarker"> [O] </span><tt>net.liftweb.http.Bootable</tt></span></span> and implement the <tt>boot</tt> method. The <tt>boot</tt> method will only be run once, so you can place any initialization calls for other libraries here as well.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.2.1">3.2.1</a> Class Resolution<a class="Label" name="sub:Class-Resolution"> </a>
</h3>
<div class="Unindented">
As part of our discussion of the Boot class, it’s also important to explain how Lift determines where to find classes for Views and Snippet rendering when using implicit dispatch (we’ll cover this in Section <a class="Reference" href="#sub:Implicit-Dispatch-Via">5.2.1 on page 1↓</a>). The <tt>LiftRules.addToPackages</tt> method tells lift which Scala packages to look in for a given class. Lift has implicit extensions to the paths you enter: in particular, if you tell Lift to use the <tt>com.pocketchangeapp</tt> package, Lift will look for View classes (Section ???)under <tt>com.pocketchangeapp.view</tt> , Comet classes (Section <a class="Reference" href="#sec:COMET">11.5↓</a>) under <tt>com.pocketchange.comet</tt>, and Snippet classes (Chapter <a class="Reference" href="#cha:Snippets">5↓</a>) under <tt>com.pocketchangeapp.snippet</tt>. The <tt>addToPackages</tt> method should almost always be executed in your Boot class. A minimal Boot class would look like:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Minimal Boot Class<a class="Label" name="lst:Minimal-Boot-class"> </a>
</div>
<pre class="listing brush: scala">class Boot {
  def boot = {
    LiftRules.addToPackages("com.pocketchangeapp")
  }
}
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.3">3.3</a> A Note on Standard Imports
</h2>
<div class="Unindented">
For the sake of saving space, the following import statements are assumed for all example code throughout the rest of the book:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Standard Import Statements<a class="Label" name="lst:Standard-import-statements"> </a>
</div>
<pre class="listing brush: scala">import net.liftweb.common._
​
import net.liftweb.http._
import S._
​
import net.liftweb.util._
import Helpers._
​
import scala.xml._
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.4">3.4</a> Lift’s Main Objects
</h2>
<div class="Unindented">
Before we dive into Lift’s fundamentals, we want to briefly discuss three objects you will use heavily in your Lift code. We’ll be covering these in more detail later in this chapter and in further chapters, so feel free to skip ahead if you want more details.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.4.1">3.4.1</a> S<a class="IndexReference" name="entry-S-0" href="#index-S">↓</a> object<a class="Label" name="sub:S-object"> </a>
</h3>
<div class="Unindented">
The <tt>net.liftweb.http.S</tt> object represents the state of the current request (according to David Pollak, “S” is for Stateful). As such, it is used to retrieve information about the request and modify information that is sent in the response. Among other things, it can be used for notices (Section <a class="Reference" href="#cha:Message-Handling">B↓</a>) , cookie management (Section <a class="Reference" href="#sec:Cookies">3.10↓</a>), localization/internationalization (Chapter <a class="Reference" href="#cha:Internationalization">D↓</a>) and redirection (Section <a class="Reference" href="#sec:HTTP-redirects">3.9↓</a>).
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.4.2">3.4.2</a> SHtml<a class="IndexReference" name="entry-SHtml-0" href="#index-SHtml">↓</a><a class="Label" name="sub:SHtml"> </a>
</h3>
<div class="Unindented">
The <tt>net.liftweb.http.SHtml</tt> object’s main purpose is to define HTML generation functions, particularly those having to do with form elements. We cover forms in detail in Chapter <a class="Reference" href="#cha:Forms-in-Lift">6↓</a>). In addition to normal form elements, SHtml defines functions for AJAX and JSON form elements (Chapters <a class="Reference" href="#cha:AJAX-and-COMET">11↓</a> and <a class="Reference" href="#cha:Lift-and-Javascript">10↓</a>, respectively).
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.4.3">3.4.3</a> LiftRules<a class="IndexReference" name="entry-LiftRules-0" href="#index-LiftRules">↓</a>
</h3>
<div class="Unindented">
The <tt>net.liftweb.http.LiftRules</tt> object is where the vast majority of Lift’s global configuration is handled. Almost everything that is configurable about Lift is set up based on variables in <tt>LiftRules</tt>. Because LiftRules spans such a diverse range of functionality, we won’t be covering <tt>LiftRules</tt> directly, but as we discuss each Lift mechanism we’ll touch on the <tt>LiftRules</tt> variables and methods related to the configuration of that mechanism.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.5">3.5</a> The Rendering Process<a class="Label" name="sec:The-Rendering-Process"> </a>
</h2>
<div class="Unindented">
The rest of this chapter, as well as the next few chapters, are dedicated to the stages of rendering in Lift. We’ll start here by giving a brief overview of the processes by which Lift transforms a request into a response<a class="IndexReference" name="entry-rendering-pipeline-0" href="#index-rendering-pipeline">↓</a>. We’re only going to touch on the major points here, although the steps we do discuss will be in the order that Lift performs them. A much more detailed tour of the pipeline is given in Section <a class="Reference" href="#sec:Request/Response-Lifecycle">9.2↓</a>. Starting from the initial invocation on a request, Lift will:
</div>
<ol>
<li>
Perform any configured URL rewriting. This is covered in Section <a class="Reference" href="#sec:URL-Rewriting">3.7↓</a>.
</li>
<li>
Execute any matching custom dispatch functions. This is split into both stateless and stateful dispatch, and will be covered in more detail in Section <a class="Reference" href="#sec:Custom-dispatch-func">3.8↓</a>.
</li>
<li>
Perform automatic processing of Comet and AJAX requests (Chapter <a class="Reference" href="#cha:AJAX-and-COMET">11↓</a>).
</li>
<li>
Perform SiteMap setup and matching. SiteMap, covered in Chapter <a class="Reference" href="#cha:SiteMap">7↓</a>, not only provides a nice site-wide menu system, but can also perform security control, URL rewrite, and other custom functionality.
</li>
<li>
Locate the template XHTML to use for the request. This is handled via three mechanisms:<ol>
<li>
Checking the <tt>LiftRules.viewDispatch<a class="IndexReference" name="entry-viewDispatch-0" href="#index-viewDispatch">↓</a><a class="IndexReference" name="entry-Views-Explicit-dispatch-0" href="#index-Views-Explicit-dispatch">↓</a></tt> <tt>RulesSeq</tt> to see if any custom dispatch rules have been defined. We cover custom view dispatch in Section <a class="Reference" href="#sec:Request/Response-Lifecycle">9.2 on page 1↓</a>.
</li>
<li>
If there is no matching <tt>viewDispatch</tt>, locate a template<a class="IndexReference" name="entry-template-1" href="#index-template">↓</a> file that matches and use it. We’ll cover templates, and how they’re located, in Section <a class="Reference" href="#sec:Templates">4.1↓</a>.
</li>
<li>
If no templates files can be located, attempting to locate a view<a class="IndexReference" name="entry-Views-0" href="#index-Views">↓</a> based on implicit dispatch. We’ll cover views in Section <a class="Reference" href="#sec:Views">4.4↓</a>.
</li>

</ol>

</li>
<li>
Process the template, including embedding of other templates (Section <a class="Reference" href="#sub:embed-tag">4.5.7↓</a>), merging <tt>&lt;head/&gt;</tt> elements from composited templates (Section <a class="Reference" href="#sec:Head-Merge">↓</a>), and executing snippet functions (Chapter <a class="Reference" href="#cha:Snippets">5↓</a>).
</li>

</ol>
<div class="Unindented">
The rest of this chapter will be devoted in part to the early stages of the rendering pipeline, as well as some notes on some general functionality in Lift like redirects<a class="IndexReference" name="entry-redirect-0" href="#index-redirect">↓</a>.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.6">3.6</a> Notices, Warnings, and Error Messages<a class="Label" name="sub:Notices/Warnings/Errors-messages"> </a>
</h2>
<div class="Unindented">
Feedback to the user is important. The application must be able to notify the user of errors, warn the user of potential problems, and notify the user when system status changes. Lift provides a unified model for such messages that can be used for static pages as well as for AJAX and Comet calls. We cover messaging support in Appendix <a class="Reference" href="#cha:Message-Handling">B↓</a>.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.7">3.7</a> URL Rewriting <a class="Label" name="sec:URL-Rewriting"> </a>
</h2>
<div class="Unindented">
Now that we’ve gone over Templates, Views, Snippets, and how requests are dispatched to a Class.method, we can discuss how to intercept requests and handle them the way we want to. URL rewriting<a class="IndexReference" name="entry-rewriting-0" href="#index-rewriting">↓</a><a class="IndexReference" name="entry-URL-rewriting-0" href="#index-URL-rewriting">↓</a> is the mechanism that allows you to modify the incoming request so that it dispatches to a different URL. It can be used, among other things, to allow you to:
</div>
<ul>
<li>
Use user-friendly, bookmarkable URLs like <tt>http://www.example.com/budget/2008</tt>
</li>
<li>
Use short URLs instead of long, hard to remember ones, similar to <a class="URL" href="http://tinyurl.com">http://tinyurl.com</a>
</li>
<li>
Use portions of the URL to determine how a particular snippet or view responds. For example, you could make it so that a user’s profile is displayed via a URL such as<br/>
<tt>http://someplace.com/user/derek</tt> instead of having the username sent as part of a query string.
</li>

</ul>
<div class="Unindented">
The mechanism is fairly simple to set up. We need to write a partial function from a RewriteRequest to a RewriteResponse to determine if and how we want to rewrite particular requests. Once we have the partial function, we modify the <tt>LiftRules.rewrite</tt> configuration to hook into Lift’s processing chain. The simplest way to write a partial function is with Scala’s match statement, which will allow us to selectively match on some or all of the request information. (Recall that for a partial function, the matches do not have to be exhaustive. In the instance that no RewriteRequest matches, no RewriteResponse will be generated.) It is also important to understand that when the rewrite functions run, the Lift session has not yet been created. This means that you generally can’t set or access properties in the S object. RewriteRequest is a <tt>case</tt> object that contains three items: the parsed path, the request type and the original HttpServletRequest<a class="IndexReference" name="entry-HttpServletRequest-0" href="#index-HttpServletRequest">↓</a> object. (If you are not familiar with case classes, you may wish to review the Scala documentation for them. Adding the <tt>case</tt> modifier to a class results in some nice syntactic conveniences.)
</div>
<div class="Indented">
The parsed path of the request is in a ParsePath<a class="IndexReference" name="entry-ParsePath-0" href="#index-ParsePath">↓</a> <tt>case</tt> class instance. The ParsePath class contains
</div>
<ol>
<li>
The parsed path as a List[String]
</li>
<li>
The suffix of the request (i.e. “html”, “xml”, etc)
</li>
<li>
Whether this path is root-relative path. If true, then it will start with /&lt;context-path&gt;, followed by the rest of the path. For example, if your application is deployed on the app context path (“/app”) and we want to reference the file &lt;webapp-folder&gt;/pages/index.html, then the root-relative path will be /app/pages/index.html. 
</li>
<li>
Whether the path ends in a slash (“/”)
</li>

</ol>
<div class="Unindented">
The latter three properties are useful only in specific circumstances, but the parsed path is what lets us work magic. The path of the request is defined as the parts of the URI between the context path and the query string. The following table shows examples of parsed paths for a Lift application under the “myapp” context path:
</div>
<div class="Indented">
<div class="center">
<table>
<tr>
<td align="left" valign="top">
<b><span class="footnotesize">Requested URL</span></b>
</td>
<td align="left" valign="top">
<b><span class="footnotesize">Parsed Path</span></b>
</td>

</tr>
<tr>
<td align="left" valign="top">
<span class="footnotesize">http://foo.com/myapp/home?test_this=true</span>
</td>
<td align="left" valign="top">
<span class="footnotesize">List[String](“home”)</span>
</td>

</tr>
<tr>
<td align="left" valign="top">
<span class="footnotesize">http://foo.com/myapp/user/derek</span>
</td>
<td align="left" valign="top">
<span class="footnotesize">List[String](“user”, “derek”)</span>
</td>

</tr>
<tr>
<td align="left" valign="top">
<span class="footnotesize">http://foo.com/myapp/view/item/14592</span>
</td>
<td align="left" valign="top">
<span class="footnotesize">List[String](“view”,”item”,”14592”)</span>
</td>

</tr>

</table>

</div>

</div>
<div class="Indented">
The RequestType maps to one of the five HTTP methods: GET, POST, HEAD, PUT and DELETE. These are represented by the corresponding GetRequest, PostRequest, etc. case classes, with an UnknownRequest case class to cover anything strange.
</div>
<div class="Indented">
The flexibility of Scala’s matching system is what really makes this powerful. In particular, when matching on Lists, we can match parts of the path and capture others. For example, suppose we’d like to rewrite the <tt>/account/&lt;account name&gt;</tt> path so that it’s handled by the <tt>/viewAcct</tt> template as shown in Listing <a class="Reference" href="#lst:Simple-rewrite-example">3.7↓</a>. In this case we provide two rewrites. The first matches /account/&lt;account name&gt; and redirects it to the /viewAcct template, passing the acctName as a “name” parameter. The second matches /account/&lt;account name&gt;/&lt;tag&gt;, redirecting it to /viewAcct as before, but passing both the “name” and a “tag” parameter with the acctName and tag matches from the ParsePath, respectively. Remember that the underscore (_) in these matching statements means that we don’t care what that parameter is, i.e., match anything in that spot.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Simple Rewrite Example<a class="Label" name="lst:Simple-rewrite-example"> </a>
</div>
<pre class="listing brush: scala">LiftRules.rewrite.append {
  case RewriteRequest(
         ParsePath(List("account",acctName),_,_,_),_,_) =&gt; 
         RewriteResponse("viewAcct" :: Nil, Map("name" -&gt; acctName))
  case RewriteRequest(
         ParsePath(List("account",acctName, tag),_,_,_),_,_) =&gt; 
         RewriteResponse("viewAcct" :: Nil, Map("name" -&gt; acctName,
                                                "tag" -&gt; tag)))
}
</pre>
</div>

</div>
<div class="Indented">
The RewriteResponse<a class="IndexReference" name="entry-RewriteResponse-0" href="#index-RewriteResponse">↓</a> simply contains the new path to follow. It can also take a Map<a class="IndexReference" name="entry-Map-0" href="#index-Map">↓</a> that contains parameters that will be accessible via S.param<a class="IndexReference" name="entry-S.param-0" href="#index-S.param">↓</a><a class="IndexReference" name="entry-S-1" href="#index-S">↓</a> in the snippet or view. As we stated before, the LiftSession (and therefore most of S) isn’t available at this time, so the Map is the only way to pass information on to the rewritten location. 
</div>
<div class="Indented">
We can combine the ParsePath matching with the RequestType and HttpServletRequest to be very specific with our matches. For example, if we wanted to support the DELETE HTTP verb for a RESTful<span class="FootOuter"><span class="SupFootMarker"> [P] </span><span class="HoverFoot"><span class="SupFootMarker"> [P] </span></span></span><a class="IndexReference" name="entry-RESTful-0" href="#index-RESTful">↓</a> interface through an existing template, we could redirect as shown in Listing <a class="Reference" href="#lst:Complex-rewrite-example">3.7↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Complex Rewrite Example<a class="Label" name="lst:Complex-rewrite-example"> </a>
</div>
<pre class="listing brush: scala">LiftRules.rewrite.append {
  case RewriteRequest(ParsePath("username" :: Nil, _, _, _),
                      DeleteRequest,
                      httpreq) 
                      if isMgmtSubnet(httpreq.getRemoteHost()) =&gt; 
       RewriteResponse("deleteUser" :: Nil, Map("username" -&gt; username))
}
</pre>
</div>

</div>
<div class="Indented">
We’ll go into more detail about how you can use this in the following sections. In particular, SiteMap<a class="IndexReference" name="entry-SiteMap-1" href="#index-SiteMap">↓</a> (Chapter <a class="Reference" href="#cha:SiteMap">7↓</a>) provides a mechanism for doing rewrites combined with menu entries.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.8">3.8</a> Custom Dispatch Functions <a class="Label" name="sec:Custom-dispatch-func"> </a>
</h2>
<div class="Unindented">
Once the rewriting phase is complete (whether we pass through or are redirected), the next phase is to determine whether there should be a custom dispatch for the request. A custom dispatch allows you to handle a matching request directly by a method instead of going through the template lookup system. Because it bypasses templating, you’re responsible for the full content of the response. A typical use case would be a web service<a class="IndexReference" name="entry-web-service-0" href="#index-web-service">↓</a> returning XML or a service to return, say, a generated image or PDF. In that sense, the custom dispatch mechanism allows you to write your own “sub-servlets” without all the mess of implementing the interface and configuring them in web.xml<a class="IndexReference" name="entry-web.xml-1" href="#index-web.xml">↓</a>.
</div>
<div class="Indented">
As with rewriting, custom dispatch is realized via a partial function. In this case, it’s a function of type <tt>PartialFunction[Req,<span class="formula">() ⇒ <i>Box</i>[<i>LiftResponse</i>]</span>]</tt> that does the work. The <tt>Req</tt> is similar to the <tt>RewriteRequest</tt> case class: it provides the path as a <tt>List[String]</tt>, the suffix of the request, and the <tt>RequestType</tt>. There are three ways that you can set up a custom dispatch function:
</div>
<ol>
<li>
Globally, via <tt>LiftRules.dispatch</tt><a class="IndexReference" name="entry-LiftRules-dispatch-0" href="#index-LiftRules-dispatch">↓</a><a class="IndexReference" name="entry-Custom-dispatch-stateful-0" href="#index-Custom-dispatch-stateful">↓</a>
</li>
<li>
Globally, via <tt>LiftRules.statelessDispatchTable</tt><a class="IndexReference" name="entry-LiftRules-statelessDispatchTable-0" href="#index-LiftRules-statelessDispatchTable">↓</a><a class="IndexReference" name="entry-Custom-dispatch-stateless-0" href="#index-Custom-dispatch-stateless">↓</a>
</li>
<li>
Per-Session, via <tt>S.addHighLevelSessionDispatcher</tt><a class="IndexReference" name="entry-S-addHighLevelSessionDispatcher-0" href="#index-S-addHighLevelSessionDispatcher">↓</a><a class="IndexReference" name="entry-Custom-dispatch-per-session-0" href="#index-Custom-dispatch-per-session">↓</a>
</li>

</ol>
<div class="Unindented">
If you attach the dispatch function via <tt>LiftRules.dispatch</tt> or <tt>S.addHighLevelSessionDispatcher</tt>, then you’ll have full access to the <tt>S</tt> object, <tt>SessionVar</tt>s and <tt>LiftSession</tt>; if you use <tt>LiftRules.statelessDispatchTable</tt> instead, then these aren’t available. The result of the dispatch should be a function that returns a <tt>Box[LiftResponse]</tt>. If the function returns <tt>Empty</tt>, then Lift returns a “404 Not Found” response.
</div>
<div class="Indented">
As a concrete example, let’s look at returning a generated chart image from our application. There are several libraries for charting, but we’ll take a look at JFreeChart in particular. First, let’s write a method that will chart our account balances by month for the last year:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Charting Method<a class="Label" name="lst:Charting-method"> </a>
</div>
<pre class="listing brush: scala">def chart (endDate : String) : Box[LiftResponse] = {
  // Query, set up chart, etc...
  val buffered = balanceChart.createBufferedImage(width,height)
  val chartImage = ChartUtilities.encodeAsPNG(buffered)
  // InMemoryResponse is a subclass of LiftResponse
  // it takes an Array of Bytes, a List[(String,String)] of
  // headers, a List[Cookie] of Cookies, and an integer
  // return code (here 200 for HTTP 200: OK)
  Full(InMemoryResponse(chartImage, 
                        ("Content-Type" -&gt; "image/png") :: Nil,
                        Nil,
                        200))
}
</pre>
</div>

</div>
<div class="Indented">
Once we’ve set up the chart, we use the ChartUtilities helper class from JFreeChart to encode the chart into a PNG byte array. We can then use Lift’s InMemoryResponse<a class="IndexReference" name="entry-InMemoryResponse-0" href="#index-InMemoryResponse">↓</a> to pass the encoded data back to the client with the appropriate Content-Type<a class="IndexReference" name="entry-Type-0" href="#index-Type">↓</a> header. Now we just need to hook the request into the dispatch table from the Boot class as shown in Listing <a class="Reference" href="#lst:Hooking-dispatch-into-Boot">3.8↓</a>. In this instance, we want state so that we can get the current user’s chart. For this reason, we use <tt>LiftRules.dispatch</tt> as opposed to <tt>LiftRules.statelessDispatch</tt>. Because we’re using a partial function to perform a Scala match operation, the case that we define here uses the <tt>Req</tt> object’s <tt>unapply</tt> method, which is why we only need to provide the <tt>List[String]</tt> argument. <div class="listing">
<div class="caption">
Hooking Dispatch into Boot<a class="Label" name="lst:Hooking-dispatch-into-Boot"> </a>
</div>
<pre class="listing brush: scala">LiftRules.dispatch.append {
  case Req("chart" :: "balances" :: endDate :: Nil, _, _) =&gt;
    Charting.chart(endDate) _
}
</pre>
</div>

</div>
<div class="Indented">
As you can see, we capture the endDate parameter from the path and pass it into our chart method. This means that we can use a URL like <tt>http://foo.com/chart/balances/20080401</tt> to obtain the image. Since the dispatch function has an associated Lift session, we can also use the S.param method to get query string parameters, if, for example, we wanted to allow someone to send an optional width and height:
</div>
<pre class="LyX-Code">
val width = S.param(“width”).map(_.toInt) openOr 400
val height = S.param(“height”).map(_.toInt) openOr 300
</pre>
<div class="Unindented">
Or you can use a slightly different approach by using the <tt>Box.dmap</tt> method:
</div>
<pre class="LyX-Code">
val width = S.param(“width”).dmap(400)(_.toInt)
val height = S.param(“height”).dmap(300)(_.toInt)
</pre>
<div class="Unindented">
Where dmap is identical with map function except that the first argument is the default value to use if the <tt>Box</tt> is <tt>Empty</tt>. There are a number of other ListResponse subclasses to cover your needs, including responses for XHTML, XML, Atom, Javascript, CSS, and JSON. We cover these in more detail in Section <a class="Reference" href="#sec:LiftResponse-in-Detail">9.4↓</a>.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.9">3.9</a> HTTP Redirects <a class="Label" name="sec:HTTP-redirects"> </a>
</h2>
<div class="Unindented">
HTTP redirects are an important part of many web applications. In Lift there are two main ways of sending a redirect to the client:
</div>
<ol>
<li>
Call S.redirectTo. When you do this, Lift throws an exception and catches it later on. This means that any code following the redirect is skipped. If you’re using a StatefulSnippet (Section <a class="Reference" href="#sub:Stateless-versus-Stateful">5.3.3↓</a>), use <tt>this.redirectTo</tt> so that your snippet instance is used when the redirect is processed.<div class="Unindented">
<div class="Shadowbox" style="width: 80%;">
<b>Important:</b> if you use S.redirectTo within a try/catch block, you’ll need to make sure that you aren’t catching the redirect exception (Scala uses unchecked exceptions), or test for the redirect’s exception and rethrow it. Ifyou mistakenly catch the redirect exception, then no redirect will occur. 
</div>

</div>

</li>
<li>
When you need to return a LiftResponse, you can simply return a RedirectResponse or a RedirectWithState response.
</li>

</ol>
<div class="Unindented">
The RedirectWithState response allows you to specify a function to be executed when the redirected request is processed. You can also send Lift messages (notices, warnings, and errors) that will be rendered in the redirected page, as well as cookies to be set on redirect. Similarly, there is an overloaded version of S.redirectTo that allows you to specify a function to be executed when the redirect is processed.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.10">3.10</a> Cookies<a class="Label" name="sec:Cookies"> </a>
</h2>
<div class="Unindented">
Cookies<span class="FootOuter"><span class="SupFootMarker"> [Q] </span><span class="HoverFoot"><span class="SupFootMarker"> [Q] </span><a class="URL" href="http://java.sun.com/products/servlet/2.2/javadoc/javax/servlet/http/Cookie.html">http://java.sun.com/products/servlet/2.2/javadoc/javax/servlet/http/Cookie.html</a></span></span> are a useful tool when you want data persisted across user sessions. Cookies are essentially a token of string data that is stored on the user’s machine. While they can be quite useful, there are a few things that you should be aware of:
</div>
<ol>
<li>
The user’s browser may have cookies disabled, in which case you need to be prepared to work without cookies or tell the user that they need to enable them for your site
</li>
<li>
Cookies are relatively insecure<span class="FootOuter"><span class="SupFootMarker"> [R] </span><span class="HoverFoot"><span class="SupFootMarker"> [R] </span>See <a class="URL" href="http://www.w3.org/Security/Faq/wwwsf2.html">http://www.w3.org/Security/Faq/wwwsf2.html</a> (Q10) and <a class="URL" href="http://www.cookiecentral.com/faq/">http://www.cookiecentral.com/faq/</a> for details on cookies and their security issues.</span></span>. There have been a number of browser bugs related to data in cookies being read by viruses or other sites
</li>
<li>
Cookies are easy to fake, so you need to ensure that you validate any sensitive cookie data
</li>

</ol>
<div class="Unindented">
Using Cookies in Lift is very easy. In a stateful context, everything you need is provided by a few methods on the S object:
</div>
<div class="Description">
<span class="Description-entry">addCookie</span> Adds a cookie to be sent in the response
</div>
<div class="Description">
<span class="Description-entry">deleteCookie</span> Deletes a cookie (technically, this adds a cookie with a maximum age of zero so that the browser removes it). You can either delete a cookie by name, or with a Cookie object
</div>
<div class="Description">
<span class="Description-entry">findCookie</span> Looks for a cookie with a given name and returns a Box[Cookie]. Empty means that the cookie doesn’t exist
</div>
<div class="Description">
<span class="Description-entry">receivedCookies</span> Returns a List[Cookie] of all of the cookies sent in the request
</div>
<div class="Description">
<span class="Description-entry">responseCookies</span> Returns a List[Cookie] of the cookies that will be sent in the response
</div>
<div class="Unindented">
If you need to work with cookies in a stateless context, many of the ListResponse classes (Section <a class="Reference" href="#sec:LiftResponse-in-Detail">9.4↓</a>) include a List[Cookie] in their constructor or <tt>apply</tt> arguments. Simply provide a list of the cookies you want to set, and they’ll be sent in the response. If you want to delete a cookie in a LiftResponse, you have to do it manually by adding a cookie with the same name and a <tt>maxage</tt> of zero. 
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.11">3.11</a> Session and Request State<a class="Label" name="sec:Session-and-Request"> </a>
</h2>
<div class="Unindented">
Lift provides a very easy way to store per-session and per-request data through the SessionVar and RequestVar classes. In true Lift fashion, these classes provide:
</div>
<ul>
<li>
Type-safe access to the data they hold
</li>
<li>
A mechanism for providing a default value if the session or request doesn’t exist yet
</li>
<li>
A mechanism for cleaning up the data when the variable’s lifecycle ends
</li>

</ul>
<div class="Unindented">
Additionally, Lift provides easy access to HTTP request parameters<a class="IndexReference" name="entry-request-parameters-0" href="#index-request-parameters">↓</a> via the S.param method, which returns a Box[String]. Note that HTTP request parameters (sent via GET or POST) differ from RequestVars in that query parameters are string values sent as part of the request; RequestVars, in contrast, use an internal per-request Map so that they can hold any type, and are initialized entirely in code. At this point you might ask what RequestVars can be used for. A typical example would be sharing state between different snippets, since there is no connection between snippets other than at the template level.
</div>
<div class="Indented">
SessionVars and RequestVars are intended to be implemented as singleton objects so that they’re accessible from anywhere in your code. Listing <a class="Reference" href="#lst:Defining-a-RequestVar">3.11↓</a> shows an example definition of a RequestVar used to hold the number of entries to show per page. We start by defining the object as extending the RequestVar. You must provide the type of the RequestVar so that Lift knows what to accept and return. In this instance, the type is an Int. The constructor argument is a by-name parameter which must evaluate to the var’s type. In our case, we attempt to use the HTTP request variable “pageSize,” and if that isn’t present or isn’t an integer, then we default to 25.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Defining a RequestVar<a class="Label" name="lst:Defining-a-RequestVar"> </a>
</div>
<pre class="listing brush: scala">class AccountOps {
  object pageSize extends RequestVar[Int](S.param("pageSize").map(_.toInt) openOr 25)
  ...
}
</pre>
</div>

</div>
<div class="Indented">
Accessing the value of the <tt>RequestVar</tt> is done via the <tt>is</tt> method. You can also set the value using the <tt>apply</tt> method, which in Scala is syntactically like using the <tt>RequestVar</tt> as a function. Common uses of apply in Scala include array element access by index and companion object methods that can approximate custom constructors. For example, the <tt>Loc</tt> object (which we’ll cover in Chapter <a class="Reference" href="#cha:SiteMap">7↓</a>), has an overloaded <tt>apply</tt> method that creates a new <tt>Loc</tt> class instance based on input parameters.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Accessing the RequestVar<a class="Label" name="lst:Accessing-the-RequestVar"> </a>
</div>
<pre class="listing brush: scala">// get the value contained in the AccountOps.pageSize RequestVar
query.setMaxResults(AccountOps.pageSize.is)
​
// Change the value of the RequestVar. The following two lines
// of code are equivalent:
AccountOps.pageSize(50)
AccountOps.pageSize.apply(50)
</pre>
</div>

</div>
<div class="Indented">
In addition to taking a parameter that defines a default value for setup, you can also clean up the value when the variable ends it lifecycle. Listing <a class="Reference" href="#lst:Defining-a-Cleanup">3.11↓</a> shows an example of opening a socket and closing it at the end of the request. This is all handled by passing a function to the <tt>registerCleanupFunc</tt> method. The type of the function that you need to pass is <span class="formula"><i>CleanUpParam</i> ⇒ <i>Unit</i></span>, where <tt>CleanUpParam</tt> is defined based on whether you’re using a <tt>RequestVar</tt> or a <tt>SessionVar</tt>. With <tt>RequestVar</tt>, <tt>CleanUpParam</tt> is of type <tt>Box[LiftSession]</tt>, reflecting that the session may not be in scope when the cleanup function executes. For a <tt>SessionVar</tt> the <tt>CleanUpParam</tt> is of type <tt>LiftSession</tt>, since the session is always in scope for a <tt>SessionVar</tt> (it holds a reference to the session). In our example in Listing <a class="Reference" href="#lst:Defining-a-Cleanup">3.11↓</a> we simply ignore the input parameter to the cleanup function, since closing the socket is independent of any session state. Another important thing to remember is that you’re responsible for handling any exceptions that might be thrown during either default initialization or cleanup. 
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Defining a Cleanup Function<a class="Label" name="lst:Defining-a-Cleanup"> </a>
</div>
<pre class="listing brush: scala">object mySocket extends RequestVar[Socket](new Socket("localhost:23")) {
  registerCleanupFunc(ignore =&gt; this.is.close)
}
</pre>
</div>

</div>
<div class="Indented">
The information we’ve covered here is equally applicable to SessionVars; the only difference between them is the scope of their respective lifecycles.
</div>
<div class="Indented">
Another common use of <tt>RequestVar</tt> is to pass state around between different page views (requests). We start by defining a <tt>RequestVar</tt> on an object so that it’s accesible from all of the snippet methods that will read and write to it. It’s also possible to define it on a class if all of the snippets that will access it are in that class. Then, in the parts of your code that will transition to a new page you use the overloaded versions of <tt>SHtml.link</tt> or<tt> S.redirectTo</tt> that take a function as a second argument to “inject” the value you want to pass via the <tt>RequestVar</tt>. This is similar to using a query parameter on the URL to pass data, but there are two important advantages:
</div>
<ol>
<li>
You can pass any type of data via a <tt>RequestVar</tt>, as opposed to just string data in a query parameter.
</li>
<li>
You’re really only passing a reference to the injector function, as opposed to the data itself. This can be important if you don’t want the user to be able to tamper with the passed data. One example would be passing the cost of an item from a “view item” page to an “add to cart” page.
</li>

</ol>
<div class="Unindented">
Listing <a class="Reference" href="#lst:Passing-an-Account">3.11↓</a> shows how we pass an Account from a listing table to a specific Account edit page using <tt>SHtml.link</tt>, as well as how we could transition from an edit page to a view page using <tt>S.redirectTo</tt>. Another example of passing is shown in Listing <a class="Reference" href="#lst:Passing-Detached-Instances">12.1.3 on page 1↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Passing an Account to View<a class="Label" name="lst:Passing-an-Account"> </a>
</div>
<pre class="listing brush: scala">class AccountOps {
  ...
  object currentAccountVar extends RequestVar[Account](null)
  ...
  def manage (xhtml : NodeSeq) ... {
    ...
    User.currentUser.map({user =&gt; 
      user.accounts.flatMap({acct =&gt;
        bind("acct", chooseTemplate("account", "entry", xhtml),
          ...
          // The second argument injects the "acct" val back
          // into the RequestVar
          link("/editAcct", () =&gt; currentAccountVar(acct), Text("Edit"))
      })
    })
    ...
  }
  def edit (xhtml : NodeSeq) : NodeSeq = {
    def doSave () {
      ...
      val acct = currentAccountVar.is
      S.redirectTo("/view", () =&gt; currentAccountVar(acct))
    }
    ...
  }
}
</pre>
</div>

</div>
<div class="Indented">
One important thing to note is that the injector variable is called in the scope of the <i>following</i> request. This means that if you want the value returned by the function at the point where you call the link or redirectTo, you’ll need to capture it in a val. Otherwise, the function will be called <i>after</i> the redirect or link, which may result in a different value than you expect. As you can see in Listing <a class="Reference" href="#lst:Passing-an-Account">3.11↑</a>, we set up an acct val in our doSave method prior to redirecting. If we tried to do something like
</div>
<pre class="LyX-Code">
S.redirectTo("/view", () =&gt; currentAccountVar(currentAccountVar.is))
</pre>
<div class="Unindented">
instead, we would get the default value of our RequestVar (null in this case).
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.12">3.12</a> Conclusion
</h2>
<div class="Unindented">
We’ve covered a lot of material and we still have a lot more to go. Hopefully this chapter provides a firm basis to start from when exploring the rest of the book.
</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-4">4</a> Templates in Lift
</h1>
<div class="Unindented">
An XHTML page, being the central component of a web application, is likewise the central component of Lift’s request processing. In Lift, we go a step further and utilize a flexible yet powerful templating engine that allows us to compose an XHTML<a class="IndexReference" name="entry-XHTML-0" href="#index-XHTML">↓</a> page not only out of one or more XML<a class="IndexReference" name="entry-XML-0" href="#index-XML">↓</a> files, but also from methods that can programmaticaly generate template XML. Additionally, Lift 2.2<a class="IndexReference" name="entry-Lift-2.2-0" href="#index-Lift-2.2">↓</a> brings designer-friendly templates (Section <a class="Reference" href="#sec:Designer-Friendly-Templates">4.2↓</a>) and HTML5 support (Section <a class="Reference" href="#sec:HTML5-Support">4.3↓</a>). Designer-friendly templates, in particular, can simplify working with a designer because they allow templates to be fully valid XHTML or HTML5.
</div>
<div class="Indented">
In this chapter we’ll discuss template capabilities and syntax, including built-in tags provided by Lift that perform special template processing (Section <a class="Reference" href="#sec:ArchTags">4.5↓</a>). We will also cover how you can write your own View classes, Scala code that can programmatically generate template XML (Section <a class="Reference" href="#sec:Views">4.4↓</a>). We’ll finish up the chapter with some discussion on miscellaneous templating functionality.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.1">4.1</a> Template XML<a class="Label" name="sec:Templates"> </a>
</h2>
<div class="Unindented">
Templates<a class="IndexReference" name="entry-Templates-0" href="#index-Templates">↓</a> form the backbone of Lift’s flexibility and power. A template is an XML document that contains Lift-specific tags, see <a class="Reference" href="#sec:ArchTags">4.5↓</a>, as well as whatever content you want returned to the user. 
</div>
<div class="Indented">
<div class="center">
<div class="Shadowbox" style="width: 75%;">
A note on nomenclature: typically when people discuss “templates” in books or on the mailing list they’re talking about XML files. We’ll cover programmatic generation of template XML in Section <a class="Reference" href="#sec:Views">4.4↓</a>.
</div>

</div>

</div>
<div class="Indented">
Lift includes several built-in XML tags for specific actions. These utilize prefixed XML elements and are of the form <tt>&lt;lift:tag_name/&gt;</tt>. Lift also allows you to define your own tags, which are called <i>snippets</i><a class="IndexReference" name="entry-snippets-0" href="#index-snippets">↓</a> (Chapter <a class="Reference" href="#cha:Snippets">5↓</a>). These user-defined tags are linked to Scala methods and these methods can process the XML contents of the snippet tag, or can generate their own content from scratch. A simple template is shown in Listing <a class="Reference" href="#lst:Sample-template">4.1↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Sample Template<a class="Label" name="lst:Sample-template"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:surround with="default" at="content"&gt;
  &lt;head&gt;&lt;title&gt;Hello!&lt;/title&gt;&lt;/head&gt;
  &lt;lift:Hello.world /&gt;
&lt;/lift:surround&gt;
</pre>
</div>

</div>
<div class="Indented">
Notice the tags that are of the form <tt>&lt;lift:name&gt;</tt> which in this case are <tt>&lt;lift:surround&gt;</tt> and <tt>&lt;lift:snippet&gt;. </tt>These are two examples of Lift-specific tags. We’ll discuss all of the tags that users will use in Section <a class="Reference" href="#sec:ArchTags">4.5↓</a>, but let’s briefly discuss the two shown here. We use the built-in <tt>&lt;lift:surround&gt;<a class="IndexReference" name="entry-lift:surround-0" href="#index-lift:surround">↓</a></tt> tag (Section <a class="Reference" href="#sub:surround-tag">4.5.17↓</a>) to make Lift embed our current template inside the “default” template. We also use <tt>&lt;lift:snippet&gt;</tt> tag (aliased to Hello.world) to execute a snippet that we defined. In this instance, we execute the method <tt>world</tt> in the class <tt>Hello </tt>to generate some content.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.1.1">4.1.1</a> Locating Template XML
</h3>
<div class="Unindented">
During request processing, Lift first tries to match against the <tt>LiftRules.viewDispatch<a class="IndexReference" name="entry-viewDispatch-1" href="#index-viewDispatch">↓</a><a class="IndexReference" name="entry-Views-Explicit-dispatch-1" href="#index-Views-Explicit-dispatch">↓</a></tt> function to see if an explicit View method is defined for the request. If there isn’t a <tt>viewDispatch</tt> match, then Lift next tries to locate a file in the template directory tree (typically in a WAR archive) that matches the request. Lift tries several suffixes (html, xhtml, htm, and no suffix) and also tries to match based on the client’s <tt>Accept-Language</tt> header. The pattern Lift uses is:
</div>
<pre class="LyX-Code">
&lt;path to template&gt;[_&lt;language tag&gt;][.&lt;suffix&gt;]
</pre>
<div class="Unindented">
Because Lift will implicitly search for suffixes, it’s best to leave the suffix off of your links within the web app. If you have a link with an href of <tt>/test/template.xhtml</tt>, it will only match that file, but if you use <tt>/test/template</tt> for the href and you have the following templates in your web app:
</div>
<ul>
<li>
<tt>/test/template.xhtml</tt>
</li>
<li>
<tt>/test/template_es_ES.xhtml (Spanish localized for Spain)</tt>
</li>
<li>
<tt>/test/template_ja.xhtml</tt>
</li>

</ul>
<div class="Unindented">
then Lift will use the appropriate template based on the user’s requested language if a corresponding template is available. For more information regarding internationalization please see Appendix <a class="Reference" href="#cha:Internationalization">D↓</a>. In addition to normal templates, your application can make use of hidden templates<a class="IndexReference" name="entry-hidden-templates-0" href="#index-hidden-templates">↓</a>. These are templates that are located under the <tt>/templates-hidden</tt> directory of your web app. Technically, Lift hides files in any directory ending in “-hidden”, but templates-hidden is somewhat of a de facto standard. Like the <tt>WEB-INF</tt> directory, the contents cannot be directly requested by clients. They can, however, be used by other templates through mechanisms such as the <tt>&lt;lift:surround&gt;</tt> and <tt>&lt;lift:embed&gt;</tt> tags (Section <a class="Reference" href="#sub:embed-tag">4.5.7↓</a>). If a static file can’t be located then Lift will attempt to locate a View class (Section <a class="Reference" href="#sec:Views">4.4↓</a>) that will process the request. If Lift cannot locate an appropriate template based on the request path then it will return a 404 to the user.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.1.2">4.1.2</a> Processing Template XML
</h3>
<div class="Unindented">
Once Lift has located the correct template, the next step is to process the contents. It is important to understand that Lift processes XML tags recursively, from the outermost tag to the innermost tag. That means that in our example Listing <a class="Reference" href="#lst:Sample-template">4.1↑</a>, the surround tag gets processed first. In this case the surround loads the default template and embeds our content at the appropriate location. The next tag to be processed is the <tt>&lt;lift:Hello.world/&gt;</tt> snippet. This tag is essentially an alias for the lift:snippet tag (specifically, <tt>&lt;lift:snippet type=“Hello:world”&gt;</tt>) , and will locate the Hello class and execute the world method on it. If you omit the “method” part of the type and only specify the class (<tt>&lt;lift:Hello&gt;</tt> or <tt>&lt;lift:snippet type=“Hello”&gt;</tt>), then Lift will attempt to call the <tt>render</tt> method of the class.
</div>
<div class="Indented">
To give a more complex example that illustrates the order of tag processing, consider Listing <a class="Reference" href="#lst:A-Recursive-Tag">4.1.2↓</a>. In this example we have several nested snippet tags, starting with <tt>&lt;A.snippet /&gt;</tt>. Listing <a class="Reference" href="#lst:Recursive-Tag-Snippets">4.1.2↓</a> shows the backing code for this example. Snippets are covered in more detail in Chapter <a class="Reference" href="#cha:Snippets">5↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Recursive Tag Processing Example<a class="Label" name="lst:A-Recursive-Tag"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:A.snippet&gt;
  &lt;p&gt;Hello, &lt;A:name /&gt;!&lt;/p&gt;
  &lt;p&gt;
    &lt;lift:B.snippet&gt;
      &lt;B:title /&gt;
      &lt;lift:C.snippet /&gt;
    &lt;/lift:B.snippet&gt;
  &lt;/p&gt;
&lt;/lift:A.snippet&gt;
</pre>
</div>

</div>
<div class="Indented">
The first thing that happens is that the contents of the <tt>&lt;lift:A.snippet&gt;</tt> tag are passed as a <tt>NodeSeq</tt> argument to the <tt>A.snippet</tt> method. In the <tt>A.snippet</tt> method we bind<a class="IndexReference" name="entry-bind-0" href="#index-bind">↓</a>, or replace, the <tt>&lt;A:name /&gt;</tt> tag with an XML Text node of “The A snippet”. The rest of the input is left as-is and is returned to Lift for more processing. Lift examines the returned <tt>NodeSeq</tt> for more lift tags and finds the <tt>&lt;lift:B.snippet&gt;</tt> tag. The contents of the <tt>&lt;lift:B.snippet&gt;</tt> tag are passed as a <tt>NodeSeq</tt> argument to the <tt>B.snippet</tt> method, where the <tt>&lt;B.title /&gt;</tt> tag is bound with the XML Text node “The B snippet”. The rest of the contents are left unchanged and the transformed <tt>NodeSeq</tt> is returned to Lift, which scans for and finds the <tt>&lt;lift:C.snippet /&gt;</tt> tag. Since there are no child elements for the <tt>&lt;lift:C.snippet /&gt;</tt> tag, the <tt>C.snippet</tt> method is invoked with an empty <tt>NodeSeq</tt> and the <tt>C.snippet</tt> returns the Text node “The C snippet”.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
The Recursive Tag Snippets Code<a class="Label" name="lst:Recursive-Tag-Snippets"> </a>
</div>
<pre class="listing brush: scala">... standard Lift imports ...
class A {
  def snippet (xhtml : NodeSeq) : NodeSeq = 
    bind("A", xhtml, "name" -&gt; Text("The A snippet"))
}
class B {
  def snippet (xhtml : NodeSeq) : NodeSeq =
    bind("B", xhtml, "title" -&gt; Text("The B snippet"))
}
class C {
  def snippet (xhtml : NodeSeq) : NodeSeq = Text("The C snippet")
}
</pre>
</div>

</div>
<div class="Indented">
While the contents of the <tt>A.snippet</tt> tag are passed to the <tt>A.snippet</tt> method, there’s no requirement that the contents are actually used. For example, consider what would happen if we swapped the B and C snippet tags in our template, as shown in Listing <a class="Reference" href="#lst:The-Swapped-Recursive">4.1.2↓</a>. In this example, the <tt>C.snippet</tt> method is called before the <tt>B.snippet</tt> method. Since our <tt>C.snippet</tt> method returns straight XML that doesn’t contain the B snippet tag, the B snippet will never be executed! We’ll cover how the <tt>eager_eval</tt> tag attribute can be used to reverse this behavior in Section <a class="Reference" href="#sub:Eager-Eval">5.3.4↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
The Swapped Recursive Snippet Template<a class="Label" name="lst:The-Swapped-Recursive"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:A.snippet&gt;
  &lt;p&gt;Hello, &lt;A:name /&gt;!&lt;/p&gt;
  &lt;p&gt;
    &lt;lift:C.snippet&gt;
      &lt;lift:B.snippet&gt;
        &lt;B:title /&gt;
      &lt;/lift:B.snippet&gt;
    &lt;/lift:C.snippet&gt;
  &lt;/p&gt;
&lt;/lift:A.snippet&gt;
&lt;!-- After the A and C snippets have been processed: --&gt;
&lt;p&gt;Hello, The A snippet&lt;/p&gt;
&lt;p&gt;The C snippet&lt;/p&gt;
</pre>
</div>

</div>
<div class="Indented">
As you can see, templates are a nice way of setting up your layout and then writing a few methods to fill in the XML fragments that make up your web applications. They provide a simple way to generate a uniform look for your site, particularly if you assemble your templates using the surround and embed tags. If you’d like programmatic control over the template XML used for a particular request, you’ll want to use a View, which is discussed in the next section.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.2">4.2</a> Designer-Friendly Templates<a class="Label" name="sec:Designer-Friendly-Templates"> </a><a class="IndexReference" name="entry-Templates-Designer-friendly-0" href="#index-Templates-Designer-friendly">↓</a><a class="IndexReference" name="entry-Designer-friendly-templates-0" href="#index-Designer-friendly-templates">↓</a>
</h2>
<div class="Unindented">
New in Lift 2.2 is the ability to use fully valid XHTML (or HTML5, which we’ll discuss in Section <a class="Reference" href="#sec:HTML5-Support">4.3↓</a>) for your templates. There are a number of features involved in designer-friendly templates (or DFTs for short), so let’s go through each one.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.2.1">4.2.1</a> Determining the Content Element<a class="IndexReference" name="entry-Templates-content-element-0" href="#index-Templates-content-element">↓</a>
</h3>
<div class="Unindented">
In XML-based templates, the entire XML file is considered to hold the contents of the template. In DFTs, we want to be able to include the full XHTML or HTML5 markup, including tags like <tt>&lt;DOCTYPE&gt;</tt>, <tt>&lt;html/&gt;</tt>, etc. without necessarily including all of that in the output of the template (for example, in an embedded template). Lift supports choosing a child element of the template to represent the actual contents via the use of one of two related mechanisms.
</div>
<div class="Indented">
The first mechanism is to put a <tt>lift:content_id</tt> attribute on the HTML element, as shown in Listing <a class="Reference" href="#lst:Assigning-a-Content-ID-HTML">4.2.1↓</a>. The drawback to this approach is that you have to specify the “lift” namespace in the html tag or you might get validation errors.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Assigning a Content ID on the HTML element<a class="Label" name="lst:Assigning-a-Content-ID-HTML"> </a>
</div>
<pre class="listing brush: html">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
 &lt;html xmlns="http://www.w3.org/1999/xhtml" 
       xmlns:lift="http://liftweb.net" 
       lift:content_id="real_content"&gt;
   &lt;head&gt;
	&lt;title&gt;Not really&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
     &lt;div id="real_content"&gt;
       &lt;h1&gt;Welcome to your project!&lt;/h1&gt;
     &lt;/div&gt;
   &lt;/body&gt;
 &lt;/html&gt;
</pre>
</div>

</div>
<div class="Indented">
The second, safer approach, is to specific the <tt>lift:content_id</tt> marker as part of the body element’s <tt>class</tt> attribute, as shown in Listing <a class="Reference" href="#lst:Assigning-a-Content-ID-Body">4.2.1↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Assigning a Content ID in the Body class<a class="Label" name="lst:Assigning-a-Content-ID-Body"> </a>
</div>
<pre class="listing brush: html">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
 &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
   &lt;head&gt;
	&lt;title&gt;Not really&lt;/title&gt;
   &lt;/head&gt;
   &lt;body class="lift:content_id=real_content"&gt;
     &lt;div id="real_content"&gt;
       &lt;h1&gt;Welcome to your project!&lt;/h1&gt;
     &lt;/div&gt;
   &lt;/body&gt;
 &lt;/html&gt;
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.2.2">4.2.2</a> Invoking Snippets Via the Class Attribute<a class="IndexReference" name="entry-Snippets-invoking-via-class-attributes-0" href="#index-Snippets-invoking-via-class-attributes">↓</a>
</h3>
<div class="Unindented">
In XML-based templates, Lift looks for tags with the “lift” prefix to process. In DFTs, the <tt>class</tt> attribute is used instead for invocation. This form of invocation is discussed in more detail in Section <a class="Reference" href="#sec:The-Snippet-Tag">5.1 on page 1↓</a>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.2.3">4.2.3</a> Binding via CSS transforms<a class="IndexReference" name="entry-Binding-with-CSS-0" href="#index-Binding-with-CSS">↓</a>
</h3>
<div class="Unindented">
Lift 2.2 introduces a new feature for binding values into snippet markup by using CSS id and class attributes instead of prefixed XML elements. This support is detailed in Section <a class="Reference" href="#sub:CSS-Selector-Transforms">5.3.2 on page 1↓</a>.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.3">4.3</a> HTML5 Support<a class="Label" name="sec:HTML5-Support"> </a><a class="IndexReference" name="entry-HTML5-0" href="#index-HTML5">↓</a><a class="IndexReference" name="entry-HTML-Version-5-0" href="#index-HTML-Version-5">↓</a><a class="IndexReference" name="entry-Templates-HTML5-0" href="#index-Templates-HTML5">↓</a>
</h2>
<h2 class="Section">
<a class="toc" name="toc-Section-4.4">4.4</a> Views<a class="Label" name="sec:Views"> </a><a class="IndexReference" name="entry-Views-1" href="#index-Views">↓</a>
</h2>
<div class="Unindented">
We just discussed Templates and saw that through a combination of an XML file, Lift tags, and Scala code we can respond to requests made by a user. You can also generate an XHTML response entirely in code using a View. Custom dispatch is a similar method which can be used to programmatically return any kind of response (not just XHTML), and is covered in more depth in Section <a class="Reference" href="#sec:Custom-dispatch-func">3.8↑</a>.
</div>
<div class="Indented">
A view function is a normal Scala method of type <span class="formula">() ⇒ <i>scala</i>.<i>xml</i>.<i>NodeSeq</i></span><a class="IndexReference" name="entry-NodeSeq-0" href="#index-NodeSeq">↓</a>. The <tt>NodeSeq</tt> that’s returned from a view is processed for template tags in the same way that XML loaded from a static file would be. As we showed in Section <a class="Reference" href="#sec:The-Rendering-Process">3.5↑</a>, there are two ways that a View can be invoked. The first is by defining a partial function for <tt>LiftRules.viewDispatch<a class="IndexReference" name="entry-viewDispatch-2" href="#index-viewDispatch">↓</a><a class="IndexReference" name="entry-Views-Explicit-dispatch-2" href="#index-Views-Explicit-dispatch">↓</a></tt>, which allows you to dispatch to any statically-available method (i.e. on an <tt>object</tt>, not a <tt>class</tt>), or to a <tt>LiftView</tt> (explained in a moment) object for any arbitrary request path. The second way that a View can be invoked is by reflection: if the first element of the request path matches the class name of the View (as defined in Section <a class="Reference" href="#sub:Class-Resolution">3.2.1↑</a>), then the second element is used to look up the View function depending on which trait the View class implements. For performance reasons, explicit dispatch via <tt>LiftRules.viewDispatch</tt> is recommended because reflection incurs a significant cost for each request. When you use <tt>LiftRules.viewDispatch</tt>, you need to provide an instance of <tt>scala.lang.Either</tt> to differentiate the dispatch type: a <tt>scala.lang.Left</tt> indicates a method returning a <tt>Box[NodeSeq]</tt>, while a <tt>scala.lang.Right</tt> indicates a <tt>LiftView</tt> object. If you want to dispatch a request to a <tt>LiftView</tt> object, the match in the <tt>LiftRules.viewDispatch</tt> is made on all path components except the last one (e.g. <tt>List.init</tt>), and that object’s <tt>dispatch</tt> method is checked against the last component of the path to further determine which method on the object will handle the request. Listing <a class="Reference" href="#lst:Explicit-View-Dispatch">4.4↓</a> shows how we can define an RSS view as a feed using explicit dispatch. Note that we use extraction on the requested path in this case to provide account-specific feeds and a security token to prevent feed browsing.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Explicit View Dispatch<a class="Label" name="lst:Explicit-View-Dispatch"> </a>
</div>
<pre class="listing brush: scala">// In Boot.boot:
LiftRules.viewDispatch.append {
  // This is an explicit dispatch to a particular method based on the path
  case List("Expenses", "recent", acctId, authToken) =&gt;
    Left(() =&gt; Full(RSSView.recent(acctId, authToken)))
​
  // This is a dispatch via the same LiftView object. The path
  // "/Site/news" will match this dispatch because of our dispatch
  // method defined in RSSView. The path "/Site/stuff/news" will not
  // match because the dispatch will be attempted on List("Site","stuff")
  case List("Site") =&gt; Right(RSSView)
}
​
// Define the View object:
object RSSView extends LiftView {
  def dispatch = {
    case "news" =&gt; siteNews
  }
​
  def recent(acctId : String, authToken : String)() : NodeSeq = {
     // User auth, account retrieval here
     ...
     &lt;lift:surround with="rss" at="content"&gt;
       ...
     &lt;/lift:surround&gt;
  }
​
  // Display a general RSS feed for the entire site
  def siteNews() : NodeSeq = { ... }
}
</pre>
</div>

</div>
<div class="Indented">
If you want to use reflection for dispatch<a class="IndexReference" name="entry-Views-Implicit-dispatch-0" href="#index-Views-Implicit-dispatch">↓</a><a class="IndexReference" name="entry-Views-Reflection-dispatch-0" href="#index-Views-Reflection-dispatch">↓</a> then there are two traits that you can use when implementing a view class: one is the <tt>LiftView</tt><a class="IndexReference" name="entry-LiftView-0" href="#index-LiftView">↓</a> trait, the other is the <tt>InsecureLiftView</tt><a class="IndexReference" name="entry-InsecureLiftView-0" href="#index-InsecureLiftView">↓</a> trait, both under the <tt>net.liftweb.http</tt> package. As you may be able to tell from the names, we would prefer that you extend the <tt>LiftView</tt> trait. The <tt>InsecureLiftView</tt> determines method dispatch by turning a request path into a class and method name. For example, if we have a path <tt>/MyStuff/enumerate</tt>, then Lift will look for a class called <tt>MyStuff</tt> in the view subpackage (class resolution is covered in Section <a class="Reference" href="#sub:Class-Resolution">3.2.1↑</a>) and if it finds <tt>MyStuff</tt> and it has a method called <tt>enumerate</tt>, then Lift will execute the <tt>enumerate</tt> method and return its result to the user. The main concern here is that Lift uses reflection<a class="IndexReference" name="entry-reflection-0" href="#index-reflection">↓</a> to get the method with <tt>InsecureLiftView</tt>, so it can access any method in the class, even ones that you don’t intend to make public. A better way to invoke a View is to extend the <tt>LiftView</tt> trait, which defines a dispatch partial function. This dispatch function maps a string (the “method name”) to a function that will return a <tt>NodeSeq</tt>. Listing <a class="Reference" href="#lst:Dispatch-in-LiftView">4.4↓</a> shows a custom <tt>LiftView</tt> class where the path <tt>/ExpenseView/enumerate</tt> will map to the <tt>ExpenseView.doEnumerate</tt> method. If a user attempts to go to <tt>/ExpenseView/privateMethod</tt> they’ll get a 404 because <tt>privateMethod</tt> is not defined in the dispatch method. If, however, our <tt>ExpenseView</tt> class implemented the <tt>InsecureLiftView</tt> trait and someone visited <tt>/ExpenseView/privateMethod</tt>, we would lose our hard drive (on Unix at least).
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Dispatch in LiftView<a class="Label" name="lst:Dispatch-in-LiftView"> </a>
</div>
<pre class="listing brush: scala">class ExpenseView extends LiftView {
  override def dispatch = {
    case "enumerate" =&gt; doEnumerate _
  }
​
  def doEnumerate () : NodeSeq = {  
    ...
    &lt;lift:surround with="default" at="content"&gt;
     { expenseItems.toTable }
    &lt;/lift:surround&gt;
  }
​
  def privateMethod () : NodeSeq = {
    Runtime.getRuntime.exec("rm -rf /")
  }
}
</pre>
</div>

</div>
<div class="Indented">
A major difference between Views and other programmatic rendering approaches (such as Custom Dispatch) is that the <tt>NodeSeq</tt> returned from the View method is processed for template tags including <tt>surrounds</tt> and <tt>includes</tt>, just as it would be for a snippet. That means that you can use the full power of the templating system from within your View, as shown in Listing <a class="Reference" href="#lst:Dispatch-in-LiftView">4.4↑</a>’s <tt>doEnumerate</tt> method.
</div>
<div class="Indented">
Since you can choose not to include any of the pre-defined template XHTML, you can easily generate any XML-based content, such as Atom or RSS feeds, using a View.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.5">4.5</a> Tags<a class="Label" name="sec:ArchTags"> </a>
</h2>
<div class="Unindented">
In the earlier sections on Templates and Views we briefly touched on some of Lift’s built-in tags, namely, <tt>&lt;lift:snippet/&gt;</tt> and <tt>&lt;lift:surround</tt>/&gt;. In this section we’ll go into more detail on those tags as well as cover the rest of Lift’s tags.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.1">4.5.1</a> a<a class="Label" name="sub:a-tag"> </a><a class="IndexReference" name="entry-Tags-a-0" href="#index-Tags-a">↓</a><a class="IndexReference" name="entry-SHtml-a-0" href="#index-SHtml-a">↓</a><a class="IndexReference" name="entry-AJAX-anchor-tag-0" href="#index-AJAX-anchor-tag">↓</a>
</h3>
<div class="Unindented">
The <tt>&lt;lift:a/&gt;</tt> tag is used internally by <tt>SHtml.a</tt> to create an anchor tag that will call an AJAX function when clicked. This tag is generally not used directly by developers. See Section <a class="Reference" href="#sub:AJAX-Generators-in-detail">11.4 on page 1↓</a> for more details.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.2">4.5.2</a> bind<a class="Label" name="sub:bind-tag"> </a><a class="IndexReference" name="entry-Tags-bind-0" href="#index-Tags-bind">↓</a><a class="IndexReference" name="entry-binding-1" href="#index-binding">↓</a>
</h3>
<pre class="LyX-Code">
Usage: &lt;lift:bind name=”binding_name” /&gt;
</pre>
<div class="Unindented">
The <tt>&lt;lift:bind/&gt;</tt> tag is used as a placeholder for insertion of content within included templates when using the <tt>&lt;lift:surround/&gt; and</tt> <tt>&lt;lift:embed/&gt;</tt> tags. See Section <a class="Reference" href="#sec:Binding">4.7↓</a> for examples and discussion.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.3">4.5.3</a> bind-at<a class="Label" name="sub:bind-at-tag"> </a><a class="IndexReference" name="entry-Tags-bind-at-0" href="#index-Tags-bind-at">↓</a><a class="IndexReference" name="entry-binding-2" href="#index-binding">↓</a>
</h3>
<pre class="LyX-Code">
Usage: &lt;lift:bind-at name=”binding_name”&gt;contents&lt;/lift:bind-at&gt;
</pre>
<div class="Unindented">
The <tt>&lt;lift:bind-at/&gt;</tt> tag is used to replace named <tt>&lt;lift:bind/&gt;</tt> tags within <tt>&lt;lift:surround/&gt;</tt> and <tt>&lt;lift:embed/&gt;</tt> tags. See Section <a class="Reference" href="#sec:Binding">4.7↓</a> for examples and discussion.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.4">4.5.4</a> children<a class="Label" name="sub:children-tag"> </a><a class="IndexReference" name="entry-Tags-children-0" href="#index-Tags-children">↓</a><a class="IndexReference" name="entry-children-0" href="#index-children">↓</a>
</h3>
<pre class="LyX-Code">
Usage: &lt;lift:children&gt;...multiple xml nodes here...&lt;/lift:children&gt;
</pre>
<div class="Unindented">
The purpose of the <tt>&lt;lift:children/&gt;</tt> tag is to allow you to create fragment templates with more than one root element that still parse as valid XML. For example, Listing <a class="Reference" href="#lst:A-Non-Conforming-XML">4.5.4↓</a> shows a template that we might want to embed into other templates. The problem is that XML requires a single root element, and in this case we have two.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Non-Conforming XML Fragment<a class="Label" name="lst:A-Non-Conforming-XML"> </a>
</div>
<pre class="listing brush: xml">&lt;div&gt;First Div&lt;/div&gt;
&lt;div&gt;Second Div&lt;/div&gt;
</pre>
</div>

</div>
<div class="Indented">
By using the <tt>&lt;lift:children/&gt;</tt> tag, as shown in Listing <a class="Reference" href="#lst:A-Conforming-XML">4.5.4↓</a>, we have a valid XML file. Lift essentially replaces the <tt>&lt;lift:children/&gt;</tt> tag with its contents.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Conforming XML Fragment<a class="Label" name="lst:A-Conforming-XML"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:children&gt;
&lt;div&gt;First Div&lt;/div&gt;
&lt;div&gt;Second Div&lt;/div&gt;
&lt;/lift:children&gt;
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.5">4.5.5</a> comet<a class="Label" name="sub:comet-tag"> </a><a class="IndexReference" name="entry-Tags-comet-0" href="#index-Tags-comet">↓</a><a class="IndexReference" name="entry-Comet-0" href="#index-Comet">↓</a>
</h3>
<pre class="LyX-Code">
<tt>Usage: &lt;lift:comet type="ClassName" name=”optional”/&gt;</tt>
</pre>
<div class="Unindented">
The <tt>&lt;lift:comet/&gt;</tt> tag embeds a Comet actor into your page. The class of the Comet actor is specified by the <tt>type</tt> attribute. The <tt>name</tt> attribute tells Lift to create a unique instance of the Comet actor; for example, you could have one Comet actor for site updates and another for admin messages. The contents of the tag are used by the Comet actor to bind a response. Listing <a class="Reference" href="#lst:Ledger-Entry-Comet">4.5.5↓</a> shows an example of a Comet binding that displays expense entries as they’re added. Comet is covered in more detail in Chapter <a class="Reference" href="#cha:AJAX-and-COMET">11↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Account Entry Comet<a class="Label" name="lst:Ledger-Entry-Comet"> </a>
</div>
<pre class="listing brush: xml">&lt;div class="accountUpdates"&gt;
  &lt;lift:comet type="AccountMonitor"&gt;
    &lt;ul&gt;&lt;account:entries&gt;
      &lt;li&gt;&lt;entry:time/&gt; : &lt;entry:user /&gt; : &lt;entry:amount /&gt;&lt;/li&gt;
    &lt;/account:entries&gt;&lt;/ul&gt;
  &lt;/lift:comet&gt;
&lt;/div&gt;
</pre>
</div>

</div>
<div class="Indented">
As we mention in the <tt>embed</tt> tag documentation, mixing Comet with AJAX responses can be a bit tricky due to the embedded JavaScript that Comet uses.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.6">4.5.6</a> CSS<a class="Label" name="sub:CSS-tag"> </a><a class="IndexReference" name="entry-Tags-CSS-0" href="#index-Tags-CSS">↓</a><a class="IndexReference" name="entry-CSS-0" href="#index-CSS">↓</a>
</h3>
<pre class="LyX-Code">
Usage: &lt;lift:CSS.blueprint /&gt;
       &lt;lift:CSS.fancyType /&gt;
</pre>
<div class="Unindented">
The <tt>&lt;lift:CSS/&gt;</tt> tag is used to insert the blueprint<span class="FootOuter"><span class="SupFootMarker"> [S] </span><span class="HoverFoot"><span class="SupFootMarker"> [S] </span><a class="FlexURL" href="http://www.blueprintcss.org/">http://www.blueprintcss.org/</a></span></span> and (optionally) fancyType <span class="FootOuter"><span class="SupFootMarker"> [T] </span><span class="HoverFoot"><span class="SupFootMarker"> [T] </span><a class="FlexURL" href="http://anthonygthomas.com/2010/02/15/blueprint-optional-fancy-type-plugin/">http://anthonygthomas.com/2010/02/15/blueprint-optional-fancy-type-plugin/</a></span></span> CSS stylesheets
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.7">4.5.7</a> embed<a class="IndexReference" name="entry-embed-0" href="#index-embed">↓</a><a class="Label" name="sub:embed-tag"> </a> <a class="IndexReference" name="entry-Tags-embed-0" href="#index-Tags-embed">↓</a>
</h3>
<pre class="LyX-Code">
Usage:<tt> &lt;lift:embed what="template_name" /&gt;</tt>
</pre>
<div class="Unindented">
The <tt>embed</tt> tag allows you to embed a template within another template. This can be used to assemble your pages from multiple smaller templates, and it also allows you to access templates from JavaScript commands (Chapter <a class="Reference" href="#cha:Lift-and-Javascript">10↓</a>). As with the <tt>surround</tt> tag, the template name can be either the base filename or a fully-qualified path.
</div>
<div class="Indented">
<div class="center">
<div class="Shadowbox" style="width: 75%;">
<span class="small">Note that if you use the embed tag to access templates from within a JsCmd (typically an AJAX call), any JavaScript in the embedded template won’t be executed. This includes, but is not limited to, Comet widgets.</span>
</div>

</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.8">4.5.8</a> form
</h3>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.9">4.5.9</a> HTML5
</h3>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.10">4.5.10</a> ignore
</h3>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.11">4.5.11</a> lazy-load
</h3>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.12">4.5.12</a> loc
</h3>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.13">4.5.13</a> Menu
</h3>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.14">4.5.14</a> Msgs
</h3>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.15">4.5.15</a> SkipDocType
</h3>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.16">4.5.16</a> snippet
</h3>
<div class="Unindented">
The snippet tag is covered in detail in Section <a class="Reference" href="#sec:The-Snippet-Tag">5.1 on page 1↓</a>, part of the chapter on snippets.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.17">4.5.17</a> surround<a class="IndexReference" name="entry-surround-0" href="#index-surround">↓</a><a class="IndexReference" name="entry-Tags-surround-0" href="#index-Tags-surround">↓</a><a class="Label" name="sub:surround-tag"> </a>
</h3>
<pre class="LyX-Code">
Usage:<tt> &lt;lift:surround with="template_name" at=”binding”&gt;</tt>
<tt>         children</tt>
<tt>       &lt;/lift:surround&gt;</tt>
</pre>
<div class="Unindented">
The <tt>surround</tt> tag surrounds the child nodes with the named template. The child nodes are inserted into the named template at the binding point specified by the <tt>at</tt> parameter (we’ll cover the bind tag in Section <a class="Reference" href="#sub:bind-tag">4.5.2↑</a>). Typically, templates that will be used to surround other templates are incomplete by themselves, so we usually store them in the <tt>&lt;app root&gt;/templates-hidden</tt> subdirectory so that they can’t be accessed directly. Having said that, “incomplete” templates may be placed in any directory that templates would normally go in. The most common usage of <tt>surround</tt> is to permit you to use a “master” template for your site CSS, menu, etc. An example use of <tt>surround</tt> is shown in Listing <a class="Reference" href="#lst:Surrounding-your-page">4.5.17↓</a>. We’ll show the counterpart master template in the section on the bind tag. Note also that the surrounding template name can be either a fully-qualified path (i.e. “/templates-hidden/default”), or just the base filename (“default”). In the latter case, Lift will search all subdirectories of the app root for the template. By default, Lift will use “/templates-hidden/default” if you don’t specify a <tt>with</tt> attribute, so Listings <a class="Reference" href="#lst:Surrounding-your-page">4.5.17↓</a> and <a class="Reference" href="#lst:Surrounding-with-the-default-template">4.5.17↓</a> are equivalent.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Surrounding Your Page<a class="Label" name="lst:Surrounding-your-page"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:surround with="default" at="content"&gt;
  &lt;p&gt;Welcome to PocketChange!&lt;/p&gt;
&lt;/lift:surround&gt;
</pre>
</div>

</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Surrounding with the default template<a class="Label" name="lst:Surrounding-with-the-default-template"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:surround at="content"&gt;
  &lt;p&gt;Welcome to PocketChange!&lt;/p&gt;
&lt;/lift:surround&gt;
</pre>
</div>

</div>
<div class="Indented">
Note that you can use multiple surround templates for different functionality, and surrounds can be nested. For example, you might want to have a separate template for your administrative pages that adds a menu to your default template. In that case, your <tt>admin.html</tt> could look like Listing <a class="Reference" href="#lst:Adding-an-Admin-menu">4.5.17↓</a>. As you can see, we’ve named our bind point in the admin template “content” so that we keep things consistent for the rest of our templates. So if, for example, we were going to nest the template in Listing <a class="Reference" href="#lst:Surrounding-your-page">4.5.17↑</a> above into the <tt>admin.html</tt> template in Listing <a class="Reference" href="#lst:Adding-an-Admin-menu">4.5.17↓</a>, all we’d need to do is change it’s <tt>with</tt> attribute from “default” to “admin.”
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Adding an Admin Menu<a class="Label" name="lst:Adding-an-Admin-menu"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:surround with="default" at="content"&gt;
  &lt;lift:Admin.menu /&gt;
  &lt;lift:bind name="content" /&gt;
&lt;/lift:surround&gt;
</pre>
</div>

</div>
<div class="Indented">
<div class="center">
<div class="Shadowbox" style="width: 75%;">
<span class="small">You cannot have a hidden template with the same name as a sub-directory of your webapp directory. For example, if you had an admin.html template in /templates-hidden, you could not also have an admin directory. </span>
</div>

</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.18">4.5.18</a> tail
</h3>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.19">4.5.19</a> TestCond
</h3>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.20">4.5.20</a> with-param
</h3>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.21">4.5.21</a> with-resource-id
</h3>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.22">4.5.22</a> VersionInfo
</h3>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.5.23">4.5.23</a> XmlGroup
</h3>
<h2 class="Section">
<a class="toc" name="toc-Section-4.6">4.6</a> Head and Tail Merge<a class="Label" name="sec:Head-Tail-Merge"> </a>
</h2>
<div class="Unindented">
Another feature of Lift’s template processing is the ability to merge the HTML <tt>head</tt><a class="IndexReference" name="entry-head-0" href="#index-head">↓</a> element in a template with the <tt>head</tt> element in the surrounding template. In our example, Listing <a class="Reference" href="#lst:Sample-template">4.1↑</a>, notice that we’ve specified a <tt>head</tt> tag inside the template. Without the head merge, this <tt>head</tt> tag would show up in the default template where our template gets bound. Lift is smart about this, though, and instead takes the content of the <tt>head</tt> element and merges it into the outer template’s <tt>head</tt> element. This means that you can use a <tt>surround</tt> tag to keep a uniform default template, but still do things such as changing the title of the page, adding scripts or special CSS, etc. For example, if you have a table in a page that you’d like to style with jQuery’s TableSorter, you could add a head element to insert the appropriate script:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using Head Merge<a class="Label" name="lst:Using-Head-Merge"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:surround with="default" at="foo"&gt;
&lt;head&gt;&lt;script src="/scripts/tablesorter.js" type="text/javascript" /&gt;&lt;head&gt;
...
&lt;/lift:surround&gt;
</pre>
</div>

</div>
<div class="Indented">
In this manner, you’ll import TableSorter for this template alone.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.7">4.7</a> Binding<a class="Label" name="sec:Binding"> </a>
</h2>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-5">5</a> Snippets<a class="IndexReference" name="entry-Snippets-0" href="#index-Snippets">↓</a><a class="Label" name="cha:Snippets"> </a>
</h1>
<div class="Unindented">
Put simply, a snippet is a Scala method that transforms input XML into output XML<a class="IndexReference" name="entry-XML-1" href="#index-XML">↓</a>. Snippets act as independent (or dependent, if you want) pieces of logic that you insert into your page to perform rendering. As such, snippets form the backbone of Lift’s View-First<a class="IndexReference" name="entry-View-First-0" href="#index-View-First">↓</a> rendering architecture. Although snippets aren’t the only mechanism Lift has for rendering page views (see Views, Section <a class="Reference" href="#sec:Views">4.4 on page 1↑</a>, Custom Dispatch, Section <a class="Reference" href="#sec:Custom-dispatch-func">3.8 on page 1↑</a>, or even the REST API, Chapter <a class="Reference" href="#cha:Web-Services">15↓</a>), they’re so widely used and so important that we feel they warrant their own chapter.
</div>
<div class="Indented">
In this chapter we will cover the ins and outs of snippets, from the snippet tag that you place in your templates, through how the snippet method is resolved, to the snippet method definition itself. We’ll also cover related topics and some advanced functionality in snippets for those looking to push Lift’s boundaries.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-5.1">5.1</a> The Snippet Tag<a class="IndexReference" name="entry-snippet-0" href="#index-snippet">↓</a><a class="IndexReference" name="entry-Tags-snippet-0" href="#index-Tags-snippet">↓</a><a class="Label" name="sec:The-Snippet-Tag"> </a><a class="Label" name="sub:snippet-tag"> </a>
</h2>
<pre class="LyX-Code">
<tt>Usage: &lt;lift:snippet type="snippetName" ...options... /&gt;</tt>
       &lt;lift:snippetName ...options... /&gt;
       &lt;div class=”lift:snippetName?opt1=...;opt2=...;opt3=...” /&gt;
</pre>
<div class="Unindented">
The snippet tag is what you use to tell Lift where and how to invoke a snippet method on given XML content. The most important part of the tag is the snippet name, which is used to resolve which snippet method will process the snippet tag contents. We’ll cover how the snippet name is resolved to a concrete method in section <a class="Reference" href="#sub:Snippet-Dispatch">5.2↓</a>. 
</div>
<div class="Indented">
<div class="center">
<div class="Shadowbox" style="width: 75%;">
Note that there is a shorthand for the <tt>type</tt> attribute simply by appending the snippet name after the <tt>lift:</tt> prefix. If you use this shorthand, make sure to avoid naming your snippets the same as Lift’s built-in tags, such as <tt>surround</tt>, <tt>children</tt>, <tt>embed</tt>, etc.
</div>

</div>

</div>
<div class="Indented">
In addition to the the <tt>type</tt> attribute, Lift will process several other options:
</div>
<div class="Description">
<span class="Description-entry">form</span> If the <tt>form<a class="IndexReference" name="entry-Forms-snippet-tag-0" href="#index-Forms-snippet-tag">↓</a></tt> attribute is included with a value of either “POST” or “GET”, then an appropriate form tag will be emitted into the XHTML using the specified submission method. If you omit this tag from a snippet that generates a form, the form elements will display but the form won’t submit.
</div>
<div class="Description">
<span class="Description-entry">multipart</span> <a class="IndexReference" name="entry-Forms-multipart-0" href="#index-Forms-multipart">↓</a><a class="IndexReference" name="entry-Forms-file-upload-0" href="#index-Forms-file-upload">↓</a>The <tt>multipart</tt> attribute is a boolean (the default is false, specify “yes”, “true” or “1” to enable) that specifies whether a generated form tag should be set to use multipart form submission. This is most typically used for file uploads (Section <a class="Reference" href="#sec:File-Uploads">6.4↓</a>). If you don’t also specify the <tt>form</tt> attribute then this won’t do anything.
</div>
<div class="Description">
<span class="Description-entry">eager_eval</span> <a class="IndexReference" name="entry-Snippets-eager_eval-0" href="#index-Snippets-eager_eval">↓</a>The eager_eval attribute is a boolean (the default is false, specify “yes”, “true” or “1” to enable) that controls the order of processing for the snippet tag contents. Normally, the snippet is processed and then the XML returned from the snippet is further processed for Lift tags. Enabling eager_eval reverses this order so that the contents of the snippet tag are processed first. We cover this in more detail with an example in Section <a class="Reference" href="#sub:Eager-Eval">5.3.4↓</a>.
</div>
<div class="Unindented">
With Lift 2.2’s Designer-Friendly Templates (Section <a class="Reference" href="#sec:Designer-Friendly-Templates">4.2 on page 1↑</a>), you can also specify a snippet tag as part of the class attribute for a given element. Attributes for snippets invoked in this manner are passed via a query string. Listing <a class="Reference" href="#lst:Invoking-Snippets-Via-Class">5.1↓</a> shows an example of how we can use the standard <tt>lift:surround</tt> processing by modiying the <tt>class</tt> of our content element.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Invoking Snippets Via the Class Attribute<a class="Label" name="lst:Invoking-Snippets-Via-Class"> </a>
</div>
<pre class="listing brush: scala">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
 &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
   &lt;head&gt;
	&lt;title&gt;Not really&lt;/title&gt;
   &lt;/head&gt;
   &lt;body class="lift:content_id=real_content"&gt;
     &lt;div class="lift:surround?with=default;at=content" id="real_content"&gt;
       &lt;h1&gt;Welcome to your project!&lt;/h1&gt;
     &lt;/div&gt;
   &lt;/body&gt;
 &lt;/html&gt;
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-5.2">5.2</a> Snippet Dispatch<a class="Label" name="sub:Snippet-Dispatch"> </a><a class="IndexReference" name="entry-Snippets-Dispatch-0" href="#index-Snippets-Dispatch">↓</a>
</h2>
<div class="Unindented">
The first step taken by Lift when evaluating a snippet tag is to resolve what snippet method will actually process the content. There are several mechanisms that are used to resolve the method, but they can be broken down into two main approaches: dispatch via reflection and explicit dispatch. In addition, Lift allows per-request remapping of snippet names via <tt>S.mapSnippet</tt><a class="IndexReference" name="entry-mapSnippet-0" href="#index-mapSnippet">↓</a>. We’ll cover each in the following sections.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-5.2.1">5.2.1</a> Implicit Dispatch Via Reflection<a class="IndexReference" name="entry-Reflection-0" href="#index-Reflection">↓</a><a class="IndexReference" name="entry-Snippets-Implicit-dispatch-0" href="#index-Snippets-Implicit-dispatch">↓</a><a class="Label" name="sub:Implicit-Dispatch-Via"> </a>
</h3>
<div class="Unindented">
The simplest, and default, approach to resolving snippet names is to use implicit dispatch via reflection. When using implicit dispatch, Lift will use the snippet name specified in the snippet tag to first locate a class. Lift will then either instantiate a class, or if it’s a stateful snippet (we’ll cover stateful snippets in Section <a class="Reference" href="#sub:Stateless-versus-Stateful">5.3.3↓</a>), retrieve the current instance. One Lift has a class instance, it uses the snippet name to further determine which method in the class to execute. There are three ways to specify this:
</div>
<ol>
<li>
Via the <tt>type</tt> attribute on the snippet tag. The value should be “<tt>ClassName</tt>:<tt>method</tt>” for the particular snippet method you want to have handle the tag
</li>
<li>
Via a tag suffix of <tt>Class.method</tt>. This is the same as specifying the <tt>type=”Class:method”</tt> attribute
</li>
<li>
Via a tag suffix of just <tt>Class</tt>. This will use the <tt>render</tt> method on the specified class to handle the tag
</li>

</ol>
<div class="Unindented">
Classes are resolved as specified in Section <a class="Reference" href="#sub:Class-Resolution">3.2.1↑</a>. 
</div>
<div class="Indented">
<div class="center">
<div class="Shadowbox" style="width: 75%;">
The most important thing to remember when using implicit dispatch is that your snippet classes must be members of a <tt>snippet</tt> subpackage as registered by <tt>LiftRules.addToPackages</tt>. For example, if you have <tt>LiftRules.addToPackages(“com.foo”)</tt> in your <tt>Boot.boot</tt> method, snippets should be members of <tt>com.foo.snippet</tt>.
</div>

</div>

</div>
<div class="Indented">
Listing <a class="Reference" href="#lst:Snippet-tag-equivalence">5.2.1↓</a> shows three equivalent snippet tags. Note: these are only equivalent because the method name is “render.” If we had chosen a different method, e.g., “list,” then the third example below will still call a “render” method. 
</div>
<div class="Indented">
<div class="center">
<tt><div class="Shadowbox" style="width: 75%;">
It’s important to note that with pure implicit dispatch, Java’s reflection allows access to <i>any</i> method on the enclosing class, no matter what the protection on the method is set to (e.g. private, protected). Because of this, it’s possible to invoke private and protected methods via implicit dispatch, which could be a security concern.This is one reason that we recommend using either DispatchSnippet or explicit dispatch for production sites. We’ll cover both of these approaches momentarily.<div class="PlainVisible">
Another important note is that lookup via reflection is relatively expensive<span class="FootOuter"><span class="SupFootMarker"> [U] </span><span class="HoverFoot"><span class="SupFootMarker"> [U] </span>See <a class="FlexURL" href="http://www.jguru.com/faq/view.jsp?EID=246569">http://www.jguru.com/faq/view.jsp?EID=246569</a> for a more thorough explanation</span></span> operation, yet another reason that we recommend explicit dispatch for production sites.
</div>

</div>
</tt>
</div>

</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Snippet Tag Equivalence<a class="Label" name="lst:Snippet-tag-equivalence"> </a>
</div>
<pre class="listing brush: scala">&lt;lift:snippet type="MyClass:render" /&gt;
&lt;lift:MyClass.render /&gt;
&lt;lift:MyClass /&gt;
</pre>
</div>

</div>
<div class="Indented">
In addition to “pure” implicit dispatch, you can exert a little more control on which method in a given class handles a snippet by implementing the <tt>net.liftweb.http.DispatchSnippet<a class="IndexReference" name="entry-DispatchSnippet-0" href="#index-DispatchSnippet">↓</a></tt> trait. This trait contains a single method, dispatch, of type <span class="formula"><i>PartialFunction</i>[<i>String</i>, <i>NodeSeq</i> ⇒ <i>NodeSeq</i>]</span> that maps the method name (the “method” part of “Class.method” or “Class:method” as described above) to a particular method. Only method names defined in the dispatch PartialFunction can be executed; any methods that aren’t covered by the partial function will result in a snippet failure. Listing <a class="Reference" href="#lst:Using-DispatchSnippet-to-select">5.2.1↓</a> shows how you can control the dispatch by providing a custom <tt>dispatch</tt> def.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using DispatchSnippet to Control Snippet Method Selection<a class="Label" name="lst:Using-DispatchSnippet-to-select"> </a>
</div>
<pre class="listing brush: scala">package com.foo.snippet
​
import scala.xml.{NodeSeq,Text}
import net.liftweb.http.DispatchSnippet
​
class SomeSnippetClass extends DispatchSnippet {
  def dispatch : DispatchIt = {
    // We have to use a partially-applied (trailing "_") version
    // of the functions that we dispatch to
    case "foo" =&gt; myFooMethod _ 
    case "bar" =&gt; someOtherBarMethod _
    case _ =&gt; catchAllMethod _
  }
​
  def myFooMethod (xhtml : NodeSeq) : NodeSeq = { ... }
  def someOtherBarMethod (xhtml : NodeSeq) : NodeSeq = { ... }
  def catchAllMethod(xhtml : NodeSeq) : NodeSeq = Text("You’re being naughty!")
}
</pre>
</div>

</div>
<div class="Indented">
To summarize, implicit dispatch is the default method by which Lift resolves snippet tag names to the actual class and method that will process the snippet tag contents. Although implicit dispatch is simple to use and works well, security concerns lead us to recommend the use of the <tt>DispatchSnippet<a class="IndexReference" name="entry-DispatchSnippet-1" href="#index-DispatchSnippet">↓</a></tt> trait. Even with <tt>DispatchSnippet</tt>, however, the implicit class resolution still uses reflection, so if you’re trying to make things performant you should use explicit dispatch instead.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-5.2.2">5.2.2</a> Explicit Dispatch<a class="IndexReference" name="entry-Snippets-Explicit-Dispatch-0" href="#index-Snippets-Explicit-Dispatch">↓</a><a class="Label" name="sub:Explicit-Dispatch"> </a>
</h3>
<div class="Unindented">
Explicit dispatch allows you to have direct control over which methods will be executed for a given snippet name. There are two ways that you can define snippet name to method mappings: via <tt>LiftRules.snippetDispatch</tt>, which points Lift to <tt>DispatchSnippet</tt> instances, and <tt>LiftRules.snippets</tt>, which points Lift directly at methods.
</div>
<div class="Indented">
Let’s first take a look at <tt>LiftRules.snippetDispatch</tt>, the more generic option. When a snippet tag is encountered with a snippet name of the form <tt>A.B</tt> or <tt>A:B</tt>, Lift will take the first portion (<tt>A</tt>) and use that as the lookup for <tt>snippetDispatch</tt>. The <tt>PartialFunction</tt> needs to return an instance of <tt>DispatchSnippet</tt>, so typically you will implement your explicit dispatch snippets using an <tt>object</tt> instead of a <tt>class</tt>. Listing <a class="Reference" href="#lst:Defining-an-Explicit-snippet">5.2.2↓</a> shows how we define our object. Note that the <tt>dispatch</tt> method will be executed with the “<tt>B</tt>” portion of the snippet name (as we defined above) as its argument. Other than the fact that it’s an object, the definition is essentially identical to our implicit dispatch class in Listing <a class="Reference" href="#lst:Using-DispatchSnippet-to-select">5.2.1↑</a>. <div class="listing">
<div class="caption">
Defining an Explicit Snippet Object<a class="Label" name="lst:Defining-an-Explicit-snippet"> </a>
</div>
<pre class="listing brush: scala">// The package *doesn’t* need to be "snippet" because there’s
// no reflection involved here
package com.foo.logic
​
import scala.xml.{NodeSeq,Text}
import net.liftweb.http.DispatchSnippet
​
object HelloWorld extends DispatchSnippet {
  // We define dispatch as a val so that it doesn’t get re-created
  // on each request 
  val dispatch : DispatchIt = {
    case name =&gt; render(name) _
  }
​
  def render (name : String)(ignore : NodeSeq) : NodeSeq = 
    Text("Hello, world! Invoked as " + name)
}
</pre>
</div>

</div>
<div class="Indented">
Now that we have our snippet object, we can bind it to a particular snippet name in our <tt>Boot.boot</tt> method, as shown in Listing <a class="Reference" href="#lst:Binding-Our-Explicit-snippet">5.2.2↓</a>. It’s interesting to note that this is actually how Lift defines many of its tags, such as <tt>&lt;lift:embed/&gt;</tt>, <tt>&lt;lift:surround/&gt;</tt>, and <tt>&lt;lift:comet/&gt;</tt>. In our case, we’ve bound our snippet object to <tt>&lt;lift:HelloWorld/&gt;</tt>, and because our <tt>DispatchSnippet</tt> uses a simple variable binding for its <tt>dispatch</tt> method case, we can invoke the same snippet with <tt>&lt;lift:HelloWorld.hey /&gt;</tt>, <tt>&lt;lift:HelloWorld.useless/&gt;</tt>, or even <tt>&lt;lift:HelloWorld.this_is_getting_silly/&gt;</tt>, and the snippet will tell us what name it was invoked with (<tt>&lt;lift:HelloWorld/&gt;</tt> will invoke with the name “render”, following Lift’s normal snippet tag conventions). Noe that if you’re setting up a dispatch for a <tt>StatefulSnippet</tt><a class="IndexReference" name="entry-StatefulSnippet-0" href="#index-StatefulSnippet">↓</a><a class="IndexReference" name="entry-Snippets-stateful-0" href="#index-Snippets-stateful">↓</a>, return a new instance of your <tt>StatefulSnippet</tt> class. <tt>StatefulSnippet</tt> instances will properly register themselves ahead of the <tt>snippetDispatch</tt> partial function on each successive request.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Binding Our Explicit Snippet Object<a class="Label" name="lst:Binding-Our-Explicit-snippet"> </a>
</div>
<pre class="listing brush: scala">class Boot {
  def boot {
    ...
    LiftRules.snippetDispatch.append {
      case "HelloWorld" =&gt; com.foo.logic.HelloWorld
      // For StatefulSnippets, return a *new instance*
      case "HelloConversation" =&gt; 
        new com.foo.logic.StatefulHelloWorld
    }
  }
}
</pre>
</div>

</div>
<div class="Indented">
Now let’s look at <tt>LiftRules.snippets</tt>. This is a more fine-grained approach to explicit dispatch that doesn’t require the <tt>DispatchSnippet</tt> trait. Instead, we bind a list of snippet name components corresponding to the parts of the snippet name separated by either “:” or “.”, and point it directly at a given snippet method. Assuming we’re using the same snippet object in Listing <a class="Reference" href="#lst:Defining-an-Explicit-snippet">5.2.2↑</a>, we can bind the <tt>&lt;lift:HelloWorld/&gt;</tt> tag by setting up <tt>LiftRules.snippets</tt> in our Boot.boot method as shown in Listing <a class="Reference" href="#lst:Explicitly-Binding-a-snippet">5.2.2↓</a>. Notice that in order to bind the same way that we did with <tt>snippetDispatch</tt>, we need two lines to match the un-suffixed and suffixed versions. If you omit the un-suffixed line you will get a snippet failure. <div class="listing">
<div class="caption">
Explicitly Binding a Snippet Method<a class="Label" name="lst:Explicitly-Binding-a-snippet"> </a>
</div>
<pre class="listing brush: scala">import com.foo.logic
class Boot {
  def boot {
    ...
    LiftRules.snippets.append {
      // Matches a tag without a suffix (&lt;lift:HelloWorld /&gt;)
      case List("HelloWorld") =&gt; HelloWorld.render("no name") _
      case List("HelloWorld", name) =&gt; HelloWorld.render(name) _
    }
  }
}
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-5.2.3">5.2.3</a> Per-request Remapping<a class="IndexReference" name="entry-Snippets-Per-request-remapping-0" href="#index-Snippets-Per-request-remapping">↓</a>
</h3>
<div class="Unindented">
The final piece of snippet mapping that we want to discuss is per-request remapping. The S.mapSnippet method allows you to modify which snippet method will service a given snippet tag within your page processing. For example, Listing <a class="Reference" href="#lst:Remapping-A-Snippet">5.2.3↓</a> shows how we can conditionally “blank” a snippet based on logic in a second snippet. This functionality isn’t used frequently as the other types of snippet dispatch, but it’s here in case you need it.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Remapping A Snippet<a class="Label" name="lst:Remapping-A-Snippet"> </a>
</div>
<pre class="listing brush: scala">import scala.xml.NodeSeq
import net.liftweb.http.S
​
class Display {
  def header (xhtml : NodeSeq) : NodeSeq = {
    ...
    // If simple is set, we don’t display complexStuff
    S.param("simple").foreach {
      S.mapSnippet("complexStuff", ignore =&gt; Text(""))
    }
  }
​
  def complexStuff (xhtml : NodeSeq) : NodeSeq = {
    ...
  }
}
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-5.3">5.3</a> Snippet Methods<a class="Label" name="sec:Snippets"> </a>
</h2>
<div class="Unindented">
Now that we’ve examined how Lift determines which snippet to execute, let’s look at what a snippet method actually does. A snippet method is essentially a transform, taking a single <tt>scala.xml.NodeSeq</tt><a class="IndexReference" name="entry-NodeSeq-1" href="#index-NodeSeq">↓</a> argument and returning a <tt>NodeSeq</tt>.
</div>
<div class="Indented">
<div class="center">
<div class="Shadowbox" style="width: 75%;">
Note: Although Scala can often infer return types, it’s important to explicitly specify the return type of your snippet methods as <tt>NodeSeq</tt>. Failure to do so may prevent Lift from locating the snippet method if you’re using implicit dispatch (Section <a class="Reference" href="#sub:Implicit-Dispatch-Via">5.2.1↑</a>), in which case the snippet won’t execute!
</div>

</div>

</div>
<div class="Indented">
The argument passed to the snippet method is the XML content of the snippet tag. Because Lift processes XML from the root element down to the child elements (outside-in), the contents of the snippet tag aren’t processed until <i>after</i> the snippet method processes them. You may reverse the order of processing by specifying the <tt>eager_eval</tt> attribute on the tag (Section <a class="Reference" href="#sub:Eager-Eval">5.3.4↓</a>). As an example, let’s say we wanted a snippet that would output the current balance of our ledger, shown in Listing <a class="Reference" href="#lst:Returning-tags-snippet">5.3↓</a>. We simply return an XML Text node with the formatted balance. Note that the XML result from a snippet is itself processed recursively, so the <tt>lift:Util.time</tt> snippet will be processed after our snippet method returns.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Returning Tags from a Snippet<a class="Label" name="lst:Returning-tags-snippet"> </a>
</div>
<pre class="listing brush: scala">class Ledger {
  def balance (content : NodeSeq) : NodeSeq = 
    &lt;p&gt;{currentLedger.formattedBalance}
      as of &lt;lift:Util.time /&gt;&lt;/p&gt;
}
</pre>
</div>

</div>
<div class="Indented">
It is this hierarchical processing of template tags that makes Lift so flexible. For those of you coming to Lift with some JSP experience, Lift is designed to let you write something similar to tag libraries, but that are much more powerful and much simpler to use.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-5.3.1">5.3.1</a> Binding Values in Snippets<a class="Label" name="sub:Binding-Values-in-snippets"> </a><a class="IndexReference" name="entry-Binding-0" href="#index-Binding">↓</a><a class="IndexReference" name="entry-Snippets-binding-0" href="#index-Snippets-binding">↓</a>
</h3>
<div class="Unindented">
So far we’ve shown our snippets generating complete output and ignoring the input to the method. Lift actually provides some very nice facilities for using the input <tt>NodeSeq</tt> within your snippet to help keep presentation and code separate. First, remember that the input <tt>NodeSeq</tt> consists of the child elements for the snippet tag in your template.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Snippet Tag Children<a class="Label" name="lst:Snippet-tag-children"> </a>
</div>
<pre class="listing brush: scala">&lt;lift:Ledger.balance&gt;
  &lt;ledger:balance/&gt; as of &lt;ledger:time /&gt;
&lt;/lift:Ledger.balance&gt;
</pre>
</div>

</div>
<div class="Indented">
For example, given a template containing the snippet tag shown in Listing <a class="Reference" href="#lst:Snippet-tag-children">5.3.1↑</a>, the Ledger.balance method receives
</div>
<pre class="LyX-Code">
&lt;ledger:balance/&gt; as of &lt;ledger:time /&gt;
</pre>
<div class="Unindented">
as its input parameter. This is perfectly correct XML, although it may look a little strange at first unless you’ve used prefixed elements in XML before. The key is that Lift allows you to selectively “bind”, or replace, these elements with data inside your snippet. The <tt>Helpers.bind</tt><span class="FootOuter"><span class="SupFootMarker"> [V] </span><span class="HoverFoot"><span class="SupFootMarker"> [V] </span>net.liftweb.util.Helpers. Technically the bind method is overloaded, and can even fill in values for the lift:bind tag, but this is advanced usage and we’re not going to cover that here.</span></span> method takes three arguments:
</div>
<ol>
<li>
The prefix for the tags you wish to bind, in this instance, “ledger”
</li>
<li>
The <tt>NodeSeq</tt> that contains the tags you wish to bind
</li>
<li>
One or more <tt>BindParam</tt> elements that map the tag name to a replacement value
</li>

</ol>
<div class="Unindented">
While you can create your own <tt>BindParam</tt> instances by hand, we generally recommend importing <tt>Helpers._</tt>, which among other things contains a convenient implicit conversion to BindParam using the “-&gt;” operator. With this knowledge in hand, we can change our previous definition of the balance method in Listing <a class="Reference" href="#lst:Returning-tags-snippet">5.3↑</a> to that in Listing <a class="Reference" href="#lst:Binding-the-ledger-balance">5.3.1↓</a> below.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Binding the Ledger Balance<a class="Label" name="lst:Binding-the-ledger-balance"> </a>
</div>
<pre class="listing brush: scala">class Ledger {
  def balance (content : NodeSeq ) : NodeSeq = 
    bind ("ledger", content,
          "balance" -&gt; Text(currentLedger.formattedBalance),
          "time" -&gt; Text((new java.util.Date).toString))
}
</pre>
</div>

</div>
<div class="Indented">
As you can see here, we actually gain a line of code over our previous effort, but the trade-off makes it far simpler for us to change the layout just by editing the template.
</div>
<div class="Indented">
One last aspect of binding that we want to discuss is that any attributes set on the input elements that are being bound will be discarded<a class="IndexReference" name="entry-Attributes-discarded-in-bind-0" href="#index-Attributes-discarded-in-bind">↓</a> if you use the “-&gt;” binding operator. See Section <a class="Reference" href="#sec:Handling-XHTML-Attributes">5.4↓</a> for more details on how you manipulate attributes in bindings, including how you can retain attributes on binding elements from your templates by using the “-%&gt;”<a class="IndexReference" name="entry-Attributes--%&gt;-operator-0" href="#index-Attributes--%&gt;-operator">↓</a> binding operator instead.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-5.3.2">5.3.2</a> CSS Selector Transforms<a class="Label" name="sub:CSS-Selector-Transforms"> </a><a class="IndexReference" name="entry-CSS-selector-transforms-0" href="#index-CSS-selector-transforms">↓</a><a class="IndexReference" name="entry-Binding-with-CSS-1" href="#index-Binding-with-CSS">↓</a><a class="IndexReference" name="entry-Snippets-binding-with-CSS-0" href="#index-Snippets-binding-with-CSS">↓</a><a class="IndexReference" name="entry-CSS-Transforms-0" href="#index-CSS-Transforms">↓</a>
</h3>
<div class="Unindented">
In addition to the binding support detailed in Section <a class="Reference" href="#sub:Binding-Values-in-snippets">5.3.1↑</a>, Lift 2.2 introduces binding via CSS transforms as part of its support for designer friendly templates. These allow you to bind values into template XHTML (or HTML5, see Section <a class="Reference" href="#sec:HTML5-Support">4.3 on page 1↑</a>) by using the attributes on specific elements. Let’s start by looking at a basic example, corresponding to the examples in Section <a class="Reference" href="#sub:Binding-Values-in-snippets">5.3.1↑</a>.
</div>
<div class="Indented">
Listing <a class="Reference" href="#lst:A-Simple-CSS-snippet">5.3.2↓</a> shows a Designer-Friendly version of Listing <a class="Reference" href="#lst:Snippet-tag-children">5.3.1↑</a>. You can see that we’re invoking the <tt>Ledger.balance</tt> snippet via the class attribute, and we’ve specified the binding elements as normal <tt>&lt;span/&gt;</tt> elements with <tt>id</tt> attributes.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Simple CSS Snippet<a class="Label" name="lst:A-Simple-CSS-snippet"> </a>
</div>
<pre class="listing brush: scala">&lt;div class="lift:Ledger.balance"&gt;
  &lt;span id="balance"&gt;$0&lt;/span&gt; as of &lt;span id="time"&gt;midnight&lt;/span&gt;
&lt;/div&gt;
</pre>
</div>

</div>
<div class="Indented">
Now, we need to perform the CSS transform within our snippet. The binding implicits for CSS transforms are found on the <tt>net.liftweb.util.BindHelpers</tt> object/trait, so you should import it (in particular, the <tt>strToCssBindPromoter</tt> method). Listing <a class="Reference" href="#lst:Binding-the-Ledger-with-CSS">5.3.2↓</a> shows how we modify the snippet in Listing <a class="Reference" href="#lst:Binding-the-ledger-balance">5.3.1↑</a> to utilize the new CSS transform.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Binding the Ledger Balance with CSS<a class="Label" name="lst:Binding-the-Ledger-with-CSS"> </a>
</div>
<pre class="listing brush: scala">import net.liftweb.util.BindHelpers._
​
class Ledger {
  def balance = "#balance" #&gt; currentLedger.formattedBalance &amp;
    "#time" #&gt; (new java.util.Date).toString
}
</pre>
</div>

</div>
<div class="Indented">
As you can see in this example, CSS transforms are comprised of three parts: the transform selector, the transform operator (<tt>#&gt;</tt>), and the right hand side value. This value can be a number of different things, which we’ll cover in Section <a class="Reference" href="#sub:Replacement-Values">5.3.2.2↓</a>, but in our case we’re using a <tt>MappedField</tt> and a <tt>String</tt>. Additionally, you can chain transforms together with the <tt>&amp;</tt> operator.
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-5.3.2.1">5.3.2.1</a> CSS Selector Syntax
</h4>
<div class="Unindented">
The selector syntax is based on a subset of CSS, so if you already know that you’re well on your way. The syntax can operate on elements based on id or class, and can also operate on attributes of those elements. Let’s look at the basic syntax:
</div>
<ul>
<li>
<tt>#foo</tt> - Selects the element with an <tt>id</tt> attribute of “foo”
</li>
<li>
<tt>.foo</tt> - Selects all elements with a CSS <tt>class</tt> of “foo”
</li>
<li>
<tt>@foo</tt> - Selects all elements with a <tt>name</tt> attribute of “foo”
</li>
<li>
<tt>attrName=attrValue</tt> - Selects all elements with an attribute of “attrName” equal to “attrValue”
</li>
<li>
<tt>element</tt> - Selects all “element” elements (e.g. span, h1, etc.)
</li>
<li>
<tt>:type</tt> - Selects all elements with a <tt>type</tt> of “type”. The type must be one of:<ul>
<li>
<tt>button</tt>
</li>
<li>
<tt>checkbox</tt>
</li>
<li>
<tt>file</tt>
</li>
<li>
<tt>password</tt>
</li>
<li>
<tt>radio</tt>
</li>
<li>
<tt>reset</tt>
</li>
<li>
<tt>submit</tt>
</li>
<li>
<tt>text</tt>
</li>

</ul>

</li>
<li>
<tt>*</tt> - Selects all elements
</li>

</ul>
<div class="Unindented">
The element matching the selector is replaced by the result of processing the replacement. That means that in the example of Listing <a class="Reference" href="#lst:A-Simple-CSS-snippet">5.3.2↑</a> the <tt>span</tt> elements will be replaced with straight Text elements, resulting in the markup shown in Listing <a class="Reference" href="#lst:Sample-CSS-Transform-result">5.3.2.1↓</a> (in other words, no remaining markup).
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Sample CSS Transform Result<a class="Label" name="lst:Sample-CSS-Transform-result"> </a>
</div>
<pre class="listing brush: xml">$12.42 as of Fri Jan 14 08:29:50 MST 2011
</pre>
</div>

</div>
<div class="Indented">
You can further refine the replacement with an optional qualifier. We’ve already seen how omitting the qualifer results in wholesale replacement of the matching element, but there are a few additional options:
</div>
<ul>
<li>
<tt>*</tt> - Replaces the children of the selected element. For example, if we changed our selector in Listing <a class="Reference" href="#lst:Binding-the-Ledger-with-CSS">5.3.2↑</a> from <tt>“#balance”</tt> to <tt>“#balance *”</tt>, we would be replacing the text node child (“$0”), with the resulting markup:<pre class="LyX-Code">
&lt;span id="balance"&gt;$12.42&lt;/span&gt; as of Fri Jan 14 08:29:50 MST 2011
</pre>
<div class="Unindented">
Note that when we perform child replacement, the parent’s attributes<a class="IndexReference" name="entry-CSS-Transforms-attribute-copying-0" href="#index-CSS-Transforms-attribute-copying">↓</a> are carried over to the resulting element. There is an exception to this in the case of iterated replacements, which we’ll cover in Section <a class="Reference" href="#sub:Replacement-Values">5.3.2.2↓</a>.
</div>

</li>
<li>
<tt>*+</tt> - Appends to the children of the selected element. For example, given the template<pre class="LyX-Code">
&lt;span id="love"&gt;I love &lt;/span&gt;
</pre>
<div class="Unindented">
The transform
</div>
<pre class="LyX-Code">
"#love *+" #&gt; "figs"
</pre>
<div class="Unindented">
Would result in the markup
</div>
<pre class="LyX-Code">
&lt;span id="love"&gt;I love figs&lt;/span&gt;
</pre>

</li>
<li>
<tt>-*</tt> - Prepends to the children of the selected element. This operates the same as appending.
</li>
<li>
<tt>[name]</tt> - <a class="IndexReference" name="entry-CSS-Transforms-attribute-replacement-0" href="#index-CSS-Transforms-attribute-replacement">↓</a>Sets the value of the <tt>”name”</tt> attribute on the selected element. If the attribute already exists on the selected element, its value is replaced, otherwise the attribute is added. For example, if we wanted to replace both the link text and <tt>href</tt> of a link via CSS transform for the template<pre class="LyX-Code">
&lt;a href="#"&gt;ReplaceMe&lt;/a&gt;
</pre>
<div class="Unindented">
We could perform this by chaining two selections together, one for the child element (link text) and one for the <tt>href</tt> attribute:
</div>
<pre class="LyX-Code">
"a *" #&gt; "This is the link text"&amp; 
  "a [href]" #&gt; "http://foo.com/bar"
</pre>
<div class="Unindented">
Note that the order of the selections is not important.
</div>

</li>
<li>
<tt>[name+]</tt> - Appends a value to the attribute on the selected element. If the attribute doesn’t already exist on the element then this behaves the same as the <tt>[name]</tt> qualifier. One example would be adding to the <tt>class</tt> attribute for a given element:<pre class="LyX-Code">
"tr [class+]" #&gt; (if (index % 2) "odd" else "even")
</pre>

</li>
<li>
<tt>^^</tt> - Makes the selected element the root of the returned elements. This can be used to select a particular element from a template, similar to <tt>BindHelpers.chooseTemplate</tt>. The right hand side for the selected element is ignored, but you can chain further transforms to modify the returned element. For example, if we decided to only output the balance in Listing <a class="Reference" href="#lst:A-Simple-CSS-snippet">5.3.2↑</a>, we could do so by changing our snippet code to:<pre class="LyX-Code">
def balance = "#balance ^^" #&gt; "ignore" &amp;
  "#balance" #&gt; currentLedger.formattedBalance
</pre>

</li>

</ul>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-5.3.2.2">5.3.2.2</a> Right Hand Side Values<a class="Label" name="sub:Replacement-Values"> </a>
</h4>
<div class="Unindented">
The right hand side of a CSS transform operates on the selected element to either transform or replace it. It can be one of:
</div>
<ul>
<li>
<tt>String</tt> constant - returns a Text node for the <tt>String</tt>. For example, in Listing <a class="Reference" href="#lst:Binding-the-Ledger-with-CSS">5.3.2↑</a>:<pre class="LyX-Code">
"#time" #&gt; (new java.util.Date).toString
</pre>

</li>
<li>
A <tt>NodeSeq</tt> constant - returns the <tt>NodeSeq</tt> itself. In Listing <a class="Reference" href="#lst:Binding-the-Ledger-with-CSS">5.3.2↑</a> we could have done this instead:<pre class="LyX-Code">
"#time" #&gt; Text((new java.util.Date).toString)
</pre>

</li>
<li>
<span class="formula"><i>NodeSeq</i> ⇒ <i>NodeSeq</i></span> - a function that transforms the selected element. Note that CSS transforms extend <span class="formula"><i>NodeSeq</i> ⇒ <i>NodeSeq</i></span>, so you can nest transforms like<pre class="LyX-Code">
// Select the element with id "entry" and then bind its 
// nested "name" element
"#entry" #&gt; { "#name" #&gt; account.name }
</pre>

</li>
<li>
<tt>net.liftweb.util.Bindable</tt> - Instances that implement the <tt>Bindable</tt> trait will be automatically converted into a <tt>NodeSeq</tt>. Among other things, <tt>MappedField</tt> and <tt>Record.Field</tt> support this, which allows us to use instances directly:<pre class="LyX-Code">
"#description" #&gt; account.description
</pre>

</li>
<li>
<tt>Boolean</tt>, <tt>Int</tt>, <tt>Long</tt> or <tt>Symbol</tt> - These are automatically promoted to a <tt>String</tt> via the <tt>net.liftweb.util.StringPromotable</tt> trait and implicits on its companion object<pre class="LyX-Code">
"#viewperm" #&gt; account.isViewableBy(someUser)
</pre>

</li>
<li>
A <tt>Box</tt>, <tt>Option</tt> or <tt>Seq</tt> of <tt>String</tt>, <tt>NodeSeq</tt>, <tt>Bindable</tt> or values convertable by <tt>StringPromotable</tt> - These will be converted into a <tt>net.liftweb.util.IterableConst</tt>, which is used to compute a <tt>Seq[NodeSeq]</tt>. If your selector replaces the children of the selected element (*), the <tt>IterableConst</tt> is applied to the selected element once for each item in the <tt>Seq</tt>. In other words, you get a copy of the selected element for each original input. For example, given the template:<pre class="LyX-Code">
&lt;h2&gt;Account names:&lt;/h2&gt;
&lt;ul&gt;
&lt;li id="item"&gt;Account&lt;/li&gt;
&lt;/ul&gt;
</pre>
<div class="Unindented">
We can iterate over a list of accounts with the CSS transform:
</div>
<pre class="LyX-Code">
"#item *" #&gt; accounts.map(_.name.toString)
</pre>
<div class="Unindented">
Which, assuming a set of accounts named “A”, “B”, and “C”, results in:
</div>
<pre class="LyX-Code">
&lt;h2&gt;Account names:&lt;/h2&gt;
&lt;ul&gt;
&lt;li id="item"&gt;A&lt;/li&gt;
  &lt;li&gt;B&lt;/li&gt;
  &lt;li&gt;C&lt;/li&gt;
&lt;/ul&gt;
</pre>
<div class="Unindented">
<div class="center">
<div class="Shadowbox" style="width: 80%;">
Note that the <tt>id</tt> attribute is only placed on the first transformed element. Subsequent replacements strip the <tt>id</tt> attribute so that it remains unique on the page. This special handling applies only to the <tt>id</tt> attribute; other attributes, such as <tt>class</tt>, are not similarly stripped.
</div>

</div>

</div>
<div class="Indented">
Passing in a <tt>None</tt>/<tt>Empty</tt> will remove the selected element. For example, you can delete an attribute<a class="IndexReference" name="entry-CSS-Transforms-deleting-attribute-0" href="#index-CSS-Transforms-deleting-attribute">↓</a><a class="IndexReference" name="entry-Attributes-delete-with-CSS-transform-0" href="#index-Attributes-delete-with-CSS-transform">↓</a> with the following code:
</div>
<pre class="LyX-Code">
val blank: Option[String] = None
"#thing [class]" #&gt; blank
</pre>

</li>
<li>
A <tt>Box</tt>, <tt>Option</tt> or <tt>Seq</tt> of <span class="formula"><i>NodeSeq</i> ⇒ <i>NodeSeq</i></span> - These will be converted into a <tt>net.liftweb.util.IterableFunc</tt>, and follow the same rules for replacement as <tt>IterableConst</tt> (e.g. child replacement repetition).
</li>

</ul>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-5.3.3">5.3.3</a> Stateless versus Stateful Snippets<a class="Label" name="sub:Stateless-versus-Stateful"> </a><a class="IndexReference" name="entry-StatefulSnippet-1" href="#index-StatefulSnippet">↓</a><a class="IndexReference" name="entry-Snippets-stateful-vs-stateless-0" href="#index-Snippets-stateful-vs-stateless">↓</a>
</h3>
<div class="Unindented">
The lifecycle of a snippet is stateless by default. That means that for each request, Lift creates a new instance of the snippet class to execute (or uses the same staic method if using explicit dispatch, Section <a class="Reference" href="#sub:Explicit-Dispatch">5.2.2↑</a>). Any changes you make to instance variables will be discarded after the request is processed. If you want to keep some state around, you have a couple of options:
</div>
<ul>
<li>
Store the state in a cookie<a class="IndexReference" name="entry-cookie-0" href="#index-cookie">↓</a> (Section <a class="Reference" href="#sec:Cookies">3.10↑</a>). This can be useful if you have data that you want to persist across sessions. The down side is that you have to manage the cookie as well as deal with any security implications for the data in the cookie as it’s stored on the user’s machine.
</li>
<li>
Store the state in a <tt>SessionVar</tt><a class="IndexReference" name="entry-SessionVar-0" href="#index-SessionVar">↓</a> (Section <a class="Reference" href="#sec:Session-and-Request">3.11↑</a>). This is a little easier to manage than cookies, but you still have to handle adding and removing the session data if you don’t want it around for the duration of the session. As with a cookie, it is global, which means that it will be the same for all snippet instances for a given session.
</li>
<li>
Pass the state around in a <tt>RequestVar</tt><a class="IndexReference" name="entry-RequestVar-0" href="#index-RequestVar">↓</a> by setting “injector” functions in your page transition functions (e.g. <tt>SHtml.link</tt>, <tt>S.redirectTo</tt>, etc). We cover this technique in Section <a class="Reference" href="#sec:Session-and-Request">3.11↑</a>.
</li>
<li>
Use a <tt>StatefulSnippet</tt><a class="IndexReference" name="entry-StatefulSnippet-2" href="#index-StatefulSnippet">↓</a> subclass. This is ideal for small, conversational state, such as a form that spans multiple pages or for a page where you have multiple variables that you want to be able to tweak individually.
</li>

</ul>
<div class="Unindented">
Using a <tt>StatefulSnippet</tt> is very similar to using a normal snippet but with the addition of a few mechanisms. First, the <tt>State</tt>fulSnippet trait extends <tt>DispatchSnippet</tt> (see Section <a class="Reference" href="#sub:Implicit-Dispatch-Via">5.2.1↑</a>), allowing you to define which methods handle which snippets based on the <tt>dispatch</tt> method. Because Scala allows <tt>def</tt>s to be implemented by <tt>var</tt>s in subclasses, we can redefine the dispatch behavior as a result of snippet processing. 
</div>
<div class="Indented">
Another thing to remember when using <tt>StatefulSnippet</tt>s is that when you render a form, a hidden field is added to the form that permits the same instance of the <tt>StatefulSnippet</tt> that created the form to be the target of the form submission. If you need to link to a different page, but would like the same snippet instance to handle snippets on that page, use the <tt>StatefulSnippet.link</tt> method (instead of <tt>SHtml.link</tt>); similarly, if you need to redirect to a different page, the <tt>StatefulSnippet</tt> trait defines a <tt>redirectTo</tt> method. In either of these instances, a function map is added to the link or redirect, respectively, that causes the instance to be reattached.
</div>
<div class="Indented">
When might you use a stateful snippet? Consider a multi-part form where you’d like to have a user enter data over several pages. You’ll want the application to maintain the previously entered data while you validate the current entry, but you don’t want to have to deal with a lot of hidden form variables. Using a <tt>StatefulSnippet</tt> instance greatly simplifies writing the snippet because you can keep all of your pertinent information around as instance variables instead of having to insert and extract them from every request, link, etc.
</div>
<div class="Indented">
Listing <a class="Reference" href="#lst:Using-a-StatefulSnippet">5.3.3↓</a> shows an example of a stateful snippet that handles the above example. Note that for this example, the URL (and therefore, the template) don’t change between pages. The template we use is shown in Listing <a class="Reference" href="#lst:The-StatefulSnippet-Example">5.3.3↓</a>. Remember to call <tt>unregisterThisSnippet()</tt> when you’re finished with your workflow in order to stop the current instance from being used.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using a StatefulSnippet<a class="Label" name="lst:Using-a-StatefulSnippet"> </a>
</div>
<pre class="listing brush: scala">... standard Lift imports ...
import scala.xml.Text
​
class BridgeKeeper extends StatefulSnippet {
  // Define the dispatch for snippets. Note that we are defining
  // it as a var so that the snippet for each portion of the 
  // multi-part form can update it after validation.
  var dispatch : DispatchIt = {
    // We default to dispatching the "challenge" snippet to our
    // namePage snippet method. We’ll update this below
    case "challenge" =&gt; firstPage _
  }
​
  // Define our state variables:
  var (name,quest,color) = ("","","")
​
  // Our first form page
  def firstPage (xhtml : NodeSeq) : NodeSeq = {
    def processName (nm : String) {
      name = nm
      if (name != "") {
        dispatch = { case "challenge" =&gt; questPage _ }
      } else {
        S.error("You must provide a name!")
      }
    }
    bind("form", xhtml,
         "question" -&gt; Text("What is your name?"),
         "answer" -&gt; SHtml.text(name, processName))
  }
​
  def questPage (xhtml : NodeSeq) : NodeSeq = {
    def processQuest (qst : String) {
      quest = qst
      if (quest != "") {
        dispatch = { 
          case "challenge" if name == "Arthur" =&gt; swallowPage _
          case "challenge" =&gt; colorPage _ 
        }
      } else {
        S.error("You must provide a quest!")
      }
    }
    bind("form", xhtml,
         "question" -&gt; Text("What is your quest?"),
         "answer" -&gt; SHtml.text(quest, processQuest))
  }
​
  def colorPage (xhtml : NodeSeq) : NodeSeq = {
    def processColor (clr : String) {
      color = clr
      if (color.toLowercase.contains "No,") {
        // This is a cleanup that removes the mapping for this
        // StatefulSnippet from the session. This will happen 
        // over time with GC, but it’s best practice to manually 
        // do this when you’re finished with the snippet
        this.unregisterThisSnippet()
        S.redirectTo("/pitOfEternalPeril")
      } else if (color != "") {
        this.unregisterThisSnippet()
        S.redirectTo("/scene24")
      } else {
        S.error("You must provide a color!")
      }
    }
    bind("form", xhtml,
         "question" -&gt; Text("What is your favorite color?"),
         "answer" -&gt; SHtml.text(color, processColor))
  }
  // and so on for the swallowPage snippet
  ...
}
</pre>
</div>

</div>
<div class="Indented">
<div class="listing">
<div class="caption">
The StatefulSnippet Example Template<a class="Label" name="lst:The-StatefulSnippet-Example"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:surround with="default" at="content"&gt;
  &lt;lift:BridgeKeeper.challenge form="POST"&gt;
    &lt;form:question /&gt; : &lt;form:answer /&gt; &lt;br /&gt;
    &lt;input type="submit" value="Answer" /&gt;
  &lt;/lift:BridgeKeeper.challenge&gt;
&lt;/lift:surround&gt;
</pre>
</div>

</div>
<div class="Indented">
If you’re using implicit dispatch (Section <a class="Reference" href="#sub:Implicit-Dispatch-Via">5.2.1↑</a>), then you’re done. If you want to use explicit dispatch<a class="IndexReference" name="entry-Snippets-explicit-dispatch-with-StatefulSnippet-0" href="#index-Snippets-explicit-dispatch-with-StatefulSnippet">↓</a><a class="IndexReference" name="entry-StatefulSnippet-explicit-dispatch-0" href="#index-StatefulSnippet-explicit-dispatch">↓</a>, however, you need to do a little more work than usual in the <tt>LiftRules.snippetDispatch</tt> setup. Listing <a class="Reference" href="#lst:Explicit-Dispatch-with-stateful">5.3.3↓</a> shows how we can bind our own StatefulSnippet classes without using reflection. 
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Explicit Dispatch with Stateful Snippets<a class="Label" name="lst:Explicit-Dispatch-with-stateful"> </a>
</div>
<pre class="listing brush: scala">// In your boot method:
LiftRules.snippetDispatch.append {
  // S.snippetForClass checks to see if an instance has already
  // registered. This is the case after form submission or when
  // we use the StatefulSnippet.link or .redirectTo methods
  case "BridgeKeeper" =&gt; S.snippetForClass("TestHello") openOr {
    // If we haven’t already registered an instance, create one
    val inst = new com.test.TestHello
    // The name is what Lift uses to locate an instance (S.snippetForClass)
    // We need to add it so that the Stateful callback functions can
    // self-register
    inst.addName("TestHello")
    // Register this instance for the duration of the request
    S.overrideSnippetForClass("TestHello", inst)
    inst
  }
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-5.3.4">5.3.4</a> Eager Evaluation<a class="Label" name="sub:Eager-Eval"> </a>
</h3>
<div class="Unindented">
As we mentioned in Section <a class="Reference" href="#sec:Snippets">5.3↑</a>, Lift processes the contents of a snippet tag after it processes the tag itself. If you want the contents of a snippet tag to be processed <i>before</i> the snippet, then you need to specify the <tt>eager_eval</tt><a class="IndexReference" name="entry-eager-eval-0" href="#index-eager-eval">↓</a> attribute on the tag:
</div>
<pre class="LyX-Code">
&lt;lift:Hello.world eager_eval=”true”&gt;...&lt;/lift:Hello.world&gt;
</pre>
<div class="Unindented">
This is especially useful if you’re using an embedded<a class="IndexReference" name="entry-embed-1" href="#index-embed">↓</a><a class="IndexReference" name="entry-Templates-embedded-0" href="#index-Templates-embedded">↓</a><a class="IndexReference" name="entry-Tags-embed-1" href="#index-Tags-embed">↓</a> template (Section <a class="Reference" href="#sub:embed-tag">4.5.7↑</a>). Consider Listing <a class="Reference" href="#lst:Embedding-and-eager">5.3.4↓</a>: in this case, the <tt>eager_eval</tt> parameter makes Lift process the <tt>&lt;lift:embed /&gt;</tt> tag before it executes the <tt>Hello.world</tt> snippet method. If the “formTemplate” template looks like Listing <a class="Reference" href="#lst:The-formTemplate-template">5.3.4↓</a>, then the <tt>Hello.world</tt> snippet sees the <tt>&lt;hello:name /&gt;</tt> and <tt>&lt;hello:time /&gt;</tt> XML tags as its <tt>NodeSeq</tt> input. If the <tt>eager_eval</tt> attribute is removed, however, the Hello.world snippet sees only a <tt>&lt;lift:embed /&gt;</tt> tag that will be processed after it returns.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Embedding and eager evaluation<a class="Label" name="lst:Embedding-and-eager"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:Hello.world eager_eval="true"&gt;
  &lt;lift:embed what="formTemplate" /&gt;
&lt;/lift:Hello.world&gt;
</pre>
</div>

</div>
<div class="Indented">
<div class="listing">
<div class="caption">
The formTemplate template<a class="Label" name="lst:The-formTemplate-template"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:children&gt;
&lt;hello:name /&gt;
&lt;hello:time /&gt;
&lt;/lift:children&gt;
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-5.4">5.4</a> <a class="Label" name="sec:Handling-XHTML-Attributes"> </a>Handling XHTML Attributes in Snippets<a class="IndexReference" name="entry-Attributes-0" href="#index-Attributes">↓</a><a class="IndexReference" name="entry-XML-attribute-handling-0" href="#index-XML-attribute-handling">↓</a>
</h2>
<div class="Unindented">
It’s a common requirement that elements contain XHTML attributes to control things like style, provide an id, register javascript event handlers, and other functionality. Lift provides two main approaches to applying attributes to elements either in your snippet code or directly in the XHTML template.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-5.4.1">5.4.1</a> <a class="Label" name="sub:Direct-attr-manip"> </a>Direct Manipulation in Code
</h3>
<div class="Unindented">
You can apply attributes directly to XHTML elements using the “%” operator<a class="IndexReference" name="entry-Attributes-%-operator-0" href="#index-Attributes-%-operator">↓</a> to apply a<br/>
<tt>scala.xml.UnprefixedAttribute</tt> instance<span class="FootOuter"><span class="SupFootMarker"> [W] </span><span class="HoverFoot"><span class="SupFootMarker"> [W] </span>there’s a corresponding <tt>PrefixedAttribute</tt> as well</span></span> to an element. Lift’s <tt>net.liftweb.util.Helpers</tt> trait contains an implicit conversion from a <tt>Pair[String,_]</tt> to an <tt>UnprefixedAttribute</tt> called <tt>pairToUnprefixed</tt> that allows you to use a simpler syntax. You may chain invocations of “%” to apply multiple attributes. For example, Listing <a class="Reference" href="#lst:Applying-Attributes-percent">5.4.1↓</a> shows how you can apply an “id” and “class” attribute to a text box and to a normal paragraph.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:Applying-Attributes-percent"> </a>Applying Attributes with <tt>%</tt>
</div>
<pre class="listing brush: scala">val myInput = SHtml.text("", processText(_)) % ("id" -&gt; "inputField") % 
  ("class" -&gt; "highlighted")
</pre>
</div>

</div>
<div class="Indented">
<div class="center">
<div class="Shadowbox" style="width: 75%;">
Note that the % metadata mechanism is actually part of the Scala XML library. Specifically, <tt>scala.xml.Elem</tt> has a <tt>%</tt> method that allows the user to update the attributes on a given XML element by passing in a <tt>scala.xml.UnprefixedAttribute</tt>. We suggest reading more about this in the Scala API documents, or in the Scala XML docbook at <a class="URL" href="http://burak.emir.googlepages.com/scalaxbook.docbk.html">http://burak.emir.googlepages.com/scalaxbook.docbk.html</a>. 
</div>

</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-5.4.2">5.4.2</a> <a class="Label" name="sub:XHTML-Attribute-Pass-through"> </a>XHTML Attribute Pass-through<a class="IndexReference" name="entry-Attributes-binding-0" href="#index-Attributes-binding">↓</a><a class="IndexReference" name="entry-XML-preserving-attributes-0" href="#index-XML-preserving-attributes">↓</a>
</h3>
<div class="Unindented">
The second main approach to modifying XHTML attributes is to specify them directly in your templates. This has the benefit of allowing your template designers to directly manipulate things like style-related attributes and keeping the markup and the logic separate. Listing <a class="Reference" href="#lst:Snippet-mixin-attributes">5.4.2↓</a> shows how you can utilize the “-%&gt;”<a class="IndexReference" name="entry-Attributes--%&gt;-operator-1" href="#index-Attributes--%&gt;-operator">↓</a> binding operator instead of “-&gt;” to preserve attributes.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Snippet mixin attributes <a class="Label" name="lst:Snippet-mixin-attributes"> </a>
</div>
<pre class="listing brush: scala">// the markup
&lt;lift:Ledger.balance&gt;
  &lt;ledger:time id="myId"/&gt;
&lt;/lift:Ledger.balance&gt;
​
// The snippet class
​
class Ledger {
  def balance (content : NodeSeq ) : NodeSeq = {
    bind ("ledger", content,
          "time" -%&gt; &lt;span&gt;{(new java.util.Date).toString}&lt;/span&gt;)
  }
}
</pre>
</div>

</div>
<div class="Indented">
The resulting node will be something like
</div>
<pre class="LyX-Code">
<tt>&lt;span id=”myId”&gt;Sat Mar 28 16:43:48 EET 2009&lt;/span&gt;</tt>
</pre>
<div class="Unindented">
In addition to the “-%&gt;” binding operator, there is also the “_id_&gt;” <a class="IndexReference" name="entry-_id_&gt;-operator-0" href="#index-_id_&gt;-operator">↓</a>operator, which uses the element’s name as its “id” attribute. Listing shows a snippet method using the “_id_&gt;” attribute and Listing shows the resulting markup.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:Binding-with-the_id_"> </a>Binding with the _id_&gt; operator
</div>
<pre class="listing brush: scala">def idByName (xhtml : NodeSeq) : NodeSeq = 
  bind("example", xhtml, "name" _id_&gt; &lt;span&gt;Fred&lt;/span&gt;)
</pre>
</div>

</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:Markup-bound-using_id_"> </a>Markup bound using _id_&gt;
</div>
<pre class="listing brush: xml">&lt;!-- Input: --&gt;
&lt;lift:HelloWorld.idByName&gt;
  Hi, &lt;example:name /&gt; 
&lt;/lift:HelloWorld.idByName&gt;
​
&lt;!-- Output: --&gt;
Hi, &lt;span id="name"&gt;Fred&lt;/span&gt; 
</pre>
</div>

</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-6">6</a> Forms in Lift<a class="Label" name="cha:Forms-in-Lift"> </a>
</h1>
<div class="Unindented">
In this chapter we’re going to discuss the specifics of how you generate and process forms with Lift. Besides standard GET/POST form processing, Lift provides AJAX forms (Chapter <a class="Reference" href="#cha:AJAX-and-COMET">11↓</a>) as well as JSON form processing (Section <a class="Reference" href="#sub:JSON-forms">10.4.1↓</a>), but we’re going to focus on the standard stuff here. We’re going to assume that you have a general knowledge of basic HTML form tags as well as how CGI<a class="IndexReference" name="entry-CGI-0" href="#index-CGI">↓</a> form processing works.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6.1">6.1</a> Form Fundamentals<a class="Label" name="sec:Form-Fundamentals"> </a>
</h2>
<div class="Unindented">
Let’s start with the basics of Lift form processing. A form in Lift is usually produced via a snippet that contains the additional <tt>form</tt> attribute. As we mentioned in Section <a class="Reference" href="#sub:snippet-tag">5.1↑</a>, this attribute takes the value GET or POST, and when present makes the snippet code embed the proper form tags around the snippet HTML. Listing <a class="Reference" href="#lst:An-example-form-template">6.1↓</a> shows an example of a form that we will be discussing throughout this section.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
An Example Form Template<a class="Label" name="lst:An-example-form-template"> </a>
</div>
<pre class="listing brush: scala">&lt;lift:Ledger.add form="POST"&gt;
  &lt;entry:description /&gt; &lt;entry:amount /&gt;&lt;br /&gt;
  &lt;entry:submit /&gt;
&lt;/lift:Ledger.add&gt;
</pre>
</div>

</div>
<div class="Indented">
The first thing to understand about Lift’s form support is that you generally don’t use the HTML tags for form elements directly, but rather you use generator functions on<br/>
 <tt>net.liftweb.http.SHtml</tt>. The main reason for this is that it allows Lift to set up all of the internal plumbing so that you keep your code simple. Additionally, we use Lift’s binding mechanism (Section <a class="Reference" href="#sub:Binding-Values-in-snippets">5.3.1↑</a>) to “attach” the form elements in the proper location. In our example in Listing <a class="Reference" href="#lst:An-example-form-template">6.1↑</a>, we have bindings for a description field, an amount, and a submit button.
</div>
<div class="Indented">
Our next step is to define the form snippet itself. Corresponding to our example template is Listing <a class="Reference" href="#lst:An-example-form-snippet">6.1↓</a>. This shows our add method with a few vars to hold the form data and a binding to the proper form elements. We’ll cover the <tt>processEntryAdd</tt> method in a moment; for now let’s look at what we have inside the add method.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
An Example Form Snippet<a class="Label" name="lst:An-example-form-snippet"> </a>
</div>
<pre class="listing brush: scala">def add (xhtml : NodeSeq) : NodeSeq = {
  var desc = ""
  var amount = "0"
​
  def processEntryAdd () { ... }
​
  bind("entry", xhtml,
       "description" -&gt; SHtml.text(desc, desc = _),
       "amount" -&gt; SHtml.text(amount, amount = _),
       "submit" -&gt; SHtml.submit("Add", processEntryAdd))
}
</pre>
</div>

</div>
<div class="Indented">
First, you may be wondering why we use vars defined inside the method. Normally, these vars would be locally scoped (stack-based) and would be discarded as soon as the method returns. The beauty of Scala and Lift is that the right hand argument of each of the SHtml functions is actually a function itself. Because these functions, also known as anonymous closures<a class="IndexReference" name="entry-closure-0" href="#index-closure">↓</a>, reference variables in local scope, Scala magically transforms them to heap variables behind the scenes. Lift, in turn, adds the function callbacks for each form element into its session state so that when the form is submitted, the appropriate closure is called and the state is updated. This is also why we define the <tt>processEntryAdd</tt> function inside of the <tt>add</tt> method: by doing so, the <tt>processEntryAdd</tt> function <i>also</i> has access to the closure variables. In our example, we’re using Scala’s placeholder “_” shorthand<span class="FootOuter"><span class="SupFootMarker"> [X] </span><span class="HoverFoot"><span class="SupFootMarker"> [X] </span>For more details on placeholders, see the <i>Scala Language Specification</i>, section 6.23</span></span> to define our functions. Your description processing function could also be defined as:
</div>
<pre class="LyX-Code">
newDesc =&gt; description = newDesc
</pre>
<div class="Unindented">
One important thing to remember, however, is that each new invocation of the add method (for each page view) will get its own unique instance of the variables that we’ve defined. That means that if you want to retain values between submission and re-rendering of the form, you’ll want to use <tt>RequestVar</tt>s (Section <a class="Reference" href="#sec:Session-and-Request">3.11↑</a>) or a <tt>StatefulSnippet</tt> (Section <a class="Reference" href="#sub:Stateless-versus-Stateful">5.3.3↑</a>) instead . Generally you will only use vars defined within the snippet method when your form doesn’t require validation and you don’t need any of the submitted data between snippet executions. An example of using <tt>RequestVar</tt>s for your form data would be if you want to do form validation and retain submitted values if validation fails, as shown in Listing <a class="Reference" href="#lst:Using-RequestVars-with-forms">6.1↓</a>. In this instance, we set an error message (more in Chapter <a class="Reference" href="#cha:Message-Handling">B↓</a>). Since we don’t explicitly redirect, the same page is loaded (the default “action” for a page in Lift is the page itself) and the current RequestVar value of description is used as the default value of the text box.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using RequestVars with Forms<a class="Label" name="lst:Using-RequestVars-with-forms"> </a>
</div>
<pre class="listing brush: scala">object description extends RequestVar("")
object amount extends RequestVar("0")
​
def add (xhtml : NodeSeq) : NodeSeq = {
  def processEntryAdd () =
    if (amount.toDouble &lt;= 0) {
      S.error("Invalid amount")
    } else {
      // ... process Add ...
      redirectTo(...)
    }
​
  bind("entry", xhtml,
       "description" -&gt; SHtml.text(description.is, description(_)),
  ...
}
</pre>
</div>

</div>
<div class="Indented">
The next thing to look at is how the form elements are generated. We use the SHtml helper object to generate a form element of the appropriate type for each variable. In our case, we just want text fields for the description and amount, but SHtml provides a number of other form element types that we’ll be covering later in this section. Generally, an element generator takes an argument for the initial value as well as a function to process the submitted value. Usually both of these arguments will use a variable, but there’s nothing stopping you from doing something such as
</div>
<pre class="LyX-Code">
“description” -&gt; SHtml.text(“”, println(“Description = “ + _))
</pre>
<div class="Unindented">
Finally, our submit function executes the partially applied <tt>processEntryAdd</tt> function, which, having access to the variables we’ve defined, can do whatever it needs to do when the submit button is pressed. 
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6.2">6.2</a> <a class="Label" name="sec:Attributes-for-Form-Elems"> </a>Attributes for Form Elements<a class="IndexReference" name="entry-Attributes-in-form-elements-0" href="#index-Attributes-in-form-elements">↓</a>
</h2>
<div class="Unindented">
In addition to the approaches shown in Section <a class="Reference" href="#sec:Handling-XHTML-Attributes">5.4↑</a>, the SHtml generator functions allow you to apply attributes by passing the attribute name/value pairs as final arguments. This is usually simpler, and in some cases is much simpler than using the “%” operator directly. For example, checkbox and radio form elements are acutally returned as ChoiceHolder instances, which do not directly support the “%” operator. Listing <a class="Reference" href="#lst:Applying-Attributes-vararg">6.2↓</a> shows how to apply the same attributes as Listing <a class="Reference" href="#lst:Applying-Attributes-percent">5.4.1↑</a> using the varargs approach.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:Applying-Attributes-vararg"> </a>Applying Attributes as Varargs
</div>
<pre class="listing brush: scala">val myInput = SHtml.text("", processText(_), "id" -&gt; "inputField",
  "class" -&gt; "highlighted")
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6.3">6.3</a> An Overview of Form Elements
</h2>
<div class="Unindented">
Now that we’ve covered the basics of forms, we’re going to go into a little more detail for each form element generator method on SHtml. The <tt>a</tt> method (all 3 variants) as well as the <tt>ajax</tt>* methods are specific to AJAX forms, which are covered in detail in Chapter <a class="Reference" href="#cha:AJAX-and-COMET">11↓</a>. The <tt>json*</tt> methods are covered in Section <a class="Reference" href="#sub:JSON-forms">10.4.1↓</a>. We’ll be covering the fileUpload method in detail in Section <a class="Reference" href="#sec:File-Uploads">6.4↓</a>. One final note before we dive in is that most generator methods have an overload with a trailing asterisk (i.e. <tt>hidden_*</tt>); these are generally equivalent to the overloads without an asterisk but are intended for Lift’s internal use.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.3.1">6.3.1</a> checkbox
</h3>
<div class="Unindented">
The <tt>checkbox</tt> method generates a checkbox form element, taking an initial Boolean value as well as a function <span class="formula">(<i>Boolean</i>) ⇒ <i>Any</i></span> that is called when the checkbox is submitted. If you’ve done a lot of HTML form processing you might wonder how this actually occurs, since <i>an unchecked checkbox is not actually submitted as part of a form</i>. Lift works around this by adding a hidden form element for each checkbox with the same element name, but with a false value, to ensure that the callback function is always called. Because more than one XML node is returned by the generator, you can’t use the % metadata mechanism to set attributes on the check box element. Instead, use attribute pairs as arguments to the generator function as outlined in Section <a class="Reference" href="#sub:Direct-attr-manip">5.4.1↑</a>.
</div>
<div class="Indented">
For example, Listing <a class="Reference" href="#lst:A-checkbox-example">6.3.1↓</a> shows a checkbox with an id of “snazzy” and a class attribute set to “woohoo.”
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Checkbox Example<a class="Label" name="lst:A-checkbox-example"> </a>
</div>
<pre class="listing brush: scala">SHtml.checkbox_id(false, if (_) frobnicate(), 
                  Full("snazzy"), "class" -&gt; "woohoo")
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.3.2">6.3.2</a> hidden
</h3>
<div class="Unindented">
The <tt>hidden</tt> method generates a hidden form field. Unlike the HTML hidden field, the hidden tag is not intended to hold a plain value; rather, in Lift it takes a function <span class="formula">() ⇒ <i>Any</i></span> argument that is called when the form is submitted. As with most of the other generators, it also takes a final varargs sequence of <tt>Pair[String,String]</tt> attributes to be added to the XML node. Listing <a class="Reference" href="#lst:A-hidden-example">6.3.2↓</a> shows an example of using a hidden field to “log” information. (When the form is submitted, “Form was submitted” will be printed to stdout. This can be a useful trick for debugging if you’re not using a full-blown IDE.)
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Hidden Example<a class="Label" name="lst:A-hidden-example"> </a>
</div>
<pre class="listing brush: scala">SHtml.hidden(() =&gt; println("Form was submitted"))
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.3.3">6.3.3</a> link
</h3>
<div class="Unindented">
The link method generates a standard HTML link to a page (an <tt>&lt;a&gt;</tt> tag, or anchor<a class="IndexReference" name="entry-anchor-0" href="#index-anchor">↓</a>), but also ensures that a given function is executed when the link is clicked. The first argument is the web context relative link path, the second argument is the <span class="formula">() ⇒ <i>Any</i></span> function that will be executed when the link is clicked, and the third argument is a NodeSeq that will make up the body of the link. You may optionally pass one or more <tt>Pair[String,String]</tt> attributes to be added to the link element. Listing <a class="Reference" href="#lst:A-link-example">6.3.3↓</a> shows using a link to load an <tt>Expense</tt> entry for editing from within a table. In this case we’re using a <tt>RequestVar</tt> to hold the entry to edit, so the link function is a closure that loads the current <tt>Expense</tt> entry. This combination of link and <tt>RequestVar</tt>s is a common pattern for passing objects between different pages.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Link Example<a class="Label" name="lst:A-link-example"> </a>
</div>
<pre class="listing brush: scala">object currentExpense extends RequestVar[Box[Expense]](Empty)
​
def list (xhtml : NodeSeq) : NodeSeq = {
  ...
  val entriesXml = 
    entries.map(entry =&gt; 
      bind("entry", chooseTemplate("expense", "entries", xhtml),
        ...
        "edit" -&gt; SHtml.link("/editExpense", 
          () =&gt; currentExpense(Full(entry)),
          Text("Edit")))
  )
}
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.3.4">6.3.4</a> text and password
</h3>
<div class="Unindented">
The text and password methods generate standard <tt>text</tt> and <tt>password</tt> <tt>input</tt> fields, respectively. While both take string default values and <span class="formula">(<i>String</i>) ⇒ <i>Any</i></span> functions to process the return, the password text field masks typed characters and doesn’t allow copying the value from the box on the client side. Listing <a class="Reference" href="#lst:A-text-field">6.3.4↓</a> shows an example of using both text and password for a login page.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Text Field Example<a class="Label" name="lst:A-text-field"> </a>
</div>
<pre class="listing brush: scala">def login(xhtml : NodeSeq) : NodeSeq = {
  var user = ""; var pass = "";
  def auth () = { ... }
  bind("login", xhtml,
       "user" -&gt; SHtml.text(user, user = _, "maxlength" -&gt; "40")
       "pass" -&gt; SHtml.password(pass, pass = _)
       "submit" -&gt; SHtml.submit("Login", auth))
}
</pre>
</div>

</div>
<div class="Indented">
Alternatively, you might want the user (but not the password) to be stored in a <tt>RequestVar</tt> so that if the authentication fails the user doesn’t have to retype it. Listing <a class="Reference" href="#lst:A-RV-text-field">6.3.4↓</a> shows how the snippet would look in this case.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A RequestVar Text Field Example<a class="Label" name="lst:A-RV-text-field"> </a>
</div>
<pre class="listing brush: scala">object user extends RequestVar[String]("")
def login(xhtml : NodeSeq) : NodeSeq = {
  var pass = "";
  def auth () = { ... }
  bind("login", xhtml,
       "user" -&gt; SHtml.text(user.is, user(_), "maxlength" -&gt; "40"),
       "pass" -&gt; SHtml.password(pass, pass = _),
       "submit" -&gt; SHtml.submit("Login", auth))
}
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.3.5">6.3.5</a> textarea
</h3>
<div class="Unindented">
The textarea method generates a <tt>textarea</tt> HTML form element. Generally the functionality mirrors that of <tt>text</tt>, although because it’s a <tt>textarea</tt>, you can control width and height by adding <tt>cols</tt> and <tt>rows</tt> attributes as shown in Listing <a class="Reference" href="#lst:A-textarea-example">6.3.5↓</a>. (You can, of course, add any other HTML attributes in the same manner.)
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Textarea Example<a class="Label" name="lst:A-textarea-example"> </a>
</div>
<pre class="listing brush: scala">var noteText = ""
val notes = 
  SHtml.textarea(noteText, noteText = _, 
                 "cols" -&gt; "80", "rows" -&gt; "8")
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.3.6">6.3.6</a> submit
</h3>
<div class="Unindented">
Submit generates the submit form element (typically a button). It requires two parameters: a String value to use as the button label, and a function <span class="formula">() ⇒ <i>Any</i></span> that can be used to process your form results. One important thing to note about submit is that form elements are processed in the order that they appear in the HTML document. This means that you should put your submit element last in your forms: any items after the submit element won’t have been “set” by the time the submit function is called. Listings <a class="Reference" href="#lst:A-text-field">6.3.4↑</a> and <a class="Reference" href="#lst:A-RV-text-field">6.3.4↑</a> use the <tt>SHtml.submit</tt> method for the authentication handler invocation.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.3.7">6.3.7</a> multiselect
</h3>
<div class="Unindented">
Up to this point we’ve covered some fairly simple form elements. Multiselect is a bit more complex in that it doesn’t just process single values. Instead, it allows you to select multiple elements out of an initial Seq and then process each selected element individually. Listing <a class="Reference" href="#lst:Using-multiselect">6.3.7↓</a> shows using a multiselect to allow the user to select multiple categories for a ledger entry. We assume that a Category entity has an id synthetic key as well as a String name value. The first thing we do is map the collection of all categories into pairs of (<tt>value</tt>, <tt>display</tt>) strings. The value is what will be returned to our processing function, while the display string is what will be shown in the select box for the user. Next, we turn the current entry’s categories into a Seq of just value strings, and we create a Set variable to hold the returned values. Finally, we do our form binding. In this example we use a helper function, <tt>loadCategory</tt> (not defined here), that takes a String representing a Category’s primary key and returns the category. We then use this helper method to update the Set that we created earlier. Note that the callback function will be executed <i>for each selected item</i> in the multiselect, which is why the callback takes a String argument instead of a <tt>Set[String]</tt>. This is also why we have to use our own set to manage the values. Depending on your use case, you may or may not need to store the returned values in a collection.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using multiselect<a class="Label" name="lst:Using-multiselect"> </a>
</div>
<pre class="listing brush: scala">def mySnippet ... {
  val possible = allCategories.map(c =&gt; (c.id.toString, c.name))
  val current = currentEntry.categories.map(c =&gt; c.id.toString)
  var updated = Set.empty[Category]
  bind (..., 
    "categories" -&gt; 
      SHtml.multiselect(possible, current, updated += loadCategory(_)))
}
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.3.8">6.3.8</a> radio
</h3>
<div class="Unindented">
The radio method generates a set of radio buttons that take String values and return a single String (the selected button) on form submission. The values are used as labels for the Radio buttons, so you may need to set up a <tt>Map</tt> to translate back into useful values. The radio method also takes a Box[String] that can be used to pre-select one of the buttons. The value of the Box must match one of the option values, or if you pass Empty no buttons will be selected. Listing <a class="Reference" href="#lst:Using-radio-for">6.3.8↓</a> shows an example of using radio to select a color. In this example, we use a <tt>Map</tt> from color names to the actual color values for the translation. To minimize errors, we use the <tt>keys</tt> property of the Map to generate the list of options. 
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using radio for Colors<a class="Label" name="lst:Using-radio-for"> </a>
</div>
<pre class="listing brush: scala">import java.awt.Color
var myColor : Color = _
val colorMap = Map("Red" -&gt; Color.red,
                   "White" -&gt; Color.white,
                   "Blue" -&gt; Color.blue)
val colors = SHtml.radio(colorMap.keys.toList, Empty, myColor = colorMap(_))
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.3.9">6.3.9</a> select
</h3>
<div class="Unindented">
The select method is very similar to the multiselect method except that only one item may be selected from the list of options. That also means that the default option is a <tt>Box[String]</tt> instead of a <tt>Seq[String]</tt>. As with <tt>multiselect</tt>, you pass a sequence of (value, display) pairs as the options for the select, and process the return with a <span class="formula">(<i>String</i>) ⇒ <i>Any</i></span> function. Listing <a class="Reference" href="#lst:A-select-example">6.3.9↓</a> shows an example of using a select to choose an account to view. 
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A select Example<a class="Label" name="lst:A-select-example"> </a>
</div>
<pre class="listing brush: scala">var selectedAccount : Account = _
val accounts = User.accounts.map(acc =&gt; (acc.id.toString, acc.name))
val chooseAccount = 
  SHtml.select(accounts, Empty, 
               selectedAccount = loadAccount(_), "class" -&gt; "myselect")
</pre>
</div>

</div>
<div class="Indented">
An important thing to note is that Lift will verify that the value submitted in the form matches one of the options that was passed in. If you need to do dynamic updating of the list, then you’ll need to use <tt>untrustedSelect</tt> (Section <a class="Reference" href="#sub:untrustedSelect">6.3.11↓</a>).
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.3.10">6.3.10</a> selectObj
</h3>
<div class="Unindented">
One of the drawbacks with the select and multiselect generators is that they deal only in Strings; if you want to select objects you need to provide your own code for mapping from the strings. The <tt>selectObj</tt> generator method handles all of this for you. Instead of passing a sequence of (value string, display string) pairs, you pass in a sequence of (object, display string) pairs. Similarly, the default value is a <tt>Box[T]</tt> and the callback function is <span class="formula">(<i>T</i>) ⇒ <i>Any</i></span> , where T is the type of the object (<tt>selectObj</tt> is a generic function). Listing <a class="Reference" href="#lst:Using-selectObj-for">6.3.10↓</a> shows a reworking of our radio example (Listing <a class="Reference" href="#lst:Using-radio-for">6.3.8↑</a>) to select Colors directly. Note that we set the select to default to <tt>Color.red</tt> by passing in a <tt>Full</tt> Box.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using selectObj for Colors<a class="Label" name="lst:Using-selectObj-for"> </a>
</div>
<pre class="listing brush: scala">... standard Lift imports ...
import _root_.java.awt.Color
​
class SelectSnippet {
  def chooseColor (xhtml : NodeSeq) : NodeSeq = {
    var myColor = Color.red
    val options = List(Color.red, Color.white, Color.blue)
    val colors = SHtml.selectObj(options, Full(myColor), myColor = _)
    bind(...)
  }
}
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.3.11">6.3.11</a> untrustedSelect<a class="Label" name="sub:untrustedSelect"> </a>
</h3>
<div class="Unindented">
The <tt>untrustedSelect</tt> generator is essentially the same as the select generator, except that the value returned in the form isn’t validated against the original option sequence. This can be useful if you want to update the selection on the client side using JavaScript.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6.4">6.4</a> File Uploads<a class="Label" name="sec:File-Uploads"> </a><a class="IndexReference" name="entry-File-uploads-0" href="#index-File-uploads">↓</a><a class="IndexReference" name="entry-Forms-File-uploads-0" href="#index-Forms-File-uploads">↓</a>
</h2>
<div class="Unindented">
File uploads are a special case of form submission that allow the client to send a local file to the server. This is accomplished by using multipart forms. You can enable this by setting the <tt>multipart</tt> attribute on your snippet tag to <tt>true</tt>. Listing <a class="Reference" href="#lst:File-upload-template">6.4↓</a> shows how we can add a file upload to our existing expense entry form so that users can attach scanned receipts to their expenses. We modify our template to add a new form, shown below. Note the <tt>multipart=”true” </tt>attribute.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
File Upload Template<a class="Label" name="lst:File-upload-template"> </a>
</div>
<pre class="listing brush: scala">&lt;lift:AddEntry.addEntry form="POST" multipart="true"&gt;
  ... existing headers ...
  &lt;td&gt;Receipt (JPEG or PNG)&lt;/td&gt;
  ... existing form fields ...
  &lt;td&gt;&lt;e:receipt /&gt;&lt;/td&gt;
  ...
&lt;/lift:AddEntry.addEntry&gt;
</pre>
</div>

</div>
<div class="Indented">
On the server side, Listing <a class="Reference" href="#lst:File-upload-snippet">6.4↓</a> shows how we modify the existing <tt>addEntry</tt> snippet to handle the (optional) file attachment. We’ve added some logic to the existing form submission callback to check to make sure that the image is of the proper type, then we use the <tt>SHtml</tt> file upload generator with a callback that sets our <tt>fileHolder</tt> variable. The callback for the <tt>fileUpload</tt> generator takes a <tt>FileParamHolder</tt>, a special case class that contains information about the uploaded file. The FileParamHolder case class has four parameters:
</div>
<div class="List">
<span class="List-entry"><tt>name</tt></span><span class="List-contents">The name of the form field that this file is associated with, as sent by the client</span>
</div>
<div class="List">
<span class="List-entry"><tt>mimeType</tt></span><span class="List-contents">The mime type as sent by the client</span>
</div>
<div class="List">
<span class="List-entry"><tt>filename</tt></span><span class="List-contents">The filename as sent by the client</span>
</div>
<div class="List">
<span class="List-entry"><tt>file</tt></span><span class="List-contents">An <tt>Array[Byte]</tt> containing the uploaded file contents</span>
</div>
<div class="Unindented">
In our example, we want to save the file data into a <tt>MappedBinary</tt> field on our expense entry. You could just as easily process the data in place using a <tt>scala.io.Source</tt> or<br/>
 <tt>java.io.ByteArrayInputStream</tt>, or output it using a <tt>java.io.FileOutputStream</tt>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
File Upload Snippet<a class="Label" name="lst:File-upload-snippet"> </a>
</div>
<pre class="listing brush: scala">class AddEntry {
  ...
  // Add a variable to hold the FileParamHolder on submission
  var fileHolder : Box[FileParamHolder] = Empty
  ...
  def doTagsAndSubmit (t : String) {
    ...
    val e : Expense = ...
    // Add the optional receipt if it’s the correct type
    val receiptOk = fileHolder match {
      // An empty upload gets reported with a null mime type,
      // so we need to handle this special case
      case Full(FileParamHolder(_, null, _, _)) =&gt; true
      case Full(FileParamHolder(_, mime, _, data))
        if mime.startsWith("image/") =&gt; {
          e.receipt(data).receiptMime(mime)
          true
        }
      case Full(_) =&gt; {
        S.error("Invalid receipt attachment")
        false
      }
      case _ =&gt; true 
    }
​
    (e.validate, receiptOk) match {
    ...
    }
    ...
  }
​
  bind("e", in,
       ...
       "receipt" -&gt; SHtml.fileUpload(fileHolder = _),
       "tags" -&gt; SHtml.text(tags, doTagsAndSubmit))
  }
}
</pre>
</div>

</div>
<div class="Indented">
By default<a class="IndexReference" name="entry-Forms-saving-file-uploads-to-disk-0" href="#index-Forms-saving-file-uploads-to-disk">↓</a>, Lift will utilize the <tt>InMemoryFileParamHolder</tt> <a class="IndexReference" name="entry-InMemoryFileParamHolder-0" href="#index-InMemoryFileParamHolder">↓</a>to represent uploaded file data. This implementation reads the uploaded data directly into memory (you retrieve the byte array with the <tt>file</tt> val). If you would prefer to have Lift write uploaded data to disk and then give you a server-local filename to work with, you can use the <tt>LiftRules.handleMimeFile</tt> configuration hook to instead use the <tt>OnDiskFileParamHolder</tt><a class="IndexReference" name="entry-OnDiskFileParamHolder-0" href="#index-OnDiskFileParamHolder">↓</a>, as shown in Listing <a class="Reference" href="#lst:Using-OnDiskFileParamHolder">6.4↓</a>. The OnDiskFileParamHolder class has an additional property, <tt>localFile</tt>, that is a <tt>java.io.File</tt> object for the temporary upload file.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:Using-OnDiskFileParamHolder"> </a>Using OnDiskFileParamHolder
</div>
<pre class="listing brush: scala">// in Boot.boot:
LiftRules.handleMimeFile = OnDiskFileParamHolder.apply
</pre>
</div>

</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-7">7</a> SiteMap<a class="Label" name="cha:SiteMap"> </a>
</h1>
<div class="Unindented">
SiteMap is a very powerful part of Lift that does essentially what it says: provides a map (menu) for your site. Of course, if all it did was generate a set of links on your page, we wouldn’t have a whole chapter dedicated to it. SiteMap not only handles the basic menu generation functionality, but also provides:
</div>
<ul>
<li>
Access control mechanisms that deal not only with whether a menu item is visible, but also whether the page it points to is accessible
</li>
<li>
Grouping of menu items so that you can easily display portions of menus where you want them
</li>
<li>
Nested menus so you can have hierarchies
</li>
<li>
Request rewriting (similar to Section <a class="Reference" href="#sec:URL-Rewriting">3.7↑</a>)
</li>
<li>
State-dependent computations for such things as page titles, page-specific snippets, etc.
</li>

</ul>
<div class="Unindented">
The beauty of SiteMap is that it’s very easy to start out with the basic functionality and then expand on it as you grow.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.1">7.1</a> Basic SiteMap Definition<a class="Label" name="sec:Basic-SiteMap-Definition"> </a>
</h2>
<div class="Unindented">
Let’s start with our basic menu for PocketChange. To keep things simple, we’ll just define four menu items to begin:
</div>
<ol>
<li>
A home page that displays the user’s entries when the user is logged in, or a welcome page when the user is not
</li>
<li>
A logout link when the user is logged in, log in and registration links and pages when the user is not
</li>
<li>
Pages to view or edit the user’s profile, available only when the user is logged in
</li>
<li>
A help page, available whether the user is logged in or not
</li>

</ol>
<div class="Unindented">
We’ll assume that we have the corresponding pages, "<tt>homepage</tt>", "<tt>login</tt>", "<tt>logout</tt>", and "<tt>profile</tt>," written and functional. We’ll also assume that the help page(s) reside under the "<tt>help</tt>" subdirectory to keep things neat, and that the entry to help is <tt>/help/index</tt>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.1.1">7.1.1</a> The Link Class<a class="Label" name="sub:The-Link-Class"> </a>
</h3>
<div class="Unindented">
The Link class<span class="FootOuter"><span class="SupFootMarker"> [Y] </span><span class="HoverFoot"><span class="SupFootMarker"> [Y] </span><tt>net.liftweb.sitemap.Loc.Link</tt></span></span> is a fundamental part of Menu definitions. The <tt>Link </tt>class contains two parameters: a <tt>List[String]</tt> of path components, and a boolean value that controls whether prefix matching is enabled. The path components represent the portion of the URI following your web context, split on the "/" character. Listing <a class="Reference" href="#lst:Link-Path-Components">7.1.1↓</a> shows how you would use Link to represent the "/utils/index" page. Of course, instead of <tt>“utils” :: “index” :: Nil</tt>, you could as easily use <tt>List(“utils”, “index”)</tt> if you prefer.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Link Path Components<a class="Label" name="lst:Link-Path-Components"> </a>
</div>
<pre class="listing brush: scala">val myUtilsIndex = new Link("utils" :: "index" :: Nil, false)
</pre>
</div>

</div>
<div class="Indented">
Prefix matching allows the path components you specify to match any longer paths as well. Following our first example, if you wanted to match anything under the utils directory (say, for access control), you would set the second parameter to <tt>true</tt>, as shown in Listing <a class="Reference" href="#lst:Link-Prefix-Matching">7.1.1↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Link Prefix Matching<a class="Label" name="lst:Link-Prefix-Matching"> </a>
</div>
<pre class="listing brush: scala">val allUtilPages = new Link("utils" :: Nil, true)
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.1.2">7.1.2</a> ExtLink
</h3>
<div class="Unindented">
The ExtLink object can be used to create a Link instance using your own full link URL. As its name implies, it would usually be used for an external location. Listing <a class="Reference" href="#lst:Using-ExtLink">7.1.2↓</a> shows a menu item that points to a popular website.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using ExtLink<a class="Label" name="lst:Using-ExtLink"> </a>
</div>
<pre class="listing brush: scala">val goodReference = Menu(Loc("reference",
                             ExtLink("http://www.liftweb.net/"),
                             "LiftWeb"))
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.1.3">7.1.3</a> Creating Menu Entries
</h3>
<div class="Unindented">
Menu entries are created using the Menu<span class="FootOuter"><span class="SupFootMarker"> [Z] </span><span class="HoverFoot"><span class="SupFootMarker"> [Z] </span><tt>net.liftweb.sitemap.Menu</tt></span></span> class, and its corresponding Menu object. A Menu, in turn, holds a Loc<span class="FootOuter"><span class="SupFootMarker"> [A] </span><span class="HoverFoot"><span class="SupFootMarker"> [A] </span><tt>net.liftweb.sitemap.Loc</tt></span></span> trait instance, which is where most of the interesting things happen. A menu can also hold one or more child menus, which we’ll cover in Section <a class="Reference" href="#sub:Nested-Menus">7.1.4↓</a>. Note that the Loc object has several implicit methods that make defining Locs easier, so you generally want to import them into scope . The simplest way is to import <tt>net.liftweb.sitemap.Loc._</tt>, but you can import specific methods by name if you prefer. A Loc can essentially be thought of as a link in the menu, and contains four basic items:
</div>
<ol>
<li>
The name of the Loc: this must be unique across your sitemap because it can be used to look up specific Menu items if you customize your menu display (Section <a class="Reference" href="#sub:Using-lift-Menu">7.2.3↓</a>)
</li>
<li>
The link to which the Loc refers: usually this will referernce a specific page, but Lift allows a single Loc to match based on prefix as well (Section <a class="Reference" href="#sub:The-Link-Class">7.1.1↑</a>)
</li>
<li>
The text of the menu item, which will be displayed to the user: you can use a static string or you can generate it with a function (Section <a class="Reference" href="#sub:menu-LinkText">7.2.2↓</a>)
</li>
<li>
An optional set of LocParam parameters that control the behavior and appearance of the menu item (see Sections <a class="Reference" href="#sec:Customizing-Display">7.2↓</a>,<a class="Reference" href="#sec:SiteMap-Access-Control">7.3↓</a>, <a class="Reference" href="#sec:Misc-Menu">7.5↓</a>, and <a class="Reference" href="#sec:Page-Specific-Rendering">7.4↓</a>)
</li>

</ol>
<div class="Unindented">
For our example, we’ll tackle the help page link first, because it’s the simplest (essentially, it’s a static link). The definition is shown in Listing <a class="Reference" href="#lst:Help-Menu-Definition">7.1.3↓</a>. We’re assuming that you’ve imported the Loc implicit methods to keep things simple. We’ll cover instantiating the classes directly in later sections of this chapter.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Help Menu Definition<a class="Label" name="lst:Help-Menu-Definition"> </a>
</div>
<pre class="listing brush: scala">val helpMenu = Menu(Loc("helpHome",
                        ("help" :: "" :: Nil) -&gt; true,
                        "Help"))
</pre>
</div>

</div>
<div class="Indented">
Here we’ve named the menu item "helpHome." We can use this name to refer back to this menu item elsewhere in our code. The second parameter is a <tt>Pair[List[String],Boolean]</tt> which converts directly to a Link class with the given parameters (see Section <a class="Reference" href="#sub:The-Link-Class">7.1.1↑</a> above). In this instance, by passing in true, we’re saying that anything under the help directory will also match. If you just use a List[String], the implicit conversion is to a Link with prefix matching disabled. Note that SiteMap won’t allow access to any pages that don’t match any Menu entries, so by doing this we’re allowing full access to all of the help files without having to specify a menu entry for each. The final parameter, "Help," is the text for the menu link, should we choose to generate a menu link from this SiteMap entry.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.1.4">7.1.4</a> Nested Menus<a class="Label" name="sub:Nested-Menus"> </a>
</h3>
<div class="Unindented">
The Menu class supports child menus by passing them in as final constructor parameters. For instance, if we wanted to have an "about" menu under Help, we could define the menu as shown in Listing <a class="Reference" href="#lst:Nested-Menu-Definition">7.1.4↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Nested Menu Definition<a class="Label" name="lst:Nested-Menu-Definition"> </a>
</div>
<pre class="listing brush: scala">val aboutMenu = Menu(Loc("about", "help" :: "about" :: Nil, "About"))
val helpMenu = Menu(Loc(...as defined above...), aboutMenu)
</pre>
</div>

</div>
<div class="Indented">
When the menu is rendered it will have a child menu for About. Child menus are only rendered by default when the current page matches their parent’s Loc. That means that, for instance the following links would show in an "About" child menu item:
</div>
<ul>
<li>
<tt>/help/index</tt>
</li>
<li>
<tt>/help/usage</tt>
</li>

</ul>
<div class="Unindented">
But the following would not:
</div>
<ul>
<li>
<tt>/index</tt>
</li>
<li>
<tt>/site/example</tt>
</li>

</ul>
<div class="Unindented">
We’ll cover how you can customize the rendering of the menus in Section <a class="Reference" href="#sub:Using-lift-Menu">7.2.3↓</a>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.1.5">7.1.5</a> Setting the Global SiteMap
</h3>
<div class="Unindented">
Once you have all of your menu items defined, you need to set them as your SiteMap. As usual, we do this in the Boot class by calling the <tt>setSiteMap</tt> method on LiftRules, as shown in Listing <a class="Reference" href="#lst:Setting-the-SiteMap">7.1.5↓</a>. The <tt>setSiteMap</tt> method takes a SiteMap object that can be constructed using your menu items as arguments.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Setting the SiteMap<a class="Label" name="lst:Setting-the-SiteMap"> </a>
</div>
<pre class="listing brush: scala">LiftRules.setSiteMap(SiteMap(homeMenu, profileMenu, ...))
</pre>
</div>

</div>
<div class="Indented">
When you’re dealing with large menus, and in particular when your model objects create their own menus (see MegaProtoUser, Section <a class="Reference" href="#sub:ProtoUser-and-MegaProtoUser">8.2.8↓</a> ), then it can be more convenient to define List[Menu] and set that. Listing <a class="Reference" href="#lst:Using-List-Menu-for">7.1.5↓</a> shows this usage.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using List[Menu] for SiteMap<a class="Label" name="lst:Using-List-Menu-for"> </a>
</div>
<pre class="listing brush: scala">val menus = Menu(Loc("HomePage", "", "Home"),...) ::
            ...
            Menu(...) :: Nil
LiftRules.setSiteMap(SiteMap(menus : _*))
</pre>
</div>

</div>
<div class="Indented">
The key to using List for your menus is to explicitly define the type of the parameter as "_*" so that it’s treated as a set of varargs instead of a single argument of type List[Menu].
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.2">7.2</a> Customizing Display<a class="Label" name="sec:Customizing-Display"> </a>
</h2>
<div class="Unindented">
There are many cases where you may want to change the way that particular menu items are displayed. For instance, if you’re using a Menu item for access control on a subdirectory, you may not want the menu item displayed at all. We’ll discuss how you can control appearance, text, etc. in this section.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.2.1">7.2.1</a> Hidden<a class="Label" name="sub:menu-Hidden"> </a>
</h3>
<div class="Unindented">
The Hidden LocParam does exactly what it says: hides the menu item from the menu display. All other menu features still work. There is a variety of reasons why you might not want a link displayed. A common use, shown in Listing <a class="Reference" href="#lst:Hidden-Menus">7.2.1↓</a>, is where the point of the item is to restrict access to a particular subdirectory based on some condition. (We’ll cover the <tt>If</tt> tag in Section <a class="Reference" href="#sub:menu-If">7.3.1↓</a>.)
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Hidden Menus<a class="Label" name="lst:Hidden-Menus"> </a>
</div>
<pre class="listing brush: scala">val receiptImages =
  Menu(Loc("receipts", 
          ("receipts" :: Nil) -&gt; true,
          "Receipts",
          Hidden, If(...)))
</pre>
</div>

</div>
<div class="Indented">
Note that in this example we’ve used the implicit conversion from <tt>Pair[String,Boolean]</tt> to <tt>Link</tt> to make this Menu apply to everything under the "<tt>receipts</tt>" directory.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.2.2">7.2.2</a> Controlling the Menu Text<a class="Label" name="sub:menu-LinkText"> </a>
</h3>
<div class="Unindented">
The <tt>LinkText</tt> class is what defines the function that will return the text to display for a given menu item. As we’ve shown, this can easily be set using the implicit conversion for string<span class="formula"> → </span><tt>LinkText</tt> from <tt>Loc</tt>. As an added bonus, the implicit conversion actually takes a by-name <tt>String</tt> for the parameter. This means that you can just as easily pass in a function to generate the link text as a static string. For example, with our profile link we may want to make the link say "&lt;username&gt;’s profile". Listing <a class="Reference" href="#lst:Customizing-Link-Text">7.2.2↓</a> shows how we can do this by defining a helper method, assuming that there’s another method that will return the current user’s name (we use the ubiquitous <tt>Foo</tt> object here).
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Customizing Link Text<a class="Label" name="lst:Customizing-Link-Text"> </a>
</div>
<pre class="listing brush: scala">def profileText = Foo.currentUser + "’s profile"
val profileMenu = Menu(Loc("Profile", 
                           "profile" :: Nil,
                           profileText, ...))
</pre>
</div>

</div>
<div class="Indented">
Of course, if you want you can construct the <tt>LinkText</tt> instance directly by passing in a constructor function that returns a <tt>NodeSeq</tt>. The function that you use with <tt>LinkText</tt> takes a type-safe input parameter, which we’ll discuss in more detail in Section <a class="Reference" href="#sub:Type-Safe-Params">7.6.2↓</a>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.2.3">7.2.3</a> Using &lt;lift:Menu&gt;<a class="Label" name="sub:Using-lift-Menu"> </a>
</h3>
<div class="Unindented">
So far we’ve covered the Scala side of things. The other half of the magic is the special <tt>&lt;lift:Menu&gt;</tt> tag. It’s this tag that handles the rendering of your menus into XHTML. The Menu tag uses a built-in snippet<span class="FootOuter"><span class="SupFootMarker"> [B] </span><span class="HoverFoot"><span class="SupFootMarker"> [B] </span>net.liftweb.builtin.snippet.Menu</span></span> to provide several rendering methods. The most commonly used method is the <tt>Menu.builder</tt> snippet. This snippet renders your entire menu structure as an unordered list (<tt>&lt;ul&gt;</tt> in XHTML). Listing <a class="Reference" href="#lst:Rendering-with-Menu.title">7.2.3↓</a> shows an example of using the Menu tag to build the default menu (yes, it’s that easy).
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Rendering with &lt;lift:Menu.title&gt;<a class="Label" name="lst:Rendering-with-Menu.title"> </a>
</div>
<pre class="listing brush: xml">&lt;div class="menu"&gt;
  &lt;lift:Menu.builder /&gt;
&lt;/div&gt;
</pre>
</div>

</div>
<div class="Indented">
Of course, Lift offers more customization on this snippet than just emitting some XHTML. By specifying some prefixed attributes on the tag itself, you can add attributes directly to the menu elements. The following prefixes are valid for attributes:
</div>
<ul>
<li>
<tt>ul</tt> - Adds the specified attribute to the <tt>&lt;ul&gt;</tt> element that makes up the menu
</li>
<li>
<tt>li</tt> - Adds the specified attribute to each <tt>&lt;li&gt;</tt> element for the menu
</li>
<li>
<tt>li_item</tt> - Adds the specified attribute to the current page’s menu item
</li>
<li>
<tt>li_path</tt> - Adds the specified attribute to the current page’s breadcrumb trail (the breadcrumb trail is the set of menu items that are direct ancestors in the menu tree)
</li>

</ul>
<div class="Unindented">
The suffix of the attributes represents the name of the HTML attribute that will be added to that element, and can be anything. It will be passed directly through. For instance, we can add CSS<a class="IndexReference" name="entry-CSS-1" href="#index-CSS">↓</a> classes to our menu and elements fairly easily, as shown in Listing <a class="Reference" href="#lst:Using-Attribues-with-Menu.builder">7.2.3↓</a>. Notice that we also add a little JavaScript to our current menu item.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using Attribues with Menu.builder<a class="Label" name="lst:Using-Attribues-with-Menu.builder"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:Menu.builder
  li:class="menuitem"
  li_item:class="selectedMenu"
  li_item:onclick="javascript:alert(’Already selected!’);" /&gt;
</pre>
</div>

</div>
<div class="Indented">
In addition to rendering the menu itself, the Menu class offers a few other tricks. The <tt>Menu.title</tt><a class="IndexReference" name="entry-Menu.title-0" href="#index-Menu.title">↓</a> snippet can be used to render the title of the page, which by default is the name parameter of the Loc for the menu (the first parameter). If you write your own Loc implementation (Section <a class="Reference" href="#sec:Writing-Your-Own-Loc">7.6↓</a>), or you use the Title<a class="IndexReference" name="entry-Title-0" href="#index-Title">↓</a> <tt>LocParam</tt> (Section <a class="Reference" href="#sub:menu-Title">7.4.3↓</a>), you can overide the title to be whatever you’d like. Listing <a class="Reference" href="#lst:Rendering-the-Title">7.2.3↓</a> shows how you use <tt>Menu.title</tt>. In this particular example the title will be rendered as "<tt>Home Page</tt>".
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Rendering the Menu Title<a class="Label" name="lst:Rendering-the-Title"> </a>
</div>
<pre class="listing brush: scala">// In Boot:
val MyMenu = Menu(Loc("Home Page", "index" :: Nil, "Home"))
// In template (or wherever)
&lt;title&gt;&lt;lift:Menu.title/&gt;&lt;/title&gt;
</pre>
</div>

</div>
<div class="Indented">
The next snippet in the Menu class is <tt>item</tt>. The <tt>Menu.item</tt> snippet allows you to render a particular menu item by specifying the name attribute (matching the first parameter to Loc). As with <tt>Menu.builder</tt>, it allows you to specify additional prefixed attributes for the link to be passed to the emitted item. Because it applies these attributes to the link itself, the only valid prefix is "<tt>a</tt>". Additionally, if you specify child elements for the snippet tag, they will be used instead of the default link text. Listing <a class="Reference" href="#lst:Using-Menu.item">7.2.3↓</a> shows an example using our "<tt>Home Page</tt>" menu item defined in Listing <a class="Reference" href="#lst:Rendering-the-Title">7.2.3↑</a>. As you can see, we’ve added some replacement text as well as specifying a CSS<a class="IndexReference" name="entry-CSS-2" href="#index-CSS">↓</a> class for the link.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using Menu.item<a class="Label" name="lst:Using-Menu.item"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:Menu.item name="Home Page"
  a:class="homeLink"&gt;
  &lt;b&gt;Go Home&lt;/b&gt;
&lt;/lift:Menu.item&gt;
</pre>
</div>

</div>
<div class="Indented">
The final snippet that the Menu class provides is the <tt>Menu.group</tt> method. We’re going to cover the use of <tt>Menu.group</tt> in detail in Section <a class="Reference" href="#sub:LocGroup">7.5.2↓</a>.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.3">7.3</a> Access Control<a class="Label" name="sec:SiteMap-Access-Control"> </a>
</h2>
<div class="Unindented">
So far we’ve covered how to control the display side of Menus; now we’ll take a look at some of the plumbing behind the scenes. One important function of a Menu is that it controls access to the pages in your application. If no Menu matches a given request, then the user gets a 404 Not Found error. Other than this binary control of "matches<span class="formula"> → </span>display" and "doesn’t match<span class="formula"> → </span>don’t display", <tt>SiteMap</tt> provides for arbitrary access checks through the <tt>If</tt> and <tt>Unless</tt> <tt>LocParams</tt>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.3.1">7.3.1</a> If<a class="Label" name="sub:menu-If"> </a>
</h3>
<div class="Unindented">
The <tt>If</tt><a class="IndexReference" name="entry-If-0" href="#index-If">↓</a> <tt>LocParam</tt> takes a test function, <span class="formula">() ⇒ <i>Boolean</i></span>, as well as failure message function, <span class="formula">() ⇒ <i>LiftResponse</i></span>, as its arguments. When the <tt>Loc</tt> that uses the <tt>If</tt> clause matches a given path, the test function is executed, and if true then the page is displayed as normal. If the function evaluates to false, then the failure message function is executed and its result is sent to the user. There’s an implicit conversion in <tt>Loc</tt> from a <tt>String</tt> to a response which converts to a <tt>RedirectWithState</tt><a class="IndexReference" name="entry-RedirectWithState-0" href="#index-RedirectWithState">↓</a> instance (Section <a class="Reference" href="#sec:HTTP-redirects">3.9↑</a>). The redirect is to the location specified by <tt>LiftRules.siteMapFailRedirectLocation</tt>, which is the root of your webapp ("/") by default. If you want, you can change this in <tt>LiftRules</tt> for a global setting, or you can provide your own <tt>LiftResponse</tt><a class="IndexReference" name="entry-LiftResponse-0" href="#index-LiftResponse">↓</a>. Listing <a class="Reference" href="#lst:Using-the-If-LocParam">7.3.1↓</a> shows a revision of the profile menu that we defined in Listing <a class="Reference" href="#lst:Customizing-Link-Text">7.2.2↑</a>, extended to check whether the user is logged in. If the user isn’t logged in, we redirect to the login page.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using the If LocParam<a class="Label" name="lst:Using-the-If-LocParam"> </a>
</div>
<pre class="listing brush: scala">val loggedIn = If(() =&gt; User.loggedIn_?,
                  () =&gt; RedirectResponse("/login"))
val profileMenu = Menu(Loc("Profile", 
                           "profile" :: Nil,
                           profileText, loggedIn))
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.3.2">7.3.2</a> Unless<a class="Label" name="sub:menu-Unless"> </a>
</h3>
<div class="Unindented">
The <tt>Unless</tt><a class="IndexReference" name="entry-Unless-0" href="#index-Unless">↓</a> <tt>LocParam</tt> is essentially the mirror of <tt>If</tt>. The exact same rules apply, except that the page is displayed only if the test function returns false. The reason that there are two classes to represent this behavior is that it’s generally clearer when a predicate is read as "working" when it returns true.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.4">7.4</a> Page-Specific Rendering<a class="Label" name="sec:Page-Specific-Rendering"> </a>
</h2>
<div class="Unindented">
Page specific rendering with <tt>SiteMap</tt> is an advanced technique that provides a lot of flexibility for making pages render differently depending on state.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.4.1">7.4.1</a> The Template Parameter<a class="Label" name="sub:The-Template-Parameter"> </a>
</h3>
<div class="Unindented">
Generally, the template that will be used for a page is derived from the path of the request. The <tt>Template</tt> <tt>LocParam</tt>, however, allows you to completely override this mechanism and provide any template you want by passing in a function <span class="formula">() ⇒ <i>NodeSeq</i></span>. Going back to our example menus (Section <a class="Reference" href="#sec:Basic-SiteMap-Definition">7.1↑</a>), we’d like the welcome page to show either the user’s entries or a plain welcome screen depending on whether they’re logged in. One approach to this is shown in Listing <a class="Reference" href="#lst:Override-Templates">7.4.1↓</a>. In this example, we create a <tt>Template</tt> class that generates the appropriate template and then bind it into the home page menu <tt>Loc</tt>. (See the Lift API for more on the Template class.)
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Overriding Templates<a class="Label" name="lst:Override-Templates"> </a>
</div>
<pre class="listing brush: scala">val homepageTempl = Template({ () =&gt;
  &lt;lift:surround with="default" at="content"&gt;
  { if (User.loggedIn_?) { 
      &lt;lift:Entries.list /&gt; 
    } else {
      &lt;lift:embed what="welcome" /&gt;
    }
  }
  &lt;/lift:surround&gt;
})
val homeMenu = Menu(Loc("Home Page",
                        "" :: Nil,
                        "Home Page", homepageTempl))
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.4.2">7.4.2</a> The Snippet and LocSnippets Parameters
</h3>
<div class="Unindented">
Besides overriding the template for a page render (admittedly, a rather coarse approach), SiteMap has two mechanisms for overriding or defining the behavior of specific snippets. The first, Snippet, allows you to define the dispatch for a single snippet based on the name of the snippet. Listing <a class="Reference" href="#lst:Using-the-Snippet-locparam">7.4.2↓</a> shows how we could use Snippet to achieve the same result for the home page rendering as we just did with the Template parameter. All we need to do is use the &lt;lift:homepage&gt; snippet on our main page and the snippet mapping will dispatch based on the state. (Here we’ve moved the welcome text into a Utils.welcome snippet.)
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using the Snippet LocParam<a class="Label" name="lst:Using-the-Snippet-locparam"> </a>
</div>
<pre class="listing brush: scala">val homeSnippet = Snippet("homepage",
  if (User.loggedIn_?) {
    Entries.list _
  } else {
    Utils.welcome _
  })
val homeMenu = Menu(Loc("Home Page",
                        "" :: Nil,
                        "Home Page", homeSnippet))
</pre>
</div>

</div>
<div class="Indented">
The LocSnippets trait extends the concept of Snippet to provide a full dispatch partial function. This allows you to define multiple snippet mappings associated with a particular Loc. To simplify things, Lift provides a DispatchLocSnippets trait that has default implementations for <tt>apply</tt> and <tt>isDefinedAt</tt>; that means you only need to provide a <tt>dispatch</tt> method implementation for it to work. Listing <a class="Reference" href="#lst:Using-LocSnippets">7.4.2↓</a> shows an example of using DispatchLocSnippets for a variety of snippets.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using LocSnippets<a class="Label" name="lst:Using-LocSnippets"> </a>
</div>
<pre class="listing brush: scala">val entrySnippets = new DispatchLocSnippets {
  def dispatch = {
    case "entries" =&gt; Entries.list _
    case "add" =&gt; Entries.newEntry _
  }
}
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.4.3">7.4.3</a> Title<a class="Label" name="sub:menu-Title"> </a>
</h3>
<div class="Unindented">
As we mentioned in Section <a class="Reference" href="#sub:Using-lift-Menu">7.2.3↑</a>, the Title LocParam can be used to provide a state-dependent title for a page. The Title case class simply takes a function <span class="formula">(<i>T</i>) ⇒ <i>NodeSeq</i></span>, where T is a type-safe parameter (we’ll cover this in Section <a class="Reference" href="#sub:Type-Safe-Params">7.6.2↓</a>). Generally you can ignore this parameter if you want to, which is what we do in Listing <a class="Reference" href="#lst:Customizing-the-Title">7.4.3↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Customizing the Title<a class="Label" name="lst:Customizing-the-Title"> </a>
</div>
<pre class="listing brush: scala">val userTitle = Title((_) =&gt; 
  if (User.loggedIn_?) {
    Text(User.name + "’s Account")
  } else {
    Text("Welcome to PocketChange")
  })
val homeMenu = Menu(Loc("Home Page",
                        "" :: Nil,
                        "Home Page", homepageTempl, userTitle))
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.5">7.5</a> Miscellaneous Menu Functionality<a class="Label" name="sec:Misc-Menu"> </a>
</h2>
<div class="Unindented">
These are LocParams that don’t quite fit into the other categories.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.5.1">7.5.1</a> Test<a class="Label" name="sub:menu-Test"> </a>
</h3>
<div class="Unindented">
Test is intended to be used to ensure that a given request has the proper parameters before servicing. With Test, you provide a function, <span class="formula">(<i>Req</i>) ⇒ <i>Boolean</i></span> that is passed the full Req object. Note that the test is performed when SiteMap tries to locate the correct menu, as opposed to If and Unless, which are tested after the proper Loc has been identified. Returning a false means that this Loc doesn’t match the request, so SiteMap will continue to search through your Menus to find an appropriate Loc. As an example, we could check to make sure that a given request comes from Opera (the Req object provides convenience methods to test for different browsers; see the Lift API for a full list) with the code in Listing <a class="Reference" href="#lst:Testing-the-Request">7.5.1↓</a>. 
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Testing the Request<a class="Label" name="lst:Testing-the-Request"> </a>
</div>
<pre class="listing brush: scala">val onlyOpera = Test(req =&gt; req.isOpera)
val operaMenu = Menu(Loc("Opera", "opera" :: Nil, "Only Opera", onlyOpera))
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.5.2">7.5.2</a> LocGroup<a class="Label" name="sub:LocGroup"> </a>
</h3>
<div class="Unindented">
The LocGroup param allows you to categorize your menu items. The <tt>Menu.group</tt> snippet (mentioned in Section <a class="Reference" href="#sub:Using-lift-Menu">7.2.3↑</a>) allows you to render the menu items for a specific group. A menu item may be associated with one or more groups. Simply add a LocGroup param with string arguments for the group names, as shown in Listing <a class="Reference" href="#lst:Categorizing-your-Menu">7.5.2↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Categorizing Your Menu<a class="Label" name="lst:Categorizing-your-Menu"> </a>
</div>
<pre class="listing brush: scala">val siteMenu = Menu(Loc(...,LocGroup("admin", "site")))
</pre>
</div>

</div>
<div class="Indented">
In your templates, you then specify the binding of the menu as shown in Listing <a class="Reference" href="#lst:Binding-a-Menu-group">7.5.2↓</a>. As you can see, we’ve also added a prefixed attribute to control the CSS<a class="IndexReference" name="entry-CSS-3" href="#index-CSS">↓</a> class of the links ("a" is the only valid prefix), and we’ve added some body XHTML for display. In particular, the &lt;menu:bind&gt; tag controls where the menu items are rendered. If you don’t provide body elements, or if you provide body elements without the &lt;menu:bind&gt; element, your body XHTML will be ignored and the menu will be rendered directly.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Binding a Menu Group<a class="Label" name="lst:Binding-a-Menu-group"> </a>
</div>
<pre class="listing brush: scala">&lt;div class="site"&gt;
  &lt;ul&gt;
  &lt;lift:Menu.group group="site"
    a:class="siteLink"&gt;
   &lt;li&gt;&lt;menu:bind /&gt;&lt;/li&gt;
  &lt;/lift:Menu.group&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.6">7.6</a> Writing Your Own Loc<a class="Label" name="sec:Writing-Your-Own-Loc"> </a>
</h2>
<div class="Unindented">
As we’ve shown, there’s a lot of functionality available for your Menu items. If you need more control, though, the Loc trait offers some functionality, such as rewriting, that doesn’t have a direct correspondence in a LocParam element. The basic definition of a Loc implementation covers a lot of the same things. The following vals and defs are abstract, so you must implement them yourself:
</div>
<ul>
<li>
def name: the name that can be used to retrieve the menu via Menu.item
</li>
<li>
def link: the actual link; you can use the implicit conversions from List[String] or Pair[List[String],Boolean], or you can create the Link object yourself
</li>
<li>
def text: the text that will be displayed to the user; you can use the implicit conversion from String, or you can provide your own LinkText instance
</li>
<li>
def params: must return a List[LocParam] that is used to control behavior as we’ve shown in the previous sections
</li>
<li>
def defaultParams: used for type-safe rewriting, which we’ll cover in Section <a class="Reference" href="#sub:Type-Safe-Params">7.6.2↓</a>
</li>

</ul>
<div class="Unindented">
Essentially, these mirror the params that are required when you use Loc.apply to generate a Loc. We’re going to write our own Loc implementation for our Expenses in this section to demonstrate how this works. Because this overlaps with existing functionality in the PocketChange application, we’ll be using a branch in the PocketChange app. You can pull the new branch with the command
</div>
<pre class="LyX-Code">
git checkout --track -b custom-loc origin/custom-loc
</pre>
<div class="Unindented">
You can then switch back and forth between the branches with the commands:
</div>
<pre class="LyX-Code">
git checkout master
git checkout custom-loc
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.6.1">7.6.1</a> Corresponding Functions
</h3>
<div class="Unindented">
Table <a class="Reference" href="#tab:LocParam-Methods-in-loc">7.1↓</a> lists the LocParams and their corresponding methods in Loc, with notes to explain any differences in definition or usage. If yould prefer to use the LocParams instead, just define the <tt>params</tt> method on Loc to return a list of the LocParams you want.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="tab:LocParam-Methods-in-loc"> </a><div class="table">
<div class="center">
<table>
<tr>
<td align="center" valign="top" style="width: 1in;">
Hidden
</td>
<td align="center" valign="top" style="width: 1.5in;">
N/A
</td>
<td align="center" valign="top" style="width: 2.5in;">
To make your Loc hidden, add a Hidden LocParam to your params method return value
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1in;">
If/Unless
</td>
<td align="center" valign="top" style="width: 1.5in;">
override testAccess
</td>
<td align="center" valign="top" style="width: 2.5in;">
You need to return an Either to indicate success (Left[Boolean]) or failure (Right[Box[LiftResponse]])
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1in;">
Template
</td>
<td align="center" valign="top" style="width: 1.5in;">
override calcTemplate
</td>
<td align="center" valign="top" style="width: 2.5in;">
Return a Box[NodeSeq]
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1in;">
Snippet and LocSnippets
</td>
<td align="center" valign="top" style="width: 1.5in;">
override snippets
</td>
<td align="center" valign="top" style="width: 2.5in;">
Snippet is a PartialFunction[String, Box[ParamType]), NodeSeq =&gt; NodeSeq], which lets you use the type-safe parameter to control behavior.
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1in;">
Title
</td>
<td align="center" valign="top" style="width: 1.5in;">
override title
</td>
<td align="center" valign="top" style="width: 2.5in;">
You can override "def title" or "def title(in: ParamType)" depending on whether you want to use type-safe parameters
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1in;">
Test
</td>
<td align="center" valign="top" style="width: 1.5in;">
override doesMatch_?
</td>
<td align="center" valign="top" style="width: 2.5in;">
It’s your responsibility to make sure that the <i>path</i> of the request matches your Loc, since this method is what SiteMap uses to find the proper Loc for a request
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1in;">
LocGroup
</td>
<td align="center" valign="top" style="width: 1.5in;">
override inGroup_?
</td>
<td align="center" valign="top" style="width: 2.5in;">
Nothing special here
</td>

</tr>

</table>

</div>
<div class="caption">
Table 7.1 LocParam Methods in Loc
</div>

</div>

</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.6.2">7.6.2</a> Type Safe Parameters<a class="Label" name="sub:Type-Safe-Params"> </a>
</h3>
<div class="Unindented">
One of the nice features of Loc is that it allows you to rewrite requests in a type-safe manner. What this means is that we can define a rewrite function on our Loc instance that returns not only a standard RewriteResponse, but also a parameter that we can define to pass information back to our menu to control behavior. The reason that this is type-safe is that we define our Loc on the type of the parameter itself. For instance, let’s expand the functionality of our app so that we have a page called "acct" that shows the expense entries for a given account. We would like this page to be viewable only by the owner of the account under normal circumstances, but to allow them to share it with other members if they wish to. Let’s start by defining our type-safe parameter class as shown in Listing <a class="Reference" href="#lst:Defining-LedgerInfo">7.6.2↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Defining AccountInfo<a class="Label" name="lst:Defining-LedgerInfo"> </a>
</div>
<pre class="listing brush: scala">abstract class AccountInfo
case object NoSuchAccount extends AccountInfo
case object NotPublic extends AccountInfo
case class FullAccountInfo(account : Account,
                           entries : List[Expense]) extends AccountInfo
</pre>
</div>

</div>
<div class="Indented">
We define a few case classes to indicate various states. The FullAccountInfo holds the account itself as well as some flags for behavior. Now that we have our parameter type, we can start to define our Loc, as shown in Listing <a class="Reference" href="#lst:Defining-a-Type-Safe-loc">7.6.2↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Defining a Type-Safe Loc<a class="Label" name="lst:Defining-a-Type-Safe-loc"> </a>
</div>
<pre class="listing brush: scala">class AccountLoc extends Loc[AccountInfo] {
...
}
</pre>
</div>

</div>
<div class="Indented">
Assuming that an Account instance has a unique string ID, we would like to use URL rewriting so that we can access a ledger via "/acct/&lt;unique id&gt;". Our rewrite function, shown in Listing <a class="Reference" href="#lst:The-Rewrite-Function">7.6.2↓</a>, handles a few different things at once. It handles locating the correct account and then checking the permissions if everything else is OK.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
The Rewrite Function<a class="Label" name="lst:The-Rewrite-Function"> </a>
</div>
<pre class="listing brush: scala">override def rewrite = Full({
  case RewriteRequest(ParsePath(List("acct", aid), _, _, _), _, _) =&gt; {
    Account.findAll(By(Account.stringId, aid)) match {
      case List(account) if account.is_public.is =&gt; {
        (RewriteResponse("account" :: Nil),
         FullAccountInfo(account, account.entries))
      }
      case List(account) =&gt; {
        (RewriteResponse("account" :: Nil),
         NotPublic)
      }
      case _ =&gt; {
        (RewriteResponse("account" :: Nil),
         NoSuchAccount)
      }
    }
  }
})
</pre>
</div>

</div>
<div class="Indented">
Now that we’ve defined the transformation from URL to parameter, we need to define the behaviors based on that parameter. The account page will show a list of expense entries only if the account is located and is public. For this example we’ll use a single template and we’ll change the snippet behavior based on our parameter, as shown in Listing <a class="Reference" href="#lst:Defining-Snippet-Behavior">7.6.2↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Defining Snippet Behavior<a class="Label" name="lst:Defining-Snippet-Behavior"> </a>
</div>
<pre class="listing brush: scala">override def snippets = {
  case ("entries", Full(NoSuchAccount)) =&gt; {ignore : NodeSeq =&gt;
    Text("Could not locate the requested account")}
  case ("entries", Full(NotPublic)) =&gt; {ignore : NodeSeq =&gt;
    Text("This account is not publicly viewable")}
  case ("entries", Full(FullAccountInfo(account, List()))) =&gt; {ignore : NodeSeq =&gt;
    Text("No entries for " + account.name.is)}
  case ("entries", Full(FullAccountInfo(account, entries))) =&gt;
    Accounts.show(entries) _ 
}
</pre>
</div>

</div>
<div class="Indented">
In this example, we simply return some text if the <tt>Account</tt> can’t be located, isn’t public, or doesn’t have any <tt>Expense</tt> entries. Remember that this function needs to return a snippet function, which expects a NodeSeq parameter. This is why we need to include the <tt>ignore</tt> parameter as part of our closures. If our <tt>Account</tt> does have entries, we return a real snippet method defined in our <tt>Accounts</tt> object. In our template, we simply use an entries snippet tag, as shown in Listing <a class="Reference" href="#lst:Our-Public-Template">7.6.2↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Our Public Template<a class="Label" name="lst:Our-Public-Template"> </a>
</div>
<pre class="listing brush: scala">&lt;lift:surround with="default" at="content"&gt;
  &lt;lift:entries  eager_eval="true"&gt;
    &lt;h1&gt;&lt;lift:Menu.title /&gt;&lt;/h1&gt;
    &lt;lift:embed what="entry_table" /&gt;
  &lt;/lift:entries&gt;
&lt;/lift:surround&gt; 
</pre>
</div>

</div>
<div class="Indented">
We’re using our embedded table template for the body of the table along with the <tt>eager_eval</tt> attribute so that we can use the same markup for all occurrences of our expense table display. We can also define the title of the page based on the <tt>title</tt> parameter, as shown in Listing <a class="Reference" href="#lst:Defining-the-Title">7.6.2↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Defining the Title<a class="Label" name="lst:Defining-the-Title"> </a>
</div>
<pre class="listing brush: scala">override def title(param : AccountInfo) = param match {
  case FullAccountInfo(acct, _) =&gt; 
    Text("Expense summary for " + acct.name.is)
  case _ =&gt; Text("No account")
}
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.6.3">7.6.3</a> Dynamically Adding Child Menus
</h3>
<div class="Unindented">
TBW
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-7.6.4">7.6.4</a> Binding Your Custom Loc
</h3>
<h2 class="Section">
<a class="toc" name="toc-Section-7.7">7.7</a> Conclusion
</h2>
<div class="Unindented">
As we’ve shown in this chapter, SiteMap offers a wide range of functionality to let you control site navigation and access. You can customize the display of your individual items using the <tt>LinkText</tt> <tt>LocParam</tt> as well as through the functionality of the built-in <tt>Menu</tt> <tt>builder</tt> and <tt>item</tt> snippets. You can use the <tt>If</tt> and <tt>Unless</tt> <tt>LocParam</tt>s to control access to your pages programmatically, and you can use the <tt>Test</tt> <tt>LocParam</tt> to check the request before it’s even dispatched. Page-specific rendering can be customized with the <tt>Template</tt>, <tt>Snippet</tt>, and <tt>LocSnippet</tt> <tt>LocParam</tt>s, and you can group menu items together via the <tt>LocGroup</tt> <tt>LocParam</tt>. Finally, you can consolidate all of these functions by writing your own <tt>Loc</tt> trait subclass directly, and gain the additional benefit of type-safe URL rewriting. Together these offer a rich set of tools for building your web site exactly they way you want to.
</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-8">8</a> The Mapper and Record Frameworks<a class="Label" name="cha:mapper_and_record"> </a>
</h1>
<div class="Unindented">
In our experience, most webapps end up needing to store user data somewhere. Once you start working with user data, though, you start dealing with issues like coding up input forms, validation<a class="IndexReference" name="entry-validation-0" href="#index-validation">↓</a>, persistence, etc. to handle the data. That’s where the Mapper and Record frameworks come in. These frameworks provides a scaffolding for all of your data manipulation needs. Mapper is the original Lift persistence framework, and it is closely tied to JDBC for its storage. Record is a new refactorization of Mapper that is backing-store agnostic at its core, so it doesn’t matter whether you want to save your data to JDBC, JPA, or even something such as XML. With Record, selecting the proper driver will be as simple as hooking the proper traits into your class.
</div>
<div class="Indented">
<div class="Framed" style="width: 100%;">
The Record framework is relatively new to Lift. <strike>The plan is to move to Record as the primary ORM framework for Lift sometime post-1.0.</strike> Because Record is still under active design and development, and because of its current “moving target” status, this chapter is mostly going to focus on Mapper. We will, however, provide a few comparitive examples of Record functionality to give you a general feel for the flavor of the changes. In any case, Mapper will not go away even when record comes out, so you can feel secure that any code using Mapper will be viable for quite a while.
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-8.1">8.1</a> Introduction to Mapper and MetaMapper
</h2>
<div class="Unindented">
Let’s start by discussing the relationship between the Mapper<a class="IndexReference" name="entry-Mapper-0" href="#index-Mapper">↓</a> and MetaMapper<a class="IndexReference" name="entry-MetaMapper-0" href="#index-MetaMapper">↓</a> traits (and the corresponding Record<a class="IndexReference" name="entry-Record-0" href="#index-Record">↓</a> and MetaRecord<a class="IndexReference" name="entry-MetaRecord-0" href="#index-MetaRecord">↓</a>). Mapper provides the <i>per-instance</i> functionality for your class, while MetaMapper handles the <i>global</i> operations for your class and provides a common location to define per-class static specializations of things like field order, form generation, and HTML representation. In fact, many of the Mapper methods actually delegate to methods on MetaMapper. In addition to Mapper and MetaMapper, there is a third trait, MappedField, that provides the per-field functionality for your class. In Record, the trait is simply called “Field”. The MappedField trait lets you define the individual validators as well as filters to transform the data and the field name. Under Record, Field adds some functionality such as tab order and default error messages for form input handling.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.1.1">8.1.1</a> Adding Mapper to Your Project
</h3>
<div class="Unindented">
Since Mapper is a separate module, you need to add the following dependency to your pom.xml to access it:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Mapper POM Dependency
</div>
<pre class="listing brush: xml">&lt;project ...&gt;
  ...
  &lt;dependencies&gt;
    ...
    &lt;dependency&gt;
      &lt;groupId&gt;net.liftweb&lt;/groupId&gt;
      &lt;artifactId&gt;lift-mapper&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt; &lt;!-- or 1.1-SNAPSHOT, etc --&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  ...
&lt;/project&gt;
</pre>
</div>

</div>
<div class="Indented">
You’ll also need the following import in any Scala code that uses Mapper:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Mapper Imports
</div>
<pre class="listing brush: scala">import _root_.net.liftweb.mapper._
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.1.2">8.1.2</a> Setting Up the Database Connection
</h3>
<div class="Unindented">
The first thing you need to do is to define the database connection. We do this by defining an object called <tt>DBVendor</tt> (but you can call it whatever you want). This object extends the net.liftweb.mapper.ConnectionManager trait and must implement two methods: newConnection and releaseConnection. You can make this as sophisticated as you want, with pooling, caching, etc., but for now, Listing <a class="Reference" href="#lst:Setting-up-the-database">8.1.2↓</a> shows a basic implementation to set up a PostgreSQL driver.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Setting Up the Database<a class="Label" name="lst:Setting-up-the-database"> </a>
</div>
<pre class="listing brush: scala">.. standard Lift imports ...
import _root_.net.liftweb.mapper._
import _root_.java.sql._
​
object DBVendor extends ConnectionManager {
  // Force load the driver
  Class.forName("org.postgresql.Driver")
  // define methods
  def newConnection(name : ConnectionIdentifier) = {
    try {
      Full(DriverManager.getConnection(
           "jdbc:postgresql://localhost/mydatabase",
           "root", "secret"))
    } catch {
      case e : Exception =&gt; e.printStackTrace; Empty
    }
  }
  def releaseConnection (conn : Connection) { conn.close }
}
​
class Boot {
  def boot {
    ...
    DB.defineConnectionManager(DefaultConnectionIdentifier, DBVendor)
  }
}
</pre>
</div>

</div>
<div class="Indented">
A few items to note:
</div>
<ol>
<li>
The <tt>name</tt> parameter for newConnection can be used if you need to have connections to multiple distinct databases. One specialized case of this is when you’re doing DB sharding (horizontal scaling). Multiple database usage is covered in more depth in Section <a class="Reference" href="#sub:Multiple-Databases">8.3.1↓</a>
</li>
<li>
The newConnection method needs to return a <tt>Box[java.sql.Connection]</tt>. Returning <tt>Empty</tt> indicates failure
</li>
<li>
The releaseConnection method exists so that you have complete control over the lifecycle of the connection. For instance, if you were doing connection pooling yourself you would return the connection to the available pool rather than closing it
</li>
<li>
The <tt>DB.defineConnectionManager</tt> call is what binds our manager into Mapper. Without it your manager will never get called
</li>

</ol>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.1.3">8.1.3</a> Constructing a Mapper-enabled Class<a class="Label" name="sub:Constructing-a-Mapper-enabled-class"> </a>
</h3>
<div class="Unindented">
Now that we’ve covered some basic background, we can start constructing some Mapper classes to get more familiar with the framework. We’ll start with a simple example of a class for an expense transaction from our PocketChange application with the following fields:
</div>
<ul>
<li>
Date
</li>
<li>
Description: a string with a max length of 100 chars
</li>
<li>
Amount: a decimal value with a precision of 16 digits and two decimal places
</li>
<li>
A reference to the Account that owns the transaction
</li>

</ul>
<div class="Unindented">
Given these requirements we can declare our <tt>Expense</tt> class as shown in Listing <a class="Reference" href="#lst:Entry-class-mapper">8.1.3↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Expense Class in Mapper<a class="Label" name="lst:Entry-class-mapper"> </a>
</div>
<pre class="listing brush: scala">import _root_.java.math.MathContext
​
class Expense extends LongKeyedMapper[Expense] with IdPK {
  def getSingleton = Expense
  object dateOf extends MappedDateTime(this)
  object description extends MappedString(this,100)
  object amount extends MappedDecimal(this, MathContext.DECIMAL64, 2)
  object account extends MappedLongForeignKey(this, Account)
}
</pre>
</div>

</div>
<div class="Indented">
For comparison, the Record version is shown in Listing <a class="Reference" href="#lst:Entry-class-record">8.1.3↓</a>. This example already shows some functionality that hasn’t been ported over to Record from Mapper; among other things, the <tt>IdPK</tt> trait, and foreign key fields (many to one mappings) are missing. The other minor differences are that the <tt>getSingleton</tt> method has been renamed to <tt>meta</tt>, and the Field traits use different names under the Record framework (i.e. <tt>DateTimeField</tt> vs <tt>MappedDateTime</tt>).
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Entry Class in Record<a class="Label" name="lst:Entry-class-record"> </a>
</div>
<pre class="listing brush: scala">import _root_.java.math.MathContext
import _root_.net.liftweb.record._
​
class Expense extends KeyedRecord[Expense,Long] {
  def meta = Expense
  def primaryKey = id
  object id extends LongField(this) with KeyField[Long,Expense]
  object dateOf extends DateTimeField(this)
  object description extends StringField(this, 100)
  object amount extends DecimalField(this, MathContext.DECIMAL64, 2)
  object account extends LongField(this)
}
</pre>
</div>

</div>
<div class="Indented">
As you can see, we’ve set <tt>Expense</tt> to extend the <tt>LongKeyedMapper</tt> and <tt>IdPK</tt> traits and we’ve added the fields required by our class. We would like to provide a primary key for our entity; while not strictly necessary, having a synthetic primary key often helps with CRUD operations. The <tt>LongKeyedMapper</tt> trait accomplishes two objectives: it tells Lift that we want a primary key defined and that the key should be a long. This is basically a shortcut for using the <tt>KeyedMapper[Long,Expense]</tt><a class="IndexReference" name="entry-KeyedMapper-0" href="#index-KeyedMapper">↓</a> trait. When you use the <tt>KeyedMapper</tt> trait you need to provide an implementation for the <tt>primaryKeyField</tt> def, which must match the type of the <tt>KeyedMapper</tt> trait and be a subtype of <tt>IndexedField</tt><a class="IndexReference" name="entry-IndexedField-0" href="#index-IndexedField">↓</a>. The <tt>IdPK</tt> trait handles the implementation, but note that <tt>IdPK</tt> currently only supports <tt>Long</tt> keys. Mapper supports both indexed <tt>Longs</tt> and <tt>Strings</tt>, so if you want <tt>Strings</tt> you’ll need to explicitly use <tt>KeyedMapper[String,...]</tt> and provide the field definition yourself. It’s possible to use some other type for your primary key, but you’ll need to roll your own (Section <a class="Reference" href="#sub:Defining-Custom-Field-types-mapper">8.2.7↓</a>). Technically <tt>Int</tt> indexes are supported as well, but there is no corresponding trait for an <tt>Int</tt> foreign key. That means that if you use an <tt>Int</tt> for the primary key, you may not be able to add a relationship to another object (Section <a class="Reference" href="#sub:Object-Relationships">8.1.4↓</a>), unless you write your own. Record is a little more flexible in primary key selection because it uses, in effect, a marker trait (<tt>KeyField</tt>) to indicate that a particular field is a key field. One thing to note is that in the Mapper framework, the table name<a class="IndexReference" name="entry-table-name-0" href="#index-table-name">↓</a> for your entity defaults to the name of the class (Expense, in our case). If you want to change this, then you just need to override the <tt>dbTableName</tt><a class="IndexReference" name="entry-dbTableName-0" href="#index-dbTableName">↓</a> def in your MetaMapper object.
</div>
<div class="Indented">
Looking at these examples, you’ve probably noticed that the fields are defined as objects rather than instance members (vars). The basic reason for this is that the MetaMapper needs access to fields for its validation and form functionality; it is more difficult to cleanly define these properties in the MetaMapper if it had to access member vars on each instance since a MetaMapper instance is itself an object. Also note that <tt>MappedDecimal</tt> is a custom field type<span class="FootOuter"><span class="SupFootMarker"> [C] </span><span class="HoverFoot"><span class="SupFootMarker"> [C] </span>The authors are working on adding this to the core library soon after Lift 1.0</span></span>, which we’ll cover in Section <a class="Reference" href="#sub:Defining-Custom-Field-types-mapper">8.2.7↓</a>.
</div>
<div class="Indented">
In order to tie all of this together, we need to define a matching <tt>LongKeyedMetaMapper</tt><a class="IndexReference" name="entry-KeyedMetaMapper-0" href="#index-KeyedMetaMapper">↓</a> object as the singleton for our entity, as shown in Listing <a class="Reference" href="#lst:EntryMeta-object">8.1.3↓</a>. The Meta object (whether MetaMapper or MetaRecord) is where you define most behavior that is common across all of your instances. In our examples, we’ve decided to name the meta object and instance class the same. We don’t feel that this is unclear because the two together are what really define the ORM behavior for a “type.”
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
EntryMeta object<a class="Label" name="lst:EntryMeta-object"> </a>
</div>
<pre class="listing brush: scala">object Expense extends Expense with LongKeyedMetaMapper[Expense] {
  override def fieldOrder = List(dateOf, description, amount)
}
</pre>
</div>

</div>
<div class="Indented">
In this instance, we’re simply defining the order of fields as they’ll be displayed in XHTML<a class="IndexReference" name="entry-XHTML-1" href="#index-XHTML">↓</a> and forms<a class="IndexReference" name="entry-form-0" href="#index-form">↓</a> by overriding the <tt>fieldOrder</tt> method. The default behavior is an empty list, which means no fields are involved in display or form generation. Generally, you will want to override <tt>fieldOrder</tt> because this is not very useful. If you don’t want a particular field to show up in forms or XHTML output, simply omit it from the fieldOrder<a class="IndexReference" name="entry-fieldOrder-0" href="#index-fieldOrder">↓</a> list.
</div>
<div class="Indented">
Because fields aren’t actually instance members, operations on them are slightly different than with a regular var. The biggest difference is how we set fields: we use the apply method. In addition, field access can be chained so that you can set multiple field values in one statement, as shown in Listing <a class="Reference" href="#lst:Setting-field-values">8.1.3↓</a>:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Setting Field Values<a class="Label" name="lst:Setting-field-values"> </a>
</div>
<pre class="listing brush: scala">myEntry.dateOf(new Date).description("A sample entry")
myEntry.amount(BigDecimal("127.20"))
</pre>
</div>

</div>
<div class="Indented">
The underlying value of a given field can be retrieved with the <tt>is</tt> method (the <tt>value</tt> method in Record) as shown in Listing <a class="Reference" href="#lst:Accessing-field-values">8.1.3↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Accessing Field Values in Record<a class="Label" name="lst:Accessing-field-values"> </a>
</div>
<pre class="listing brush: scala">// mapper
val tenthOfAmount = myEntry.amount.is / 10
val formatted = String.format("%s : %s",
                              myEntry.description.is,
                              myEntry.amount.is.toString)
// record
if (myEntry.description.value == "Doughnuts") {
  println("Diet ruined!")
}
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.1.4">8.1.4</a> Object Relationships<a class="Label" name="sub:Object-Relationships"> </a>
</h3>
<div class="Unindented">
Often it’s appropriate to have relationships between different entities. The archetypical example of this is the parent-child relationship. In SQL, a relationship can be defined with a foreign key that associates one table to another based on the primary key of the associated table. As we showed in Listing <a class="Reference" href="#lst:Entry-class-mapper">8.1.3↑</a>, there is a corresponding <tt>MappedForeignKey</tt> trait, with concrete implementations for Long and String foreign keys. Once we have this defined, accessing the object via the relationship is achieved by using the <tt>obj</tt> method on the foreign key field. Note that the <tt>obj</tt> method returns a <tt>Box</tt>, so you need to do some further processing with it before you can use it. With the foreign key functionality you can easily do one-to-many and many-to-one<a class="IndexReference" name="entry-many-to-one-0" href="#index-many-to-one">↓</a> relationships (depending on where you put the foreign key). One-to-many<a class="IndexReference" name="entry-one-to-many-0" href="#index-one-to-many">↓</a> relationships can be achieved using helper methods on the “one” side that delegate to queries. We’ll cover queries in a moment, but Listing <a class="Reference" href="#lst:Accessing-Foreign-Objects">8.1.4↓</a> shows examples of two sides of the same relationship.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Accessing Foreign Objects<a class="Label" name="lst:Accessing-Foreign-Objects"> </a>
</div>
<pre class="listing brush: scala">class Expense extends LongKeyedMapper[Expense] with IdPK {
 ...
  object account extends MappedLongForeignKey(this, Account)
  def accountName = 
    Text("My account is " + (account.obj.map(_.name.is) openOr "Unknown"))
}
​
class Account ... {
  ...
  def entries = Expense.findAll(By(Expense.account, this.id))
}
</pre>
</div>

</div>
<div class="Indented">
If you want to do many-to-many<a class="IndexReference" name="entry-many-to-many-0" href="#index-many-to-many">↓</a> mappings you’ll need to provide your own “join” class with foreign keys to both of your mapped entities. An example would be if we wanted to have tags (categories) for our ledger entries and wanted to be able to have a given entry have multiple tags (e.g., you purchase a book for your mother’s birthday, so it has the tags Gift, Mom, and Books). First we define the <tt>Tag</tt> entity, as shown in Listing<a class="Reference" href="#lst:Tag-Entity">8.1.4↓</a> .
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Tag Entity<a class="Label" name="lst:Tag-Entity"> </a>
</div>
<pre class="listing brush: scala">class Tag extends LongKeyedMapper[Tag] with IdPK {
  def getSingleton = Tag
  object name extends MappedString(this,100)
}
object Tag extends Tag with LongKeyedMetaMapper[Tag] {
  override def fieldOrder = List(name)
}
</pre>
</div>

</div>
<div class="Indented">
Next, we define our join entity, as shown in Listing <a class="Reference" href="#lst:Join-Entity">8.1.4↓</a>. It’s a <tt>LongKeyedMapper</tt> just like the rest of the entities, but it only contains foreign key fields to the other entities.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Join Entity<a class="Label" name="lst:Join-Entity"> </a>
</div>
<pre class="listing brush: scala">class ExpenseTag extends LongKeyedMapper[ExpenseTag] with IdPK {
  def getSingleton = ExpenseTag
  object tag extends MappedLongForeignKey(this,Tag)
  object expense extends MappedLongForeignKey(this,Expense)
}
​
object ExpenseTag extends ExpenseTag with LongKeyedMetaMapper[ExpenseTag] {
  def join (tag : Tag, tx : Expense) = 
    this.create.tag(tag).expense(tx).save
}
</pre>
</div>

</div>
<div class="Indented">
To use the join entity, you’ll need to create a new instance and set the appropriate foreign keys to point to the associated instances. As you can see, we’ve defined a convenience method on our <tt>Expense</tt> meta object to do just that. To make the many-to-many<a class="IndexReference" name="entry-many-to-many-1" href="#index-many-to-many">↓</a> accessible as a field on our entities, we can use the HasManyThrough trait, as shown in Listing <a class="Reference" href="#lst:HasManyThrough-for-Many-to-Many">8.1.4↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
HasManyThrough for Many-to-Many Relationships<a class="Label" name="lst:HasManyThrough-for-Many-to-Many"> </a>
</div>
<pre class="listing brush: scala">class Expense ... {
  object tags extends HasManyThrough(this, Tag, 
    ExpenseTag, ExpenseTag.tag, ExpenseTag.expense)
}
</pre>
</div>

</div>
<div class="Indented">
A similar field could be set up on the <tt>Tag</tt> entity to point to entries. It’s important to note a few items:
</div>
<ul>
<li>
The only way to add new entries is to directly construct the ExpenseTag instances and save them (either directly or via a helper method). You can’t make any modifications via the HasManyThrough trait
</li>
<li>
Although the field is defined as a query, the field is actually lazy and only runs once. That means if you query it and then add some new ExpenseTag instances, they won’t show up in the field contents
</li>

</ul>
<div class="Unindented">
If you want a way to retrieve the joined results such that it pulls fresh from the database each time, you can instead define a helper join method as shown in Section<a class="Reference" href="#sub:helper-joins">8.1.11 on page 1↓</a>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.1.5">8.1.5</a> Indexing
</h3>
<div class="Unindented">
It’s often helpful to add indexes to a database to improve performance. Mapper makes it easy to do most simple indexing simply by overriding the <tt>dbIndexed_?</tt> <a class="IndexReference" name="entry-dbIndexed_?-0" href="#index-dbIndexed_?">↓</a> def on the field. Listing <a class="Reference" href="#lst:Indexing-a-field">8.1.5↓</a> shows how we would add an index to our <tt>Expense.account</tt> field.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Indexing a Field<a class="Label" name="lst:Indexing-a-field"> </a>
</div>
<pre class="listing brush: scala">class Expense ... {
  object account extends ... {
    override def dbIndexed_? = true
  }
}
</pre>
</div>

</div>
<div class="Indented">
Mapper provides for more complex indexing via the <tt>MetaMapper.dbIndexes</tt> def combined with the <tt>Index</tt>, <tt>IndexField</tt> and <tt>BoundedIndexField</tt> case classes. Listing <a class="Reference" href="#lst:More-complex-indices">8.1.5↓</a> shows some examples of how we might create more complex indices.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
More Complex Indices<a class="Label" name="lst:More-complex-indices"> </a>
</div>
<pre class="listing brush: scala">object Expense extends ... {
  // equivalent to the previous listing
  override dbIndexes = Index(IndexField(account)) :: Nil
  // equivalent to "create index ... on transaction_t (account, description(10))"
  override dbIndexes = Index(IndexField(account), 
                             BoundedIndexField(description,10))
}
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.1.6">8.1.6</a> Schema Mapping<a class="Label" name="sub:Schema-Mapping"> </a>
</h3>
<div class="Unindented">
The Mapper framework makes it easy not only to define domain objects, but also to create the database schema to go along with those objects. The <tt>Schemifier</tt><a class="IndexReference" name="entry-Schemifier-0" href="#index-Schemifier">↓</a> object is what does all of the work for you: you simply pass in the <tt>MetaMapper</tt> objects that you want the schema created for and it does the rest. Listing <a class="Reference" href="#lst:Using-Schemifier">8.1.6↓</a> shows how we could use <tt>Schemifier</tt> to set up the database for our example objects. The first argument controls whether an actual write will be performed on the database. If false, <tt>Schemifier</tt> will log all of the DDL statements that it would like to apply, but no changes will be made to the database. The second argument is a logging function (logging is covered in Appendix <a class="Reference" href="#cha:Logging-in-Lift">E↓</a>). The remaining arguments are the <tt>MetaMapper</tt> objects that you would like to have schemified. You need to be careful to remember to include all of the objects, otherwise the tables won’t be created.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using Schemifier<a class="Label" name="lst:Using-Schemifier"> </a>
</div>
<pre class="listing brush: scala">Schemifier.schemify(true, Log.infoF _, User, Expense, Account, Tag, ExpenseTag)
</pre>
</div>

</div>
<div class="Indented">
As we mentioned in Section <a class="Reference" href="#sub:Constructing-a-Mapper-enabled-class">8.1.3↑</a>, you can override the default table name for a given Mapper class via the <tt>dbTableName</tt> def in the corresponding MetaMapper. The default table name is the name of the Mapper class, except when the class name is also an SQL reserved word; in this case, a “_t” is appended to the table name. You can also override individual column names on a per-field basis by overriding the <tt>dbColumnName</tt><a class="IndexReference" name="entry-dbColumnName-0" href="#index-dbColumnName">↓</a> def in the field itself. Like tables, the default column name for a field will be the same as the field name as long as it’s not an SQL reserved word; in this case a “_c” is appended to the column name. Listing <a class="Reference" href="#lst:Custom-column-name">8.1.6↓</a> shows how we could make our <tt>ExpenseTag.expense</tt> field map to “expense_id”.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Setting a Custom Column Name<a class="Label" name="lst:Custom-column-name"> </a>
</div>
<pre class="listing brush: scala">class ExpenseTag ... {
  object expense extends ... {
    override def dbColumnName = "expense_id"
  }
}
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.1.7">8.1.7</a> Persistence Operations on an Entity<a class="Label" name="sub:Persistence-Operations-on-entity"> </a>
</h3>
<div class="Unindented">
Now that we’ve defined our entity we probably want to use it in the real world to load and store data. There are several operations on <tt>MetaMapper</tt> that we can use :
</div>
<div class="Description">
<span class="Description-entry">create</span> Creates a new instance of the entity
</div>
<div class="Description">
<span class="Description-entry">save</span> Saves an instance to the database.
</div>
<div class="Description">
<span class="Description-entry">delete</span> Deletes the given entity instance
</div>
<div class="Description">
<span class="Description-entry">count</span> Returns the number of instances of the given entity. An optional query criteria list can be used to narrow the entities being counted
</div>
<div class="Description">
<span class="Description-entry">countByInsecureSQL</span> Similar to count, except a raw SQL string can be used to perform the count. The count value is expected to be in the first column and row of the returned result set. An example would be
</div>
<ul>
<li class="nested">
<pre class="LyX-Code">
Expense.countByInsecureSQL(“select count(amount) “ +
  “from Expense where amount &gt; 20”, ...)
</pre>
<div class="Unindented">
We’ll cover the <tt>IHaveValidatedThisSQL</tt> parameter in a moment.
</div>

</li>

</ul>
<div class="Unindented">
There are also quite a few methods available for retrieving instances from the database. Each of these methods comes in two varieties: one that uses the default database connection, and one that allows you to specify the connection<a class="IndexReference" name="entry-Mapper-multiple-databases-0" href="#index-Mapper-multiple-databases">↓</a> to use (Section <a class="Reference" href="#lst:Multi-database-Connection-Manager">8.3.1 on page 1↓</a>). The latter typically has “DB” appended to the method name. The query methods on <tt>MetaMapper</tt> are:
</div>
<div class="Description">
<span class="Description-entry">findAll</span> Retrieves a list of instances from the database. The method is overloaded to take an optional set of query criteria parameters; these will be covered in detail in their own section, <a class="Reference" href="#sub:Querying-for-Entities">8.1.8↓</a>.
</div>
<div class="Description">
<span class="Description-entry">findAllByInsecureSQL</span> Retrieves a list of instances based on a raw SQL query. The query needs to return columns for all mapped fields. Usually you can use the <tt>BySQL</tt> QueryParameter to cover most of the same functionality.
</div>
<div class="Description">
<span class="Description-entry">findAllByPreparedStatement</span> Similar to <tt>findAllByInsecureSQL</tt> except that prepared statements are used, which usually means that the driver will handle properly escaping arguments in the query string.
</div>
<div class="Description">
<span class="Description-entry">findAllFields</span> This allows you to do a normal query returning only certain fields from your Mapper instance. For example, if you only wanted the amount from the transaction table you would use this method. Note that any fields that aren’t specified in the query will return their default value. Generally, this method is only useful for read access to data because saving any retrieved instances could overwrite real data.
</div>
<div class="Description">
<span class="Description-entry">findMap*</span> These methods provide the same functionality as the non-Map methods, but take an extra function argument that transforms an entity into a <tt>Box[T]</tt>, where <tt>T</tt> is an arbitrary type. An example would be getting a list of descriptions of our transactions:
</div>
<ul>
<li class="nested">
<pre class="LyX-Code">
Expense.findMap(entry =&gt; Full(entry.description.is))
</pre>

</li>

</ul>
<div class="Unindented">
The <tt>KeyedMapperClass</tt> adds the <tt>find</tt> method, which can be used to locate a single entity based on its primary key. In general these operations will be supported in both Record and Mapper. However, because Record isn’t coupled tightly to a JDBC backend some of the find methods may not be supported directly and there may be additional methods not available in Mapper for persistence. For this reason, this section will deal specifically with Mapper’s persistence operations.
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--1"></a>Creating an Instance
</h4>
<div class="Unindented">
Once we have a <tt>MetaMapper</tt> object defined we can use it to create objects using the <tt>create<a class="IndexReference" name="entry-create-0" href="#index-create">↓</a></tt> method. You generally don’t want to use the “new” operator because the framework has to set up internal data for the instance such as field owner, etc. This is important to remember, since nothing will prevent you from creating an instance manually: you may just get errors when you go to use the instance. The <tt>join</tt> method in Listing <a class="Reference" href="#lst:Join-Entity">8.1.4↑</a> shows an example of create usage.
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--2"></a>Saving an Instance
</h4>
<div class="Unindented">
Saving an instance is as easy as calling the <tt>save</tt> method on the instance you want to save. Optionally, you can call the <tt>save</tt> method on the Meta object, passing in the instance you want to save. The <tt>save</tt> method uses the the <tt>saved_?</tt> and <tt>clean_?</tt> flags to determine whether an insert or update is required to persist the current state to the database, and returns a boolean to indicate whether the save was successful or not. The <tt>join</tt> method in Listing <a class="Reference" href="#lst:Join-Entity">8.1.4↑</a> shows an example of <tt>save</tt> usage.
</div>
<h4 class="Subsubsection-">
<a class="toc" name="toc-Subsubsection--3"></a>Deleting an Instance<a class="Label" name="sub:Deleting-an-Instance"> </a>
</h4>
<div class="Unindented">
There are several ways to delete instances. The simplest way is to call the <tt>delete_!</tt> method on the instance you’d like to remove. An alternative is to call the <tt>delete_!</tt> method on the Meta object, passing in the instance to delete. In either case, the <tt>delete_!</tt> method returns a boolean indicating whether the delete was successful or not. Listing <a class="Reference" href="#lst:Example-deletion">3 on page 1↓</a> shows an example of deleting instances.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Example Deletion<a class="Label" name="lst:Example-deletion"> </a>
</div>
<pre class="listing brush: scala">if (! myExpense.delete_!) S.error("Couldn’t delete the expense!")
//or
if (! (Expense delete_! myExpense)) S.error(...)
</pre>
</div>

</div>
<div class="Indented">
Another approach to deleting entities is to use the <tt>bulkDelete_!!</tt> method on <tt>MetaMapper</tt>. This method allows you to specify query parameters to control which entities are deleted. We will cover query parameters in Section <a class="Reference" href="#sub:Querying-for-Entities">8.1.8↓</a> (an example is in Listing <a class="Reference" href="#lst:Bulk-Deletion">8.1.9 on page 1↓</a>).
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.1.8">8.1.8</a> Querying for Entities<a class="Label" name="sub:Querying-for-Entities"> </a>
</h3>
<div class="Unindented">
There are a variety of methods on <tt>MetaMapper</tt> for querying for instances of a given entity. The simplest method is <tt>findAll</tt><a class="IndexReference" name="entry-findAll-0" href="#index-findAll">↓</a> called with no parameters. The “bare” <tt>findAll</tt> returns a <tt>List</tt> of all of the instances of a given entity loaded from the database. Note that each <tt>findAll...</tt> method has a corresponding method that takes a database connection for sharding or multiple database usage (see sharding in Section <a class="Reference" href="#sub:Multiple-Databases">8.3.1↓</a>). Of course, for all but the smallest datasets, pulling the entire model to get one entity from the database is inefficient and slow. Instead, the <tt>MetaMapper</tt> provides “flag” objects to control the query. 
</div>
<div class="Indented">
The ability to use fine-grained queries to select data is a fundamental feature of relational databases, and Mapper provides first-class support for constructing queries in a manner that is not only easy to use, but type-safe. This means that you can catch query errors at compile time instead of runtime. The basis for this functionality is the <tt>QueryParam</tt> trait, which has several concrete implementations that are used to construct the actual query. The <tt>QueryParam</tt> implementations can be broken up into two main groups:
</div>
<ol>
<li>
Comparison - These are typically items that would go in the where clause of an SQL query. They are used to refine the set of instances that will be returned
</li>
<li>
Control - These are items that control things like sort order and pagination of the results
</li>

</ol>
<div class="Unindented">
Although Mapper provides a large amount of the functionality in SQL, some features are not covered directly or at all. In some cases we can define helper methods to make querying easier, particularly for joins (Section <a class="Reference" href="#sub:helper-joins">8.1.11↓</a>).
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.1.9">8.1.9</a> Comparison QueryParams
</h3>
<div class="Unindented">
The simplest <tt>QueryParam</tt> to refine your query is the <tt>By</tt><a class="IndexReference" name="entry-By-0" href="#index-By">↓</a> object and its related objects. <tt>By</tt> is used for a direct value comparison of a given field: essentially an “=” in SQL. For instance, Listing <a class="Reference" href="#lst:Retrieving-by-account">8.1.9↓</a> shows how we can get all of the expenses for a given account.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Retrieving by Account ID<a class="Label" name="lst:Retrieving-by-account"> </a>
</div>
<pre class="listing brush: scala">val myEntries = Expense.findAll(By(Expense.account, myAccount.id))
</pre>
</div>

</div>
<div class="Indented">
Note that our By criterion is comparing the <tt>Expense.account</tt> field to the primary key (<tt>id</tt> field) of our account instead of to the account instance itself. This is because the <tt>Expense.account</tt> field is a <tt>MappedForeignKey</tt> field, which uses the type of the key instead of the type of the entity as its underlying value. In this instance, that means that any queries using <tt>Expense.account</tt> need to use a <tt>Long</tt> to match the underlying type. Besides <tt>By</tt>, the other basic clauses are:
</div>
<ul>
<li>
<tt>NotBy</tt><a class="IndexReference" name="entry-NotBy-0" href="#index-NotBy">↓</a> - Selects entities whose queried field is not equal to the given value
</li>
<li>
<tt>By_&gt;</tt><a class="IndexReference" name="entry-By_&gt;-0" href="#index-By_&gt;">↓</a>- Selects entities whose queried field is larger than the given value
</li>
<li>
<tt>By_&lt;</tt><a class="IndexReference" name="entry-By_&lt;-0" href="#index-By_&lt;">↓</a>- Selects entities whose queried field is less than the given value
</li>
<li>
<tt>ByList</tt><a class="IndexReference" name="entry-ByList-0" href="#index-ByList">↓</a> - Selects entities whose queried field is equal to one of the values in the given List. This corresponds to the “field IN (x,y,z)” syntax in SQL.
</li>
<li>
<tt>NullRef</tt><a class="IndexReference" name="entry-NullRef-0" href="#index-NullRef">↓</a> - Selects entities whose queried field is NULL
</li>
<li>
<tt>NotNullRef</tt><a class="IndexReference" name="entry-NotNullRef-0" href="#index-NotNullRef">↓</a> - Select entities whose queried field is not NULL
</li>
<li>
<tt>Like</tt><a class="IndexReference" name="entry-Like-0" href="#index-Like">↓</a> - Select entities whose queried field is like the given string. As in SQL, the percent sign is used as a wildcard
</li>

</ul>
<div class="Unindented">
In addition to the basic clauses there are some slightly more complex ways to control the query. The first of these is <tt>ByRef</tt><a class="IndexReference" name="entry-ByRef-0" href="#index-ByRef">↓</a>, which selects entities whose queried field is equal to the value of another query field <i>on the same entity</i>. A contrived example would be if we define a tree structure in our table and root nodes are marked as having themselves as parents:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
An Example of ByRef<a class="Label" name="lst:An-example-of-byref"> </a>
</div>
<pre class="listing brush: scala">// select all root nodes from the forest
TreeNode.findAll(ByRef(TreeNode.parent,TreeNode.id))
</pre>
</div>

</div>
<div class="Indented">
The related <tt>NotByRef</tt> tests for inequality between two query fields.
</div>
<div class="Indented">
Getting slightly more complex, we come to the <tt>In</tt><a class="IndexReference" name="entry-In-0" href="#index-In">↓</a> <tt>QueryParameter</tt>, which is used just like an “IN” clause with a subselect in an SQL statement. For example, let’s say we wanted to get all of the entries that belong to tags that start with the letter “c”. Listing <a class="Reference" href="#lst:Using-In">8.1.9↓</a> shows the full breakdown.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using In<a class="Label" name="lst:Using-In"> </a>
</div>
<pre class="listing brush: scala">val cExpenses = 
  ExpenseTag.findAll(
    In(ExpenseTag.tag,
       Tag.id,
       Like(Tag.name, "c%"))).map(_.expense.obj.open_!).removeDuplicates
</pre>
</div>

</div>
<div class="Indented">
Note that we use the <tt>List.removeDuplicates</tt> method to make sure that the List contains unique entities. This requires overriding the <tt>equals</tt> and <tt>hashCode</tt> methods on the Expense class, which we show in Listing <a class="Reference" href="#lst:Overriding-equalshash-expense">8.1.9↓</a>. In our example we’re using the primary key (<tt>id</tt> field) to define object “identity”.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Overriding <tt>equals</tt> and <tt>hashcode</tt> on the Expense entity<a class="Label" name="lst:Overriding-equalshash-expense"> </a>
</div>
<pre class="listing brush: scala">class Expense ... {
  ...
  override def equals (other : Any) = other match {
    case e : Expense if e.id.is == this.id.is =&gt; true
    case _ =&gt; false
  }
​
  override def hashCode = this.id.is.hashCode
  ...
}
</pre>
</div>

</div>
<div class="Indented">
We use the <tt>ByRef</tt> params to do the join between the many-to-many entity on the query. Related to <tt>In</tt> is <tt>InRaw</tt><a class="IndexReference" name="entry-InRaw-0" href="#index-InRaw">↓</a>, which allows you to specify your own SQL subquery for the “IN” portion of the where clause. Listing <a class="Reference" href="#lst:Using-InRaw">8.1.9↓</a> shows an example of how we could use <tt>InRaw</tt> to find <tt>Tags</tt> for expense entries made in the last 30 days.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using InRaw<a class="Label" name="lst:Using-InRaw"> </a>
</div>
<pre class="listing brush: scala">def recentTags = {
  val joins = ExpenseTag.findAll(
    InRaw(ExpenseTag.expense,
          "select id from Expense where dateOf &gt; (CURRENT_DATE - interval ’30 days’)",
          IHaveValidatedThisSQL("dchenbecker", "2008-12-03"))
  joins.map(_.expense.obj.open_!).removeDuplicates
}
</pre>
</div>

</div>
<div class="Indented">
Here things are starting to get a little hairy. The <tt>InRaw</tt> only allows us to specify the subquery for the IN clause, so we have to do some postprocessing to get unique results. If you want to do this in the query itself you’ll have to use the <tt>findAllByInsecureSql</tt> or <tt>findAllByPreparedStatement</tt> methods, which are covered later in this section on page number <a class="Reference" href="#sub:SQL-based-queries">1↓</a>. The final parameter for <tt>InRaw</tt>, <tt>IHaveValidatedThisSQL</tt> acts as a code audit mechanism that says that someone has checked the SQL to make sure it’s safe to use. The query fragment is added to the master query as-is: no escaping or other filtering is performed on the string. That means that if you take user input. then you need to be very careful about it or you run the risk of an SQL injection attack on your site.
</div>
<div class="Indented">
The next <tt>QueryParam</tt> we’ll cover is <tt>BySql</tt>, which lets you use a complete SQL fragment that gets put into the where clause. An example of this would be if we want to find all expense entries within the last 30 days, as shown in Listing <a class="Reference" href="#lst:Using-BySql">8.1.9↓</a>. Again, the <tt>IHaveValidatedThisSQL</tt><a class="IndexReference" name="entry-IHaveValidatedThisSQL-0" href="#index-IHaveValidatedThisSQL">↓</a> case class is required as a code audit mechanism to make sure someone has verified that the SQL used is safe.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using BySql<a class="Label" name="lst:Using-BySql"> </a>
</div>
<pre class="listing brush: scala">val recentEntries = Expense.findAll(
  BySql("dateOf &gt; (CURRENT_DATE - interval ’30 days’)",
        IHaveValidatedThisSQL("dchenbecker","2008-12-03"))
</pre>
</div>

</div>
<div class="Indented">
The tradeoff with using <tt>BySql</tt> is that you need to be careful with what you allow into the query string. <tt>BySql</tt> supports parameterized queries as shown in Listing <a class="Reference" href="#lst:Parameterized-BySql">8.1.9↓</a>, so use those if you need to have dynamic queries. Whatever you do, don’t use string concatenation unless you really know what you’re doing.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Parameterized BySql<a class="Label" name="lst:Parameterized-BySql"> </a>
</div>
<pre class="listing brush: scala">val amountRange = Expense.findAll(
  BySql("amount between ? and ?", lowVal, highVal))
</pre>
</div>

</div>
<div class="Indented">
As we mentioned in Section <a class="Reference" href="#sub:Deleting-an-Instance">3 on page 1↑</a>, we can use the query parameters to do bulk deletes in addition to querying for instances. Simply use the <tt>QueryParam</tt> classes to constrain what you want to delete. Obviously, the control params that we’ll cover next make no sense in this context, but the compiler won’t complain. Listing <a class="Reference" href="#lst:Bulk-Deletion">8.1.9↓</a> shows an example of deleting all entries older than a certain date.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Bulk Deletion<a class="Label" name="lst:Bulk-Deletion"> </a>
</div>
<pre class="listing brush: scala">def deleteBefore (date : Date) = 
  Expense.bulkDelete_!!(By_&lt;(Expense.dateOf, date))
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.1.10">8.1.10</a> Control QueryParams<a class="Label" name="sub:Control-QueryParams"> </a>
</h3>
<div class="Unindented">
Now that we’ve covered the selection and comparison <tt>QueryParams</tt>, we can start to look at the control params. The first one that we’ll look at is <tt>OrderBy</tt>. This operates exactly like the order by clause in SQL, and allows you to sort on a given field in either ascending or descending order. Listing <a class="Reference" href="#lst:OrderBy-Clause">8.1.10↓</a> shows an example of ordering our <tt>Expense</tt> entries by amount. The <tt>Ascending</tt> and <tt>Descending</tt> case objects are in the net.liftweb.mapper package. The <tt>OrderBySql</tt> case class operates similarly, except that you provide your own SQL fragment for the ordering, as shown in the example. Again, you need to validate this SQL.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
OrderBy Clause<a class="Label" name="lst:OrderBy-Clause"> </a>
</div>
<pre class="listing brush: scala">val cheapestFirst = 
  Expense.findAll(OrderBy(Expense.amount,Ascending))
// or
val cheapestFirst = 
  Expense.findAll(OrderBySql("amount asc"),
    IHaveValidatedThisSQL("dchenbecker", "2008-12-03"))
</pre>
</div>

</div>
<div class="Indented">
Pagination of results is another feature that people often want to use, and Mapper provides a simple means for controlling it with two more <tt>QueryParam</tt> classes: <tt>StartAt</tt> and <tt>MaxRows</tt>, as shown in Listing <a class="Reference" href="#lst:Pagination-of-Results">8.1.10↓</a>. In this example, we take the offset from a parameter passed to our snippet, with a default of zero.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Pagination of Results<a class="Label" name="lst:Pagination-of-Results"> </a>
</div>
<pre class="listing brush: scala">val offset = S.param("offset").map(_.toLong) openOr 0
Expense.findAll(StartAt(offset), MaxRows(20))
</pre>
</div>

</div>
<div class="Indented">
An important feature of the methods that take <tt>QueryParams</tt> is that they can take multiple params, as shown in this example. A more complex example is shown in Listing <a class="Reference" href="#lst:Multiple-QueryParams">8.1.10↓</a>. In this example, we’re querying with a <tt>Like</tt> clause, sorting on the date of the entries, and paginating the results, all in one statement!
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Multiple QueryParams<a class="Label" name="lst:Multiple-QueryParams"> </a>
</div>
<pre class="listing brush: scala">Expense.findAll(Like(Expense.description, "Gift for%"),
                OrderBy(Expense.dateOf,Descending),
                StartAt(offset),
                MaxRows(pageSize))
</pre>
</div>

</div>
<div class="Indented">
Another useful <tt>QueryParam</tt> is the <tt>Distinct</tt> case class, which acts exactly the same way as the DISTINCT keyword in SQL. One caveat is that Mapper doesn’t support explicit joins, so this restricts the situations in which you can use <tt>Distinct</tt>. The final “control” <tt>QueryParam</tt> that we’ll cover is <tt>PreCache</tt><a class="IndexReference" name="entry-PreCache-0" href="#index-PreCache">↓</a>. It’s used when you have a mapped foreign key field on an entity. Normally, when Mapper loads your main entity it leaves the foreign key field in a lazy state, so that the query to get the foreign object isn’t executed until you access the field. This can obviously be inefficient when you have many entities loaded that you need to access, so the <tt>PreCache</tt> parameter forces Mapper to preload the foreign objects as part of the query. Listing <a class="Reference" href="#lst:Using-PreCache">8.1.10↓</a> shows how we can use <tt>PreCache</tt> to fetch an <tt>Expense</tt> entry as well as the account for the entry.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using PreCache<a class="Label" name="lst:Using-PreCache"> </a>
</div>
<pre class="listing brush: scala">def loadExpensePlusAccount (id : Long) =
  Expense.findAll(By(Expense.id, id),
                    PreCache(Expense.account))
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.1.11">8.1.11</a> Making Joins a Little Friendlier<a class="Label" name="sub:helper-joins"> </a>
</h3>
<div class="Unindented">
If you prefer to keep your queries type-safe, but you want a little more convenience in your joins between entities, you can define helper methods on your entities. One example is finding all of the tags for a given <tt>Expense</tt>, as shown in Listing <a class="Reference" href="#lst:Join-Convenience-Method">1↓</a>. Using this method in our example has an advantage over using <tt>HasManyThrough</tt>: <tt>hasManyThrough</tt> is a lazy value that will only retrieve data from the database once per request. Using a <tt>findAll</tt> will retrieve data from the database every time. This may be important if you add data to the database during a request, or if you expect things to change between queries.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Join Convenience Method<a class="Label" name="lst:Join-Convenience-Method"> </a>
</div>
<pre class="listing brush: scala">def tags = 
  ExpenseTag.findAll(By(ExpenseTag.expense, this.id)).map(_.tag.obj.open_!)
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-8.2">8.2</a> Utility Functionality
</h2>
<div class="Unindented">
In addition to the first-class persistence support in Mapper and Record, the frameworks provide additional functionality to make writing data-driven applications much simpler. This includes things such as automatic XHTML representation of objects and support for generating everything from simple forms for an individual entity to a full-fledged CRUD<span class="FootOuter"><span class="SupFootMarker"> [D] </span><span class="HoverFoot"><span class="SupFootMarker"> [D] </span>An acronym (Create, Read, Update and Delete) representing the standard operations that are performed on database records. Taken from <a class="FlexURL" href="http://provost.uiowa.edu/maui/Glossary.html">http://provost.uiowa.edu/maui/Glossary.html</a>.</span></span> implementation for your entities.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.2.1">8.2.1</a> Display Generation
</h3>
<div class="Unindented">
If you want to display a Mapper instance as XHTML, simply call the <tt>asHtml</tt> method (<tt>toXHtml</tt> in Record) on your instance. The default implementation turns each field’s value into a <tt>Text</tt> node via the <tt>toString</tt> method and concatenates the results separated by newlines. If you want to change this behavior, override the <tt>asHtml</tt> on your field definitions. For example, if we wanted to control formatting on our <tt>dateOf</tt> field, we could modify the field as shown in Listing <a class="Reference" href="#lst:Custom-field-display">8.2.1↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Custom Field Display<a class="Label" name="lst:Custom-field-display"> </a>
</div>
<pre class="listing brush: scala">import _root_.java.text.DateFormat
...
object dateOf extends MappedDateTime(this) {
  final val dateFormat = 
    DateFormat.getDateInstance(DateFormat.SHORT)
  override def asHtml = Text(dateFormat.format(is))
}
</pre>
</div>

</div>
<div class="Indented">
Note that in Record, <tt>dateOf</tt> contains a <tt>java.util.Calendar</tt> instance and not a<br/>
 <tt>java.util.Date</tt>, so we would need to use the <tt>getTime</tt> method on the value. Two similar methods, <tt>asJSON</tt> and <tt>asJs</tt>, will return the JSON and JavaScript object representation of the instance, respectively. 
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.2.2">8.2.2</a> Form Generation<a class="Label" name="sub:Form-generation"> </a><a class="IndexReference" name="entry-Forms-0" href="#index-Forms">↓</a>
</h3>
<div class="Unindented">
One of the biggest pieces of functionality in the Mapper framework is the ability to generate entry forms for a given record. The <tt>toForm<a class="IndexReference" name="entry-toForm-0" href="#index-toForm">↓</a></tt> method on Mapper is overloaded so that you can control how your form is created. All three <tt>toForm</tt> methods on Mapper take a <tt>Box[String]</tt> as their first parameter to control the submit button; if the Box is Empty, no submit button is generated, otherwise, the String contents of the Box are used as the button label. If you opt to skip the submit button you’ll need to provide it yourself via binding or some other mechanism, or you can rely on implicit form submission (when the user hits enter in a text field, for instance). The first <tt>toForm</tt> method simply takes a function to process the submitted form and returns the XHTML as shown in Listing <a class="Reference" href="#lst:Default-toForm-method">8.2.2↓</a>:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Default toForm Method<a class="Label" name="lst:Default-toForm-method"> </a>
</div>
<pre class="listing brush: scala">myEntry.toForm(Full("Save"), { _.save })
</pre>
</div>

</div>
<div class="Indented">
As you can see, this makes it very easy to generate a form for editing an entity. The second <tt>toForm</tt> method allows you to provide a URL which the Mapper will redirect to if validation succeeds on form submission (this is not provided in Record). This can be used for something like a login form, as shown in Listing <a class="Reference" href="#lst:Custom-form-redirect">8.2.2↓</a>:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Custom Submit Button<a class="Label" name="lst:Custom-form-redirect"> </a>
</div>
<pre class="listing brush: scala">myEntry.toForm (Full("Login"), "/member/profile")
</pre>
</div>

</div>
<div class="Indented">
The third form of the toForm method is similar to the first form, with the addition of “redo” snippet parameter. This allows you to keep the current state of the snippet when validation fails so that the user doesn’t have to re-enter all of the data in the form.
</div>
<div class="Indented">
The Record framework allows for a little more flexibility in controlling form output. The MetaRecord object allows you to change the default template<a class="IndexReference" name="entry-Override-form-template-0" href="#index-Override-form-template">↓</a> that the form uses by setting the formTemplate<a class="IndexReference" name="entry-formTemplate-0" href="#index-formTemplate">↓</a> var. The template may contain any XHTML you want, but the <tt>toForm</tt> method will provide special handling for the following tags:
</div>
<div class="Description">
<span class="Description-entry">&lt;lift:field_label name=“...” /&gt;</span> The label for the field with the given name will be rendered here.
</div>
<div class="Description">
<span class="Description-entry">&lt;lift:field name=“...” /&gt;</span> The field itself (specified by the given name) will be rendered here. Typically this will be an input field, although it can be anything type-appropriate. For example, a BooleanField would render a checkbox.
</div>
<div class="Description">
<span class="Description-entry">&lt;lift:field_msg name=“...” /&gt;</span> Any messages, such as from validation, for the field with the given name will be rendered here.
</div>
<div class="Unindented">
As an example, if we wanted to use tables to lay out the form for our ledger entry, the row for the description field might look like that in Listing <a class="Reference" href="#lst:Custom-form-template">8.2.2↓</a>:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Custom Form Template<a class="Label" name="lst:Custom-form-template"> </a>
</div>
<pre class="listing brush: xml">&lt;!-- Example description field row for Record’s toForm method --&gt;
&lt;tr&gt;
  &lt;th&gt;&lt;lift:field_label name="description" /&gt;&lt;/th&gt;
  &lt;td&gt;&lt;lift:field name="description" /&gt; 
      &lt;lift:field_msg name="description" /&gt;&lt;/td&gt;
&lt;/tr&gt;
</pre>
</div>

</div>
<div class="Indented">
Technically, the <tt>field_msg</tt> binding looks up Lift messages (Chapter <a class="Reference" href="#cha:Message-Handling">B↓</a>) based on the field’s <tt>uniqueId</tt>, so you can set your own messages outside of validation using the S.{error, notice, warning} methods as shown in Listing <a class="Reference" href="#lst:Setting-messages-via-S">8.2.2↓</a>:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Setting Messages via S<a class="Label" name="lst:Setting-messages-via-S"> </a>
</div>
<pre class="listing brush: scala">S.warning(myEntry.amount.uniqueFieldId, 
          "You have entered a negative amount!")
S.warning("amount_id", "This is brittle")
</pre>
</div>

</div>
<div class="Indented">
For most purposes, though, using the validation mechanism discussed in the next section is the appropriate way to handle error checking and reporting.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.2.3">8.2.3</a> Validation<a class="Label" name="sub:Mapper-Validation"> </a><a class="IndexReference" name="entry-Validation-0" href="#index-Validation">↓</a>
</h3>
<div class="Unindented">
Validation is the process of checking a field during form processing to make sure that the submitted value meets requirements. This can be something as simple as ensuring that a value was submitted, or as complex as comparing multiple field values together. Validation is achieved via a <tt>List</tt> of functions on a field that take the field value as input and return a <tt>List[FieldError]</tt> (<tt>Box[Node]</tt> in Record). To indicate that validation succeeded, simply return an empty List, otherwise the list of <tt>FieldErrors</tt> you return are used as the failure messages to be presented to the user. A <tt>FieldError</tt> is simply a case class that associates an error message with a particular field. As an example, let’s say we don’t want someone to be able to add an <tt>Expense</tt> entry for a date in the future. First, we need to define a function for our <tt>dateOf</tt> field that takes a <tt>Date</tt> as an input (For Record, <tt>java.util.Calendar</tt><a class="IndexReference" name="entry-Calendar-0" href="#index-Calendar">↓</a>, not <tt>Date</tt>, is the actual value type of <tt>DateTimeField</tt>) and returns the proper <tt>List</tt>. We show a simple function in Listing <a class="Reference" href="#lst:Date-validation">8.2.3↓</a>. In the method, we simply check to see if the millisecond count is greater than “now” and return an error message if so.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Date Validation<a class="Label" name="lst:Date-validation"> </a>
</div>
<pre class="listing brush: scala">import _root_.java.util.Date
​
class Expense extends LongKeyedMapper[Expense] with IdPK {
  ...
  object dateOf extends MappedDateTime(this) {
    def noFutureDates (time : Date) = {
      if (time.getTime &gt; System.currentTimeMillis) {
        List(FieldError(this, "You cannot make future expense entries"))
      } else {
        List[FieldError]()
      }
    }
  }
  ...
}
</pre>
</div>

</div>
<div class="Indented">
The first argument for the FieldError is the field itself, so you could use the alternate definition shown in Listing <a class="Reference" href="#lst:Alternate-Date-Validation">8.2.3↓</a> if you would prefer to define your validation functions elsewhere (if they’re common to more than one entity, for example).
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Alternate Date Validation<a class="Label" name="lst:Alternate-Date-Validation"> </a>
</div>
<pre class="listing brush: scala">import _root_.java.util.Date
import _root_.net.liftweb.http.FieldIdentifier
​
object ValidationMethods {
  def noFutureDates (field : FieldIdentifier)(time : Date) = {
    if (time.getTime &gt; System.currentTimeMillis) {
      List(FieldError(field, "You cannot make future expense entries"))
    } else {
      List[FieldError]()
    }
  }
  ...
}
</pre>
</div>

</div>
<div class="Indented">
The next step is to tie the validation into the field itself. We do this by slightly modifying our field definition for <tt>date</tt> to set our list of validators as shown in Listing <a class="Reference" href="#lst:Setting-validators">8.2.3↓</a>:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Setting Validators<a class="Label" name="lst:Setting-validators"> </a>
</div>
object dateOf extends MappedDateTime(this) {<pre class="listing brush: scala">  def noFutureDates (time : Date) = { ... }
  override def validations = noFutureDates _ :: Nil
}
​
// Using the alternate definition:
object dateOf extends MappedDateTime(this) {
  override def validations = ValidationMethods.noFutureDates(dateOf) _ :: Nil
}
</pre>
</div>

</div>
<div class="Indented">
Note that we need to add the underscore for each validation function to be partially applied on the submitted value. When our form is submitted, all of the validators for each field are run, and if all of them return Empty then validation succeeds. If any validators return a Full Box, then the contents of the Box are displayed as error messages to the user.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.2.4">8.2.4</a> CRUD Support
</h3>
<div class="Unindented">
Adding CRUD support to your Mapper classes is very simple. We just mix in the <tt><br/>
net.liftweb.mapper.CRUDify</tt> trait to our meta object and it provides a full set of add, edit, list, delete and view pages automatically. Listing <a class="Reference" href="#lst:Mixing-in-CRUDify">8.2.4↓</a> shows our <tt>Expense</tt> meta object with <tt>CRUDify</tt> mixed in.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Mixing in CRUDify<a class="Label" name="lst:Mixing-in-CRUDify"> </a>
</div>
<pre class="listing brush: scala">object Expense extends Expense LongKeyedMetaMapper[Expense] 
    with CRUDify[Long,Expense] {
  ... normal def here ...
  // disable delete functionality
  override def deleteMenuLoc = Empty
}
</pre>
</div>

</div>
<div class="Indented">
The CRUDify behavior is very flexible, and you can control the templates for pages or whether pages are shown at all (as we do in our example) by overriding defs that are provided on the CRUDify trait. In our example Listing <a class="Reference" href="#lst:Mixing-in-CRUDify">8.2.4↑</a>, we disable the delete menu by overriding the<br/>
 <tt>deleteMenuLoc</tt> method to return <tt>Empty</tt>. As an added bonus, CRUDify automatically creates a set of menus for SiteMap (Chapter <a class="Reference" href="#cha:SiteMap">7↑</a>) that we can use by appending them onto the rest of our menus as shown in Listing <a class="Reference" href="#lst:Using-CRUDify-Menus">8.2.4↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using CRUDify Menus<a class="Label" name="lst:Using-CRUDify-Menus"> </a>
</div>
<pre class="listing brush: scala">class Boot {
  def boot {
    ...
    val menus = ... Menu(Loc(...)) :: Expense.menus
    LiftRules.setSiteMap(SiteMap(menus : _*))
  }
}
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.2.5">8.2.5</a> Lifecycle Callbacks
</h3>
<div class="Unindented">
Mapper and Record provide for a set of callbacks that allow you to perform actions at various points during the lifecycle of a given instance. If you want to define your own handling for one of the lifecycle events, all you need to do is override and define the callback because <tt>MetaMapper</tt> already extends the <tt>LifecycleCallbacks</tt> trait. Note that there is a separate <tt>LifecycleCallbacks</tt> trait in each of the record and mapper packages, so make sure that you import the correct one. For example, if we want to notify a Comet actor whenever a new <tt>Expense</tt> entry is saved, we can change our <tt>Expense</tt> class as shown in Listing <a class="Reference" href="#lst:Lifecycle-Callbacks">8.2.5↓</a>:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Lifecycle Callbacks<a class="Label" name="lst:Lifecycle-Callbacks"> </a>
</div>
<pre class="listing brush: scala">object Expense extends LongKeyedMapper[Expense] with LifecycleCallbacks {
  ...
  override def afterSave { myCometActor ! this }
}
</pre>
</div>

</div>
<div class="Indented">
The lifecycle hooks are executed at the main operations in an instance lifecycle:
</div>
<div class="Description">
<span class="Description-entry">Create</span> When a fresh instance is first saved (corresponding to a table insert).
</div>
<div class="Description">
<span class="Description-entry">Delete</span> When an instance is deleted.
</div>
<div class="Description">
<span class="Description-entry">Save</span> When a new or existing instance is inserted or updated. <tt>beforeSave</tt> is always called before <tt>beforeCreate</tt> or <tt>beforeUpdate</tt>. Similarly, <tt>afterSave</tt> is always called after <tt>afterCreate</tt> or <tt>afterUpdate</tt>.
</div>
<div class="Description">
<span class="Description-entry">Update</span> When an instance that already exists in the database is updated (corresponding to a table update).
</div>
<div class="Description">
<span class="Description-entry">Validation</span> When form validation occurs.
</div>
<div class="Unindented">
For each of these points you can execute your code before or after the operation is run.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.2.6">8.2.6</a> Base Field Types
</h3>
<div class="Unindented">
The Record and Mapper frameworks define several basic field types. The following table shows the corresponding types between Mapper and Record, as well as a brief description of each type.
</div>
<div class="Indented">
<table>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedBinary
</td>
<td align="center" valign="top">
BinaryField
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a byte array. You must provide your own overrides for toForm and asXHtml/asHtml for input and display
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedBirthYear
</td>
<td align="center" valign="top">
N/A
</td>
<td align="left" valign="top" style="width: 3.5in;">
Holds an Int that represents a birth year. The constructor takes a minAge parameter that is used for validation
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedBoolean
</td>
<td align="center" valign="top">
BooleanField
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a Boolean value. The default form representation is a checkbox
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedCountry
</td>
<td align="center" valign="top">
CountryField
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a choice from an enumeration of country phone codes as provided by the net.liftweb.mapper.Countries.I18NCountry class. The default form representation is a select
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedDateTime
</td>
<td align="center" valign="top">
DateTimeField
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a timestamp (java.util.Calender for Record, java.util.Date for Mapper). The default form representation is a text input
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedDouble
</td>
<td align="center" valign="top">
DoubleField
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a Double value
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedEmail
</td>
<td align="center" valign="top">
EmailField
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents an email address with a maximum length
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedEnum
</td>
<td align="center" valign="top">
EnumField
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a choice from a given scala.Enumeration. The default form representation is a select
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedEnumList
</td>
<td align="center" valign="top">
N/A
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a choice of multiple Enumerations. The default form representation is a set of checkboxes, one for each enum value
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedFakeClob
</td>
<td align="center" valign="top">
N/A
</td>
<td align="left" valign="top" style="width: 3.5in;">
Fakes a CLOB value (really stores String bytes to a BINARY column)
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedGender
</td>
<td align="center" valign="top">
N/A
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a Gender enumeration. Display values are localized via the I18NGenders object. Internationalization is covered in appendix <a class="Reference" href="#cha:Internationalization">D↓</a> 
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedInt
</td>
<td align="center" valign="top">
IntField
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents an Int value
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedIntIndex
</td>
<td align="center" valign="top">
N/A
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents an indexed Int field (typically a primary key). In Record this is achieved with the KeyField trait
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedLocale
</td>
<td align="center" valign="top">
LocaleField
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a locale as selected from the java.util.Locale.getAvailableLocales method. The default form representation is a select
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedLong
</td>
<td align="center" valign="top">
LongField
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a Long value
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedLongForeignKey
</td>
<td align="center" valign="top">
N/A
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a mapping to another entity via the other entities Long primary key. This functionality in Record is not yet supported
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedLongIndex
</td>
<td align="center" valign="top">
N/A
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents an indexed Long field (typically a primary key). In Record this is achieved with the KeyField trait
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedPassword
</td>
<td align="center" valign="top">
PasswordField
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a password string. The default form representation is a password input (obscured text)
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedPoliteString
</td>
<td align="center" valign="top">
N/A
</td>
<td align="left" valign="top" style="width: 3.5in;">
Just like MappedString, but the default value is an empty string and the input is automatically truncated to fit the database column size
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedPostalCode
</td>
<td align="center" valign="top">
PostalCodeField
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a validated postal code string. The field takes a reference to a MappedCountry (CountryField in Record) at definition and validates the input string against the selected country’s postal code format
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedString
</td>
<td align="center" valign="top">
StringField
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a string value with a maximum length and optional default value
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedStringForeignKey
</td>
<td align="center" valign="top">
N/A
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a mapping to another entity via the other entities String primary key. This functionality in Record is not yet supported
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedStringIndex
</td>
<td align="center" valign="top">
N/A
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents an indexed String field (typically a primary key). In Record this is achieved with the KeyField trait
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedText
</td>
<td align="center" valign="top">
N/A
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a String field that stores to a CLOB column in the database. This can be used for large volumes of text.
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedTextarea
</td>
<td align="center" valign="top">
TextAreaField
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a String field that will use an HTML textarea element for its form display. When you define the field you can override the textareaCols and textareaRows defs to control the dimensions of the textarea.
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedTimeZone
</td>
<td align="center" valign="top">
TimeZoneField
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a time zone selected from java.util.TimeZone.getAvailableIDs. The default form representation is a select
</td>

</tr>
<tr>
<td align="center" valign="top" style="width: 1.5in;">
MappedUniqueId
</td>
<td align="center" valign="top">
N/A
</td>
<td align="left" valign="top" style="width: 3.5in;">
Represents a unique string of a specified length that is randomly generated. The implementation doesn’t allow the user to write new values to the field. This can be thought of as a GUID
</td>

</tr>

</table>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.2.7">8.2.7</a> Defining Custom Field Types in Mapper<a class="Label" name="sub:Defining-Custom-Field-types-mapper"> </a>
</h3>
<div class="Unindented">
The basic <tt>MappedField</tt> types cover a wide range of needs, but sometimes you may find yourself wanting to use a specific type. In our example, we would like a decimal value for our expense amount and account balance. Using a double would be inappropriate due to imprecision and rounding errors<span class="FootOuter"><span class="SupFootMarker"> [E] </span><span class="HoverFoot"><span class="SupFootMarker"> [E] </span><a class="FlexURL" href="http://stephan.reposita.org/archives/2008/01/11/once-and-for-all-do-not-use-double-for-money/">http://stephan.reposita.org/archives/2008/01/11/once-and-for-all-do-not-use-double-for-money/</a></span></span>, so instead we base it on <tt>scala.BigDecimal</tt>. We’re going to provide an abridged version of the code that will end up in the Lift library. Feel free to examine the source to see the constructors and methods that we’ve omitted<span class="FootOuter"><span class="SupFootMarker"> [F] </span><span class="HoverFoot"><span class="SupFootMarker"> [F] </span>The code is checked into the master branch of the liftweb Git repository.</span></span>. Our first task is to specify the class signature and constructors, as shown in Listing <a class="Reference" href="#lst:MappedDecimal-constructors">8.2.7↓</a>. Note that the <tt>BigDecimal</tt> we’re using here is <tt>scala.BigDecimal</tt>, not <tt>java.math.BigDecimal</tt>. We’ll cover how we make this work with JDBC (which doesn’t support scala.BigDecimal) in a moment.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
MappedDecimal Constructors<a class="Label" name="lst:MappedDecimal-constructors"> </a>
</div>
<pre class="listing brush: scala">import _root_.java.math.{MathContext, RoundingMode}
​
class MappedDecimal[T &lt;: Mapper[T]] (val fieldOwner : T,
                                     val context : MathContext,
                                     val scale : Int) extends MappedField[BigDecimal,T] {
  // ... constructor taking initial value ...
  def this(fieldOwner : T, value : BigDecimal, context: MathContext) = {
    this(fieldOwner, context, value.scale)
    setAll(value) // we’ll cover this later in this section
  }
​
  def this(fieldOwner : T, value : BigDecimal) = {
    this(fieldOwner, MathContext.UNLIMITED, value.scale)
    setAll(value)
  }
</pre>
</div>

</div>
<div class="Indented">
The first part of the class definition is the type signature; basically the type <tt>[T &lt;: MappedField[T]]</tt> indicates that whatever type “owns” this field must be a Mapper subclass (&lt;: specifies an upper type bound<span class="FootOuter"><span class="SupFootMarker"> [G] </span><span class="HoverFoot"><span class="SupFootMarker"> [G] </span>For more on type bounds, see <a class="URL" href="http://www.scala-lang.org/node/136">http://www.scala-lang.org/node/136</a>.</span></span>). With our primary constructor we specify the owner mapper as well as the <tt>MathContext</tt> (this controls rounding and precision, or the total number of digits) and scale of the decimal value. The scale in <tt>BigDecimal</tt> essentially represents the number of digits to the right of the decimal point. In addition, we specify ancillary constructors to take an initial value with or without and explicit <tt>MathContext</tt>.
</div>
<div class="Indented">
Now that we have the constructors in place, there are several abstract methods on <tt>MappedField</tt> that we need to define. The first of these is a method to provide a default value. The default value is used for uninitialized fields or if validation fails. We also need to specify the class for our value type by implementing the <tt>dbFieldClass</tt> method. Listing <a class="Reference" href="#lst:Setting-a-default-value">8.2.7↓</a> shows both of these methods. In our case, we default to a zero value, with the scale set as specified in the contructor. Note that <tt>BigDecimal</tt> instances are generally immutable, so the <tt>setScale</tt> method returns a new instance. We also provide the vars and methods that handle the before and after values of the field. These values are used to handle persistence state. If you change the value of the field, then the original value is held until the instance is saved to the database. The <tt>st</tt> method is used internally to set the value of the field when instances are “rehydrated” from the database.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Setting a Default Value<a class="Label" name="lst:Setting-a-default-value"> </a>
</div>
<pre class="listing brush: scala">  private val zero = BigDecimal("0") 
  def defaultValue = zero.setScale(scale)
  def dbFieldClass = classOf[BigDecimal]
​
  // The data and orgData variables are used so that
  // we know when the field has been modified by the user
  private var data : BigDecimal = defaultValue
  private var orgData : BigDecimal = defaultValue
  private def st (in : BigDecimal) {
    data = in
    orgData = in
  }
  
  // The i_is_! and i_was_! methods are used internally to
  // keep track of when the field value is changed. In our 
  // instance they delegate directly to the data and orgData 
  // variables
  protected def i_is_! = data
  protected def i_was_! = orgData
  override def doneWithSave() {
    orgData = data
  }
</pre>
</div>

</div>
<div class="Indented">
The next set of methods we need to provide deal with when and how we can access the data. Listing <a class="Reference" href="#lst:Access-Control">8.2.7↓</a> shows the overrides that set the read and write permissions to true (default to false for both) as well as the <tt>i_obscure_!</tt> and <tt>real_i_set_!</tt> methods. The <tt>i_obscure_!</tt> method returns the a value that is used when the user doesn’t have read permissions. The <tt>real_i_set_!</tt> method is what actually stores the internal value and sets the dirty flag when the field is updated.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Access Control<a class="Label" name="lst:Access-Control"> </a>
</div>
<pre class="listing brush: scala">  override def readPermission_? = true
  override def writePermission_? = true
  protected def i_obscure_!(in : BigDecimal) = defaultValue
  protected def real_i_set_!(value : BigDecimal): BigDecimal = {
    if (value != data) {
      data = value
      dirty_?(true)
    }
    data
  }
</pre>
</div>

</div>
<div class="Indented">
The next two methods that we need to provide deal with actually setting the value of the field. The first is <tt>setFromAny</tt>, which takes an <tt>Any</tt> parameter and must convert it into a <tt>BigDecimal</tt>. The second, <tt>setFromString</tt> is a subset of <tt>setFromAny</tt> in that it takes a <tt>String</tt> parameter and must return a <tt>BigDecimal</tt>. Our implementation of these two methods is shown in Listing <a class="Reference" href="#lst:setFrom...-Methods">8.2.7↓</a>. We’ve also added a <tt>setAll</tt> and <tt>coerce</tt> method so that we have a common place to properly set scale and rounding modes on the value of the field. 
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
setFrom... Methods<a class="Label" name="lst:setFrom...-Methods"> </a>
</div>
<pre class="listing brush: scala">  def setFromAny (in : Any) : BigDecimal =
    in match {
      case bd : BigDecimal =&gt; setAll(bd)
      case n :: _ =&gt; setFromString(n.toString)
      case Some(n) =&gt; setFromString(n.toString)
      case Full(n) =&gt; setFromString(n.toString)
      case None | Empty | Failure(_, _, _) | null =&gt; setFromString("0")
      case n =&gt; setFromString(n.toString)
    }
​
  def setFromString (in : String) : BigDecimal = {
    this.setAll(BigDecimal(in))
  }
​
  protected def setAll (in : BigDecimal) = set(coerce(in))
​
  // Make a separate method for properly adjusting scale and rounding.
  // We’ll use this method later in the class as well.
  protected coerce (in : BigDecimal) = 
    new BigDecimal(in.bigDecimal.setScale(scale, context.getRoundingMode))
</pre>
</div>

</div>
<div class="Indented">
Our implementations are relatively straightforward. The only special handling we need for <tt>setFromAny</tt> is to properly deal with <tt>Lists</tt>, <tt>Boxes</tt>, <tt>Options</tt> and the <tt>null</tt> value. The <tt>BigDecimal</tt> constructor takes Strings, so the <tt>setFromString</tt> method is easy. The only addition we make over the <tt>BigDecimal</tt> constructor is to properly set the scale and rounding on the returned value. 
</div>
<div class="Indented">
Our final step is to define the database-specific methods for our field, as shown in Listing <a class="Reference" href="#lst:Database-Specific-Methods">8.2.7↓</a>. The first method we implement is <tt>targetSQLType</tt>. This method tells Mapper what the corresponding SQL type is for our database column. The <tt>jdbcFriendly</tt> method returns a value that can be used in a JDBC statement. Here’s where we need to use the <tt>bigDecimal</tt> val on our <tt>scala.BigDecimal</tt> to obtain the real <tt>java.math.BigDecimal</tt> instance. Similarly, the <tt>real_convertToJDBCFriendly</tt> method needs to return a java <tt>BigDecimal</tt> for a given <tt>scala.BigDecimal</tt> input. The <tt>buildSet...</tt> methods return functions that can be used to set the value of our field based on different input types. These are essentially conversion functions that are used by Lift to convert data retrieved in a <tt>ResultSet</tt> into actual field values. Finally, the <tt>fieldCreatorString</tt> specifices what we would need in a CREATE TABLE statement to define this column. In this instance, we need to take into account the precision and scale. We use default precision if we’re set to unlimited, but it’s important to understand that actual precision for the default DECIMAL type varies between RDBMS vendors.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Database-Specific Methods<a class="Label" name="lst:Database-Specific-Methods"> </a>
</div>
<pre class="listing brush: scala">def targetSQLType = Types.DECIMAL
def jdbcFriendly(field : String) = i_is_!.bigDecimal
def real_convertToJDBCFriendly(value: BigDecimal): Object = value.bigDecimal
​
// The following methods are used internally by Lift to
// process values retrieved from the database. 
​
// We don’t convert from Boolean values to a BigDecimal, so this returns null
def buildSetBooleanValue(accessor : Method, columnName : String) : 
  (T, Boolean, Boolean) =&gt; Unit = null
​
// Convert from a Date to a BigDecimal. Our assumption here is that we can take
// The milliseconds value of the Date.
def buildSetDateValue(accessor : Method, columnName : String) : 
    (T, Date) =&gt; Unit =
  (inst, v) =&gt; 
    doField(inst, accessor,{
      case f: MappedDecimal[T] =&gt; 
        f.st(if (v == null) defaultValue else coerce(BigDecimal(v.getTime)))
    })
​
// Convert from a String to a BigDecimal. Since the BigDecimal object can
// directly convert a String, we just pass the String directly.
def buildSetStringValue(accessor: Method, columnName: String) : 
    (T, String) =&gt; Unit =
  (inst, v) =&gt; 
    doField(inst, accessor,{
      case f: MappedDecimal[T] =&gt; 
        f.st(coerce(BigDecimal(v)))
    })
​
// Convert from a Long to a BigDecimal. This is slightly more complex than 
// for a String, since we need to check for null values.
def buildSetLongValue(accessor: Method, columnName : String) : 
    (T, Long, Boolean) =&gt; Unit = 
  (inst, v, isNull) =&gt; 
    doField(inst, accessor, {
      case f: MappedDecimal[T] =&gt; 
        f.st(if (isNull) defaultValue else coerce(BigDecimal(v)))
    })
​
// Convert from an AnyRef (Object). We simply use the String value 
// of the input here.
def buildSetActualValue(accessor: Method, data: AnyRef, columnName: String) : 
    (T, AnyRef) =&gt; Unit =
  (inst, v) =&gt; 
    doField(inst, accessor, {
      case f: MappedDecimal[T] =&gt; f.st(coerce(BigDecimal(v.toString)))
    })
​
def fieldCreatorString(dbType: DriverType, colName: String): String = {
  val suffix = if (context.getPrecision == 0) "" else {
    "(" + context.getPrecision + "," + scale + ")"
  }
  colName + " DECIMAL" + suffix
}
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.2.8">8.2.8</a> ProtoUser and MegaProtoUser<a class="Label" name="sub:ProtoUser-and-MegaProtoUser"> </a>
</h3>
<div class="Unindented">
In addition to all of the database-related features, Mapper contains an extra goody to help you quickly set up small sites. <tt>ProtoUser</tt> and <tt>MegaProtoUser</tt> are two built-in traits that define a simple user account. The <tt>ProtoUser</tt> trait defines some basic fields for a user: <tt>email</tt>, <tt>firstName</tt>, <tt>lastName</tt>, <tt>password</tt> and <tt>superUser</tt> (a boolean to provide basic permissions). There are also a number of defs used to format the fields for display or to provide form labels. Listing <a class="Reference" href="#lst:A-simple-ProtoUser">8.2.8↓</a> shows an example of a ProtoUser-based Mapper class that overrides some of the formatting defs.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Simple ProtoUser<a class="Label" name="lst:A-simple-ProtoUser"> </a>
</div>
<pre class="listing brush: scala">class User extends ProtoUser[User] {
  override def shortName = firstName.is
  override lastNameDisplayName = "surname"
}
</pre>
</div>

</div>
<div class="Indented">
The <tt>MegaProtoUser</tt> trait, as its name implies, extends the <tt>ProtoUser</tt> trait with a whole suite of functionality. The main thrust of <tt>MegaProtoUser</tt> (and its associated meta object,<br/>
 <tt>MetaMegaProtoUser</tt>) is to automatically handle all of the scaffolding for a complete user management system, with:
</div>
<ul>
<li>
A user registration page with configurable validation via email
</li>
<li>
A login page that automatically handles authentication
</li>
<li>
A lost password page that does reset via email
</li>
<li>
A change password page
</li>
<li>
A user edit page
</li>
<li>
A simple method to generate SiteMap menus for all of these pages
</li>

</ul>
<div class="Unindented">
Of course, you can customize any of these by overriding the associated methods on the MetaMegaProtoUser object. Listing <a class="Reference" href="#lst:PocketChange-User-entity">2.1 on page 1↑</a> shows an example of sprucing up the signup and login pages by overriding the <tt>loginXHtml</tt> and <tt>signupXHtml</tt> methods. Listing <a class="Reference" href="#lst:Hooking-MetaMegaProtoUser-into-Boot">8.2.8↓</a> shows how easy it is to then hook the MetaMegaProtoUser menus into SiteMap.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Hooking MetaMegaProtoUser into Boot<a class="Label" name="lst:Hooking-MetaMegaProtoUser-into-Boot"> </a>
</div>
<pre class="listing brush: scala">// in Boot.scala
LiftRules.setSiteMap(SiteMap((... :: User.sitemap) :_*))
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-8.3">8.3</a> Advanced Features
</h2>
<div class="Unindented">
In this section we’ll cover some of the advanced features of Mapper
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.3.1">8.3.1</a> Using Multiple Databases <a class="Label" name="sub:Multiple-Databases"> </a><a class="IndexReference" name="entry-Mapper-multiple-databases-1" href="#index-Mapper-multiple-databases">↓</a>
</h3>
<div class="Unindented">
It’s common for an application to need to access data in more than one database. Lift supports this feature through the use of overrides on your MetaMapper classes. First, we need to define the identifiers for the various databases using the <tt>ConnectionIdentifier</tt> trait and overriding the <tt>jndiName</tt> def. Lift comes with one pre-made: <tt>DefaultConnectionIdentifier</tt>. It’s jndiName is set to “lift”, so it’s recommended that you use something else. Let’s say we have two databases: sales and employees. Listing <a class="Reference" href="#lst:Defining-Connection-Identifiers">8.3.1↓</a> shows how we would define the <tt>ConnectionIdentifier</tt> objects for these.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Defining Connection Identifiers<a class="Label" name="lst:Defining-Connection-Identifiers"> </a>
</div>
<pre class="listing brush: scala">object SalesDB extends ConnectionIdentifier {
  def jndiName = "sales"
}
​
object EmployeeDB extends ConnectionIdentifier {
  def jndiName = "employees"
}
</pre>
</div>

</div>
<div class="Indented">
Simple enough. Now, we need to create connection managers for each one, or we can combine the functionality into a single manager. To keep things clean we’ll use a single manager, as shown in Listing <a class="Reference" href="#lst:Multi-database-Connection-Manager">8.3.1↓</a>. Scala’s match operator allows us to easily return the correct connection.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Multi-database Connection Manager<a class="Label" name="lst:Multi-database-Connection-Manager"> </a>
</div>
<pre class="listing brush: scala">object DBVendor extends ConnectionManager {
  Class.forName("org.postgresql.Driver")
 
  def newConnection(name : ConnectionIdentifier) = {
    try {
      name match {
        case SalesDB =&gt;
          Full(DriverManager.getConnection(
            "jdbc:postgresql://localhost/sales",
            "root", "secret"))
        case EmployeeDB =&gt;
          Full(DriverManager.getConnection(
            "jdbc:postgresql://server/employees",
            "root", "hidden"))
    } catch {
      case e : Exception =&gt; e.printStackTrace; Empty
    }
  }
  def releaseConnection (conn : Connection) { conn.close }
}
</pre>
</div>

</div>
<div class="Indented">
Now that we’ve defined our connection identifiers, we need to be able to use them in our <tt>Mapper</tt> instances. There are several ways to do this. The first (simplest) way is to override the <tt>dbDefaultConnectionIdentifier</tt> method on your <tt>MetaMapper</tt> object, as shown in Listing <a class="Reference" href="#lst:Defining-the-Default-connid">8.3.1↓</a>. In this example we’re setting the <tt>MetaMapper</tt> to always use the <tt>EmployeeDB</tt> connection for all persistence operations.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Defining the Default Connection Identifier<a class="Label" name="lst:Defining-the-Default-connid"> </a>
</div>
<pre class="listing brush: scala">object EmployeeMeta extends Employee with LongKeyedMetaMapper[Employee] {
  ...
  override def dbDefaultConnectionIdentifier = EmployeeDB
  ...
}
</pre>
</div>

</div>
<div class="Indented">
The second way to utilize more than one DB is to use the “DB” version of the persistence methods, as we mentioned in Section <a class="Reference" href="#sub:Persistence-Operations-on-entity">8.1.7↑</a>. Listing <a class="Reference" href="#lst:Using-a-Connection-id-direct">8.3.1↓</a> shows how we can perform a <tt>findAll</tt> with a specific connection.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using a Connection Identifier Directly<a class="Label" name="lst:Using-a-Connection-id-direct"> </a>
</div>
<pre class="listing brush: scala">val employees = EmployeeMeta.findAllDb(EmployeeDB)
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.3.2">8.3.2</a> Database Sharding
</h3>
<div class="Unindented">
A special case of using multiple databases is <i>sharding</i><span class="FootOuter"><span class="SupFootMarker"> [H] </span><span class="HoverFoot"><span class="SupFootMarker"> [H] </span>For more information on sharding, see this article: <a class="FlexURL" href="http://highscalability.com/unorthodox-approach-database-design-coming-shard">http://highscalability.com/unorthodox-approach-database-design-coming-shard</a></span></span>. Sharding is a means to scale your database capacity by associating entities with one database instance out of a federation of servers based on some property of the entity. For instance, we could distribute user entites across 3 database servers by using the first character of the last name: A-H goes to server 1, I-P goes to server 2, and Q-Z goes to server 3. As simple as this sounds, there are some important factors to remember:
</div>
<ul>
<li>
Sharding increases the complexity of your code.
</li>
<li>
To get the most benefit out of sharding, you need to carefully choose and tune your “selector.” If you’re not careful, you can get an uneven distribution where some servers handle significantly more load than others, defeating the purpose of sharding. The example we’ve given here of using the last name is, in practice, a very poor choice. We recommend reading <a class="URL" href="http://startuplessonslearned.blogspot.com/2009/01/sharding-for-startups.html">http://startuplessonslearned.blogspot.com/2009/01/sharding-for-startups.html</a> for a good overview of the pros and cons of various selector strategies.
</li>
<li>
When you use sharding, you can’t just use normal joins anymore because the data isn’t all within one instance. This means more work on your part to properly retrieve and associate data
</li>

</ul>
<div class="Unindented">
Mapper provides a handy feature for sharding that allows you to choose which database connection you want to use for a specific entity. There are two methods we can use to control the behavior: <tt>dbSelectDBConnectionForFind</tt> and <tt>dbCalculateConnectionIdentifier</tt>. dbSelect... is used to find an instance by primary key, and takes a partial function (typically a match clause) to determine which connection to use. dbCalculate... is used when a new instance is created to decide where to store the new instance. As an example, say we’ve defined two database connections, SalesA and SalesB. We want to place new instances in SalesA if the amount is &gt; $100 and SalesB otherwise. Listing <a class="Reference" href="#lst:Sharding-in-Action">8.3.2↓</a> shows our method in action.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Sharding in Action<a class="Label" name="lst:Sharding-in-Action"> </a>
</div>
<pre class="listing brush: scala">class Expense extends LongKeyedMapper[Expense] {
  ... fields, etc ...
​
  override def dbCalculateConnectionIdentifier = {
    case n if n.amount.is &gt; 100 =&gt; SalesA
    case _ =&gt; SalesB
  }
}
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-8.3.3">8.3.3</a> SQL-based Queries<a class="Label" name="sub:SQL-based-queries"> </a>
</h3>
<div class="Unindented">
If, despite all that Mapper covers, you find yourself still wanting more control over the query, there are two more options available to you: <tt>findAllByPreparedStatement</tt> and <tt>findAllByInsecureSql</tt>. The <tt>findAllByPreparedStatement</tt> method allows you to, in essence, construct your query completely by hand. The added benefit of using a <tt>PreparedStatement</tt><span class="FootOuter"><span class="SupFootMarker"> [I] </span><span class="HoverFoot"><span class="SupFootMarker"> [I] </span><a class="FlexURL" href="http://java.sun.com/javase/6/docs/api/java/sql/PreparedStatement.html">http://java.sun.com/javase/6/docs/api/java/sql/PreparedStatement.html</a></span></span> means that you can easily include user-defined data in your queries. The <tt>findAllByPreparedStatement</tt> method takes a single function parameter. This function takes a <tt>SuperConnection</tt><span class="FootOuter"><span class="SupFootMarker"> [J] </span><span class="HoverFoot"><span class="SupFootMarker"> [J] </span>Essentially a thin wrapper on java.sql.Connection, <a class="FlexURL" href="http://scala-tools.org/mvnsites/liftweb/lift-webkit/scaladocs/net/liftweb/mapper/SuperConnection.html">http://scala-tools.org/mvnsites/liftweb/lift-webkit/scaladocs/net/liftweb/mapper/SuperConnection.html</a></span></span> and returns a<br/>
 <tt>PreparedStatement</tt> instance. Listing <a class="Reference" href="#lst:Using-findAllByPreparedStatement">8.3.3↓</a> shows our previous example in which we looked up all <tt>Tag</tt>s for recent <tt>Expense</tt> entries, but here using <tt>findAllByPreparedStatement</tt> instead. The query that you provide must at least return the fields that are mapped by your entity, but you can return other columns as well (they’ll just be ignored), so you may choose to do a “select *” if you prefer.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using findAllByPreparedStatement<a class="Label" name="lst:Using-findAllByPreparedStatement"> </a>
</div>
<pre class="listing brush: scala">def recentTags = Tag.findAllByPreparedStatement({ superconn =&gt;
  superconn.connection.prepareStatement(
    "select distinct Expense.id, Tag.name" +
    "from Tag" +
    "join ExpenseTag et on Tag.id = et.tag " +
    "join Expense ex on ex.id = et.expense " +
    "where ex.dateOf &gt; (CURRENT_DATE - interval ’30 days’)")
})
</pre>
</div>

</div>
<div class="Indented">
The <tt>findAllByInsecureSql</tt> method goes even further, executing the string you submit directly as a statement without any checks. The same general rules apply as for<br/>
 <tt>findAllByPreparedStatement</tt>, although you need to add the <tt>IHaveValidatedThisSQL</tt> parameter as a code audit check. In either case, the ability to use full SQL queries can allow you to do some very powerful things, but it comes at the cost of losing type safety and possibly making your app non-portable.
</div>
<div class="Indented">
As a last resort, Mapper provides support for non-entity SQL queries through a few methods on the DB object. The first method we’ll look at is <tt>DB.runQuery</tt>. This method allows you to provide a full SQL query string, and is overloaded to take a parameterized query. It returns a <tt>Pair[List[String],List[List[String]]</tt>, with the first <tt>List[String]</tt> containing all of the column names and the second <tt>List</tt> corresponding to each row in the result set. For example, let’s say we wanted to compute the sums of each tag for a given account. Listing <a class="Reference" href="#lst:Using-DB.runQuery">8.3.3↓</a> shows how we could accomplish this using a parameterized query against the database. 
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using DB.runQuery<a class="Label" name="lst:Using-DB.runQuery"> </a>
</div>
<pre class="listing brush: scala">DB.runQuery("select Tag.name, sum(amount) from Expense ex " +
            "join ExpenseTag et on et.expense = ex.id " +
            "join Tag on et.tag = Tag.id " +
            "join Account on Account.id = ex.account " +
            "where Account.id = ? group by Tag.name order by Tag.name",
            myAccount.id)
// might return:
(List("tag", "sum"]),
 List(List("food","42.00"),
      List("home","75.49"),
      List("work","2.00")))
</pre>
</div>

</div>
<div class="Indented">
If you need full control over the query and full access to the result set, DB provides some low-level utility methods. The most basic is <tt>DB.use</tt>, which takes a connection identifier as well as a function that takes a <tt>SuperConnection</tt> (a thin wrapper on JDBC’s connection). This forms a loan pattern<span class="FootOuter"><span class="SupFootMarker"> [K] </span><span class="HoverFoot"><span class="SupFootMarker"> [K] </span><a class="URL" href="http://scala.sygneca.com/patterns/loan">http://scala.sygneca.com/patterns/loan</a></span></span> that lets Mapper deal with all of the connection open and release details. The <tt>DB.exec</tt> method takes a provided connection and executes an arbitrary SQL statement on it, then applies a provided function to the result set. Similarly, the <tt>DB.prepareStatement</tt> method allows you to create a prepared statement and then apply a function to it. You can combine these methods to run any arbitrary SQL, as shown in Listing <a class="Reference" href="#lst:Using-DB.use">8.3.3↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using DB.use<a class="Label" name="lst:Using-DB.use"> </a>
</div>
<pre class="listing brush: scala">// recompute an account balance from all of the transactions
DB.use(DefaultConnectionIdentifier) { conn =&gt;
  val balance = 
    // Should use a prepared statement here. This is for example only
    DB.exec(conn, 
      "select sum(ex.amount) from Expense ex where ex.account = " 
      + myAccount.id) {
      rs =&gt; 
       if (!rs.next) BigDecimal(0) 
       else (new BigDecimal(rs.getBigDecimal(1)))
    }
  DB.prepareStatement("update Account set balance = ? where Account.id = ", 
                      conn) { stmt =&gt;
    stmt.setBigDecimal(1, balance.bigDecimal)
    stmt.setLong(2, resetAccount.id)
    stmt.executeUpdate()
  }
}
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-8.4">8.4</a> Logging
</h2>
<div class="Unindented">
Logging with Mapper is covered in detail in Section <a class="Reference" href="#sec:Logging-Mapper-Queries">E.4 on page 1↓</a>.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-8.5">8.5</a> Summary 
</h2>
<div class="Unindented">
In this chapter, we discussed the two major ORMs included in Lift: Mapper and Record. We’ve shown how you can define entities using the Mapper field types and how to coordinate between the entity and its Meta-object. We’ve shown how you can customize the display and schema of your behavior with custom form control, CRUD support, and indexing. And we’ve show you how to query for entities using Mapper’s type-safe query support. Finally, we showed you how you can do in-depth customization of Mapper behavior by writing your own field types, using multiple databases, and using raw SQL queries.
</div>
<h1 class="Part">
<a class="toc" name="toc-Part-II">Part II.</a> Advanced Topics
</h1>
<div class="Unindented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-9">9</a> Advanced Lift Architecture<a class="Label" name="cha:Advanced-Lift-Guts"> </a>
</h1>
<div class="Unindented">
<div class="Framed" style="width: 100%;">
This chapter is still under active development. The contents will change.
</div>

</div>
<div class="Indented">
Congratulations! You’ve either made it through the introduction to Lift, or maybe you’ve just skipped Basics and jumped right to here to Advanced; either way, the next group of chapters will be exciting. 
</div>
<div class="Indented">
In this chapter we’re going to dive into some of the advanced guts of Lift so that you have a thorough understanding of what’s going on before we explore further.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-9.1">9.1</a> Architectural Overview
</h2>
<div class="Unindented">
Before we jump into the specific details of the architecture, let’s refresh our memories. Figure <a class="Reference" href="#fig:Architecture-diagram">9.1↓</a> highlights the main Lift components and where they live in the ecosystem. Scala compiles down to Java bytecode, so we sit on top of the JVM. Lift Applications are typically run in a J(2)EE web container, such as Jetty or Tomcat. As we explained in section <a class="Reference" href="#sec:Entry-into-Lift">3.1↑</a>, Lift is set up to act as a Filter<span class="FootOuter"><span class="SupFootMarker"> [L] </span><span class="HoverFoot"><span class="SupFootMarker"> [L] </span><a class="URL" href="http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/Filter.html">http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/Filter.html</a></span></span> that acts as the entry point. Usage of the rest of the framework varies from application to application, depending on how simple or complex you make it.
</div>
<div class="Indented">
<div class="center">
<div class="float">
<a class="Label" name="fig:Architecture-diagram"> </a><div class="figure">
<div class="caption">
Figure 9.1 Architecture
</div>
<div class="center">
<img class="embedded" src="images/LiftArchDiagram.png" alt="figure images/LiftArchDiagram.png" style="max-width: 612px; max-height: 792px;"/>

</div>

</div>

</div>

</div>

</div>
<div class="Indented">
The major components outlined in the diagram are:
</div>
<div class="Description">
<span class="Description-entry">LiftCore</span> The engine of the framework responsible for request/response lifecycle, rendering pipeline, invoking user’s functions etc. We don’t directly cover the core in this book since essentially all of the functionality that we do cover sits on top of the core
</div>
<div class="Description">
<span class="Description-entry">SiteMap</span> Contains the web pages for a Lift application (chapter<a class="Reference" href="#cha:SiteMap">7↑</a>)
</div>
<div class="Description">
<span class="Description-entry">LiftRules</span> Allows you to configure Lift. We cover this in various sections throughout the book
</div>
<div class="Description">
<span class="Description-entry">LiftSession</span> The session state representation (section <a class="Reference" href="#sec:Session-Management">9.5↓</a>)
</div>
<div class="Description">
<span class="Description-entry">S</span> The stateful object impersonating the state context for a given request/response lifecycle (section <a class="Reference" href="#sub:Advanced-S-Object">9.7↓</a>)
</div>
<div class="Description">
<span class="Description-entry">SHtml</span> Contains helper functions for XHtml artifacts (chapters <a class="Reference" href="#cha:Forms-in-Lift">6↑</a> and <a class="Reference" href="#cha:AJAX-and-COMET">11↓</a>)
</div>
<div class="Description">
<span class="Description-entry">Views</span> LiftView objects impersonating a view as a XML content. Thus pages can be composed from other sources not only from html files. (section <a class="Reference" href="#sec:Views">4.4↑</a>)
</div>
<div class="Description">
<span class="Description-entry">LiftResponse</span> Represents the abstraction of a response that will be propagated to the client. (section <a class="Reference" href="#sec:LiftResponse-in-Detail">9.4↓</a>)
</div>
<div class="Description">
<span class="Description-entry">Comet</span> Represents the Comet Actors layer which allows the sending of asynchronous content to the browser (section <a class="Reference" href="#sec:COMET">11.5↓</a>)
</div>
<div class="Description">
<span class="Description-entry">ORM</span> - Either Mapper or Record - The lightweight ORM library provided by Lift. The Mapper framework is the proposed ORM framework for Lift 1.0 and the Record framework will be out for next releases. (chapter <a class="Reference" href="#cha:mapper_and_record">8↑</a>)
</div>
<div class="Description">
<span class="Description-entry">HTTP Auth</span> - You can use either Basic or Digest HTTP authentication in your Lift application. This provides you more control as opposed to web-container’s HTTP authentication model. (section <a class="Reference" href="#sub:HTTP-Authentication">9.9↓</a>)
</div>
<div class="Description">
<span class="Description-entry">JS API</span> The JavaScript abstraction layer. These are Scala classes/objects that abstract JavaScript artifacts. Such objects can be combined to build JavaScript code (chapter <a class="Reference" href="#cha:Lift-and-Javascript">10↓</a>)
</div>
<div class="Description">
<span class="Description-entry">Utils</span> Contains a number of helper functions that Lift uses internally and are available to your application
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-9.2">9.2</a> The Request/Response Lifecycle<a class="Label" name="sec:Request/Response-Lifecycle"> </a>
</h2>
<div class="Unindented">
We briefly discussed the Request/Response Liftcycle in section <a class="Reference" href="#sec:The-Rendering-Process">3.5↑</a>, and now we’re going to cover it in depth. This will serve not only to familiarize you with the full processing power of Lift, but also to introduce some of the other advanced topics we’ll be discussing in this and later chapters.
</div>
<div class="Indented">
One important thing we’d like to mention is that most of the configurable properties are in <tt>LiftRules</tt>, and are of type <tt>RulesSeq</tt>. With a <tt>RulesSeq</tt> you essentially have a list of functions or values that are applied in order. <tt>RulesSeq</tt> defines a prepend and append method that allows you to add new configuration items at the beginning or end of the configuration, respectively. This allows you to prioritize things like partial functions and compose various methods together to control Lift’s behavior. You can think of a RulesSeq as a Seq on steroids, tweaked for Lift’s usage.
</div>
<div class="Indented">
The following list outlines, in order, the process of transforming a Request into a Response. We provide references to the sections of the book where we discuss each step in case you want to branch off.
</div>
<ol>
<li>
Execute early functions: this is a mechanism that allows a user function to be called on the HttpServletRequest before it enters the normal processing chain. This can be used for, for example, to set the XHTML output to UTF-8. This is controlled through <tt>LiftRules.early</tt>
</li>
<li>
Perform URL Rewriting, which we already covered in detail in section <a class="Reference" href="#sec:URL-Rewriting">3.7↑</a>. Controlled via <tt>LiftRules.rewrite</tt>, this is useful for creating user-friendly URLs, among other things. The result of the transformation will be checked for possible rewrites until there are no more matches or it is explicitly stopped by setting the <tt>stopRewriting</tt> val in ReqwriteResponse to <tt>true</tt>. It is relevant to know that you can have rewriter functions per-session hence you can have different rewriter in different contexts. These session rewriters are prended to the LiftRules rewriters before their application.
</li>
<li>
Call <tt>LiftRules.onBeginServicing</tt> hooks. This is a mechanism that allows you to add your own hook functions that will be called when Lift is starting to process the request. You could set up logging here, for instance.
</li>
<li>
Check for user-defined stateless dispatch in <tt>LiftRules.statelessDispatchTable</tt>. If the partial functions defined in this table match the request then they are used to create a <tt>LiftResponse</tt> that is sent to the user, bypassing any further processing. These are very useful for building things like REST APIs. The term stateless refers to the fact that at the time the dispatch function is called, the stateful object, called <tt>S</tt>, is not available and the <tt>LiftSession</tt> is not created yet. Custom dispatch is covered in section <a class="Reference" href="#sec:Custom-dispatch-func">3.8↑</a>
</li>
<li>
Create a <tt>LiftSession</tt>. The <tt>LiftSession</tt> holds various bits of state for the request, and is covered in more detail in section <a class="Reference" href="#sec:Session-Management">9.5↓</a>.
</li>
<li>
Call <tt>LiftSession.onSetupSession</tt>. This is a mechanism for adding hook functions that will be called when the LiftSession is created. We’ll get into more details when we discuss Lift’s session management in section <a class="Reference" href="#sec:Session-Management">9.5↓</a>.
</li>
<li>
Initialize the <tt>S</tt> object (section <a class="Reference" href="#sub:S-object">3.4.1↑</a>). The <tt>S</tt> object represents the current state of the Request and Response.
</li>
<li>
Call any <tt>LoanWrapper</tt> instances that you’ve added through <tt>S.addAround</tt>. A <tt>LoanWrapper</tt> is a way to insert your own processing into the render pipeline, similar to how Filter works in the Servlet API. This means that when your <tt>LoanWrapper</tt> implementation is called, Lift passes you a function allowing you to chain the processing of the request. With this functionality you can execute your own pre- and post-condition code. A simple example of this would be if you need to make sure that something is configured at the start of processing and cleanly shut down when processing terminates. LoanWrappers are covered in section <a class="Reference" href="#sub:Wrapping-Lift's-processing">9.6.1↓</a>
</li>
<li>
Process the stateful request<ol>
<li>
Check the stateful dispatch functions defined in <tt>LiftRules.dispatch</tt>. This is similar to the stateless dispatch in step #4 except that these functions are executed in the context of a LiftSession and an <tt>S</tt> object (section <a class="Reference" href="#sub:S-object">3.4.1↑</a>). The first matching partial function is used to generate a <tt>LiftResponse</tt> that is returned to the client. If none of the dispatch functions match then processing continues. Dispatch functions are covered in section <a class="Reference" href="#sec:Custom-dispatch-func">3.8↑</a>. This flow is wrapped by LiftSession.onBeginServicing/onEndServicing calls
</li>
<li>
If this is a <b>Comet</b> request, then process it and return the response. Comet is a method for performing asynchronous updates of the user’s page without a reload. We cover Comet techniques in chapter <a class="Reference" href="#cha:AJAX-and-COMET">11↓</a>
</li>
<li>
If this is an <b>Ajax</b> request, execute the user’s callback function; the specific function is mapped via a request parameter (essentially a token). The result of the callback is returned as the response to the user. The response can be a JavaScript snippet, an XML construct or virtually any <tt>LiftResponse</tt>. For an overview of <tt>LiftResponse</tt> please see section <a class="Reference" href="#sec:LiftResponse-in-Detail">9.4↓</a>. This flow is wrapped by LiftSession.onBeginServicing/onEndServicing calls.
</li>
<li>
If this is a regular HTTP request, then:<ol>
<li>
Call <tt>LiftSession.onBeginServicing</tt> hooks. Mostly “onBegin”/”onEnd” functions are used for logging. Note that the <tt>LiftRules</tt> object also has <tt>onBeginServicing</tt> and <tt>onEndServicing</tt> functions but these are “wrapping” more Lift processing and not just statefull processing.
</li>
<li>
Check the user-defined dispatch functions that are set per-session (see <tt>S.addHighLevelSessionDispatcher</tt>). This is similar to <tt>LiftRules.dispatch</tt> except that you can have different functions set up for a different session depending on your application logic. If there is a function applicable, execute it and return its response. If there is no per-session dispatch function, process the request by executing the Scala function that user set up for specific events (such as when clicking a link, or pressing the submit button, or a function that will be executed when a form field is set etc.). Please see SHtml obejct <a class="Reference" href="#sub:SHtml">3.4.2↑</a>.
</li>
<li>
Check the SiteMap and Loc functions. We cover SiteMap extensively in chapter <a class="Reference" href="#cha:SiteMap">7↑</a>.
</li>
<li>
Lookup the template based on the request path. Lift will locate the templates using various approaches:<ol>
<li>
Check the partial functions defined in <tt>LiftRules.viewDispatch</tt>. If there is a function defined for this path invoke it and return an Either[<span class="formula">() ⇒ <i>Can</i>[<i>NodeSeq</i>]</span>,LiftView]. This allows you to either return the function for handling the view directly, or delegate to a <tt>LiftView</tt> subclass. <tt>LiftView</tt> is covered in section <a class="Reference" href="#sec:Views">4.4↑</a>
</li>
<li>
If no viewDispatch functions match, then look for the template using the ServletContext’s <tt>getResourceAsStream</tt>.
</li>
<li>
If Lift still can’t find any templates, it will attempt to locate a View class whose name matches the first component of the request path under the <tt>view</tt> folder of any packages defined by <tt>LiftRules.addToPackages</tt> method. If an <tt>InsecureLiftView</tt> class is found, it will attempt to invoke a function on the class corresponding to the second component of the request path. If a <tt>LiftView</tt> class is found, it will invoke the <tt>dispatch</tt> method on the second component of the request path.
</li>

</ol>

</li>
<li>
Process the templates by executing snippets, combining templates etc.<ol>
<li>
Merge &lt;head&gt; elements, as described in section e<a class="Reference" href="#sec:Head-Merge">↓</a>
</li>
<li>
Update the internal functions map. Basically this associates the user’s Scala functions with tokens that are passed around in subsequent requests using HTTP query parameters. We cover this mechanism in detail in section <a class="Reference" href="#sub:Lift-Function-Mapping">9.3↓</a>
</li>
<li>
Clean up notices (see S.error, S.warning, S.notice) since they were already rendered they are no longer needed. Notices are covered in section <a class="Reference" href="#cha:Message-Handling">B↓</a>.
</li>
<li>
Call <tt>LiftRules.convertResponse</tt>. Basically this glues together different pieces if information such as the actual markup, the response headers, cookies, etc into a LiftResponse instance.
</li>
<li>
Check to see if Lift needs to send HTTP redirect. For an overview please see <a class="Reference" href="#sec:HTTP-redirects">3.9↑</a>
</li>

</ol>

</li>
<li>
Call <tt>LiftSession.onEndServicing</tt> hooks, the counterparts to <tt>LiftSession.onBeginServicing</tt>
</li>

</ol>

</li>
<li>
Call <tt>LiftRules.performTransform</tt>. This is actually configured via the <tt>LiftRules.responseTransformers</tt> <tt>RulesSeq</tt>. This is a list of functions on <span class="formula"><i>LiftResponse</i> ⇒ <i>LiftResponse</i></span> that allows the user to modify the response before it’s sent to the client
</li>

</ol>

</li>
<li>
Call <tt>LiftRules.onEndServicing</tt> hooks. These are the stateless end-servicing hooks, called after the S object context is destroyed.
</li>
<li>
Call any functions defined in <tt>LiftRules.beforeSend</tt>. This is the last place where you can modify the response before it’s sent to the user
</li>
<li>
Convert the <tt>LiftResponse</tt> to a raw byte stream and send it to client as an HTTP response.
</li>
<li>
Call any functions defined in <tt>LiftRules.afterSend</tt>. Typically these would be used for cleanup.
</li>

</ol>
<div class="Unindented">
We realize that this is a lot of information to digest in one pass, so as we continue to cover the specific details of the rendering pipeline you may want to keep a bookmark here so that you can come back and process the new information in the greater context of how Lift is working.
</div>
<div class="Indented">
Tyler Weir has created a set of diagrams on the following two pages that outline Lift’s processing at the global level and also for HTTP requests in particular. For the visually-oriented these may explain things a bit better.<p><br/>
</p>

</div>
<div class="Indented">
<div class="float">
<a class="Label" name="Figure-9.2"> </a><div class="figure">
<div class="center">
<img class="embedded" src="images/lift_request_processing_global.png" alt="figure images/lift_request_processing_global.png" style="width: 7in; max-width: 1186px; height: auto; max-height: 1226px;"/>

</div>
<div class="caption">
Figure 9.2 Lift Global Request Processing
</div>

</div>

</div>

</div>
<div class="Indented">
The “Process HTTP request” step is expanded on the following page.
</div>
<div class="Indented">
<p><br/>
</p>

</div>
<div class="Indented">
<div class="float">
<a class="Label" name="Figure-9.3"> </a><div class="figure">
<div class="center">
<img class="embedded" src="images/lift_request_processing_http.png" alt="figure images/lift_request_processing_http.png" style="width: auto; max-width: 1103px; height: 9in; max-height: 1482px;"/>

</div>
<div class="caption">
Figure 9.3 Lift HTTP Request Processing
</div>

</div>

</div>

</div>
<div class="Indented">
<p><br/>
</p>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-9.3">9.3</a> Lift Function Mapping<a class="Label" name="sub:Lift-Function-Mapping"> </a>
</h2>
<div class="Unindented">
As we mentioned in section <a class="Reference" href="#sec:Form-Fundamentals">6.1↑</a>, lift utilizes scala closures and functions for almost all processing of client data. Because of this, Lift’s ability to associate functions with specific form elements, AJAX calls, etc, is critical to its operation. This association of functions, commonly known as “mapping” is handled through a combination of request parameters, Scala closures and Session data. We feel that understanding how mapping works is important if you want to work on advanced topics.
</div>
<div class="Indented">
At its most basic, mapping of functions is just that; a map of the user’s currently defined functions. To simplify things, Lift actually uses one of four subclasses of AFuncHolder<span class="FootOuter"><span class="SupFootMarker"> [M] </span><span class="HoverFoot"><span class="SupFootMarker"> [M] </span>net.liftweb.http.S.AFuncHolder</span></span>:
</div>
<div class="Description">
<span class="Description-entry">BinFuncHolder</span> used for binding functions for file uploading. It will hold a <span class="formula"><i>FileParamHolder</i> ⇒ <i>Any</i></span> function, which is used to process the file data after upload (section <a class="Reference" href="#sec:File-Uploads">6.4↑</a>)
</div>
<div class="Description">
<span class="Description-entry">SFuncHolder</span> used for binding <span class="formula"><i>String</i> ⇒ <i>Any</i></span> functions. This function corresponds to a single HTTP query parameter, except that the parameter name is <i>unique to this request</i> (we’ll cover naming shortly)
</div>
<div class="Description">
<span class="Description-entry">LFuncHolder</span> used for binding <span class="formula"><i>List</i>[<i>String</i>] ⇒ <i>Any</i></span> functions. This is essentially the same as SFuncHolder but for multiple values
</div>
<div class="Description">
<span class="Description-entry">NFuncHolder</span> used for binding <span class="formula">() ⇒ <i>Any</i></span> functions. Typically these are used for event callabcks (such as form submission)
</div>
<div class="Unindented">
Wherever Lift takes a function callback it is converted to one of these types behind the scenes. Also on the backend, each function is assigned a token ID (generated by <tt>Helpers.nextFuncName</tt>), which is then added to the session, typically via <tt>S.addFunctionMap</tt> or <tt>S.mapFunc</tt>. The token is generally used as the form element name so that the tokens for a given form are passed back to Lift when the form is submitted; in AJAX, the token is used as an HTTP query parameter of the AJAX callback from the client JavaScript code. In either case, Lift processes the query parameters within LiftSession.runParams and executes each associated function in the function mapping.
</div>
<div class="Indented">
As a concrete example, let’s look at a simple binding in a form. Listing <a class="Reference" href="#lst:Function-binding-snippet">9.3↓</a> shows a small example snippet that will request a person’s name and print it out when the person clicks the submit button.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Function binding snippet<a class="Label" name="lst:Function-binding-snippet"> </a>
</div>
<pre class="listing brush: scala">def greet (xhtml : NodeSeq) : NodeSeq = {
  var name = ""
  def process() = {
    println(name)
  }
  bind("form", xhtml, "name" -&gt; SHtml.text(name, name = _),
                      "greet" -&gt; SHtml.submit("Greet", process))
}
</pre>
</div>

</div>
<div class="Indented">
Listing <a class="Reference" href="#lst:Function-binding-template">9.3↓</a> shows the corresponding template using our sample snippet.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Function binding template<a class="Label" name="lst:Function-binding-template"> </a>
</div>
<pre class="listing brush: scala">&lt;lift:surround with="default" at="content"&gt;
  &lt;lift:Test.greet form="GET"&gt;
    &lt;form:name /&gt; &lt;form:greet /&gt;
  &lt;/lift:Test.greet&gt;
&lt;/lift:surround&gt;
</pre>
</div>

</div>
<div class="Indented">
Finally, listing <a class="Reference" href="#lst:Function-binding-result">9.3↓</a> shows an example of the resulting HTML that’s generated when a user views the template. As you can see, each of the elements with callbacks has a corresponding form element with a token ID for the name value. Since we’ve used the GET CGI method here (we usually recommend using POST in the real world), when we submit the form our URL would look like <tt>/greet.html?F541542594358JE2=...&amp;F541542594359PM4=Greet</tt>. For SFuncHolder mappings the value of the request parameter is passed directly. For NFuncHolders the presence of the token in the query parameter list is enough to fire the function. For BinFuncHolder and LFuncHolder mappings some additional processing is performed to coerce the submitted values into proper values for the functions to handle.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Function binding result<a class="Label" name="lst:Function-binding-result"> </a>
</div>
<pre class="listing brush: scala">&lt;form method="get" action="/greet.html"&gt;
  &lt;input name="F541542594358JE2" type="text" value=""/&gt;
  &lt;input name="F541542594359PM4" type="submit" value="Greet"/&gt;
&lt;/form&gt; 
</pre>
</div>

</div>
<div class="Indented">
Normally you do not have to directly deal with the function holder classes, since the generator functions in SHtml handle that internally. However, if you’re in a situation when you need to bind functions by yourself (such as building your own widget where SHtml doesn’t provided needed elements), you can use the previously mentioned <tt>S.addFunctionMap</tt> or <tt>S.mapFunc</tt> to do the “registration” for you.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-9.4">9.4</a> LiftResponse in Detail<a class="Label" name="sec:LiftResponse-in-Detail"> </a>
</h2>
<div class="Unindented">
In some cases, particularly when using dispatch functions (section <a class="Reference" href="#sec:Custom-dispatch-func">3.8↑</a>), you may want explicit control over what Lift returns to the user. The LiftResponse trait is the base of a complete hierarchy of response classes that cover a wide variety of functionality, from simply returning an HTTP status code to returning a byte stream or your own XML fragments. In this section we’ll cover some of the more common classes.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.4.1">9.4.1</a> InMemoryResponse
</h3>
<div class="Unindented">
The <tt>InMemoryResponse</tt> allows you to return an array of bytes directly to the user along with a set of HTTP headers, cookies and a response code. An example of using <tt>InMemoryResponse</tt> was given in section <a class="Reference" href="#sec:Custom-dispatch-func">3.8↑</a>, showing how we can directly generate a chart PNG in memory and send it to the user. This is generally useful as long as the data you need to generate and send is relatively small; when you start getting into larger buffers you can run into memory constraints as well as garbage collection pressure if you’re serving a large number of requests.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.4.2">9.4.2</a> StreamingResponse
</h3>
<div class="Unindented">
The <tt>StreamingResponse</tt> class is similar to the <tt>InMemoryResponse</tt>, except that instead of reading from a buffer, it reads from an input object. The input object is not required to be a subclass of <tt>java.io.InputStream</tt>, but rather is only required to implement the method “def read(buf: Array[Byte]): Int”<span class="FootOuter"><span class="SupFootMarker"> [N] </span><span class="HoverFoot"><span class="SupFootMarker"> [N] </span>This is done with Scala’s structural typing, which we don’t cover in this book. For more info, see <a class="URL" href="http://scala.sygneca.com/patterns/duck-typing-done-right">http://scala.sygneca.com/patterns/duck-typing-done-right</a>, or the Scala Language Spec, section 3.2.7</span></span>. This allows you to essentially send back anything that can provide an input stream. Additionally, you can provide a <span class="formula">() ⇒ <i>Unit</i></span> function (cleanup, if you will) that is called when the input stream is exhausted. As an example, let’s look at how we could stream a file from our WAR back to the client. Listing <a class="Reference" href="#lst:streaming-download">9.4.2↓</a> shows how we can retrieve the input stream from our classloader and then send it directly to the user. Note that you <i>must</i> know the size of the file you’re streaming before sending it.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Streaming download method<a class="Label" name="lst:streaming-download"> </a>
</div>
<pre class="listing brush: scala">def sendFile () : Box[LiftResponse] = {
  // Locate the file and process it
  LiftRules.getResource("/some-file.txt").map { url =&gt;
    val input = url.openStream()
    val filesize = ... // must compute or predetermine this.
    StreamingResponse(inPipe,
                      () =&gt; { input.close },
                      filesize,
                      (Content-Type -&gt; "text/plain") :: Nil,
                      Nil,
                      200)
  }
}
</pre>
</div>

</div>
<div class="Indented">
Note that we use the cleanup function to close the input stream once we’re done so that we make sure to release resources.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.4.3">9.4.3</a> Hierarchy
</h3>
<div class="Unindented">
The Lift framework makes a lot of things really easy and it provides extremly useful abstractions as you may have already discovered. Responses to clients are also abstacted by <tt>LiftResponse</tt> trait. There are numerous response types and here is the simplified view of the class hierarchy:
</div>
<ul>
<li>
LiftResponse<ul>
<li>
BasicResponse<ul>
<li>
InMemoryResponse
</li>
<li>
StreamingResponse
</li>

</ul>

</li>
<li>
JSonResponse
</li>
<li>
RedirectResponse<ul>
<li>
RedirectWithState
</li>

</ul>

</li>
<li>
ToResponse<ul>
<li>
XhtmlRespomse
</li>
<li>
XmlResponse
</li>
<li>
XmlMimeResponse
</li>
<li>
AtomResponse
</li>
<li>
OpenSearchResponse
</li>
<li>
AtomCreatedResponse
</li>
<li>
AtomCategoryResponse
</li>
<li>
AtomServiceResponse
</li>
<li>
CreatedResponse
</li>

</ul>

</li>
<li>
OkResponse
</li>
<li>
PermRedirectResponse
</li>
<li>
BadResponse
</li>
<li>
UnauthorizedResponse
</li>
<li>
UnauthorizedDigestResponse
</li>
<li>
NotFoundResponse
</li>
<li>
MethodNotAllowedResponse
</li>
<li>
GoneResponse
</li>

</ul>

</li>

</ul>
<div class="Unindented">
We won’t get into details right now on what exactly each and every class/object does, although their purpose is given away by their names. It is important to know that whenever you need to return a <tt>LiftResponse</tt> reference from one of your functions, for example <tt>LiftRules.dispatch</tt> you can you can use one of these classes. Lift doesn’t really provide the HttpServletResponse object, instead all responses are impersonated by a <tt>LiftResponse</tt> instance and it content (the actual payload, http headers, content-type, cookies etc.) is written internally by Lift to the container’s output stream.
</div>
<div class="Indented">
Still let’s take a look at a few examples
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.4.4">9.4.4</a> RedirectWithState
</h3>
<div class="Unindented">
<div class="listing">
<div class="caption">
RedirectWithState example
</div>
<pre class="listing brush: scala">// Assume you boot function
import MessageState._
...
​
def boot = { 
​
LiftRules.dispatch.prepend {
  case Req("redirect1" :: _, _, _) =&gt; () =&gt; 
    Full(RedirectWithState("/page1", "My error" -&gt; Error))
  case Req("redirect2" :: _, _, _) =&gt; () =&gt; 
    Full(RedirectWithState("/page2", 
                           RedirectState(() =&gt; println("Called on redirect!"), 
                                         "My error" -&gt; Error)))     
}
​
</pre>
</div>

</div>
<div class="Indented">
First of all we added a DispatchPF function that pattern matches for paths starting with <tt>redirect1</tt> and <tt>redirect2</tt>. Let’s see what happens in each case.
</div>
<ul>
<li>
<tt>redirect1</tt> - We are returning a RedirectWithState response. It will do HTTP redirect towards /page1 and the state is impersonated by the tuple “MyError” -&gt; Error. Because MessageState object holds an implicit conversion function from Tuple2 to MessageState it suffices to just provide the tuple here. Essentially we are saying here that when the browser sends the redirect request to server we already have an Error notice set up and the &lt;lift:msgs&gt; tag from your /page1 will show this “My error” error message.
</li>
<li>
<tt>redirect2</tt> - Similarly it does an HTTP redirect to browser towards your /page2. But we are passing now a RedirectState object. This object holds a () =&gt; Unit function that will be executed when browser send the redirect request and the Notices impersonated by a repeated parameter (String, NoticeType.Value)*. In fact the mapping between the actual message and its type: Notice, Warning or Error.
</li>

</ul>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.4.5">9.4.5</a> XmlResponse
</h3>
<div class="Unindented">
<div class="listing">
<div class="caption">
XmlResponse example
</div>
<pre class="listing brush: scala">// Assume you boot function
​
def boot = { 
​
LiftRules.dispatch.prepend {
  case Req("rest" :: Nil, _, _) =&gt; () =&gt; Full(XmlResponse(
        &lt;persons&gt;
            &lt;name&gt;John&lt;/name&gt;
            &lt;name&gt;Jane&lt;/name&gt;
        &lt;/persons&gt;
    ))
}
​
</pre>
</div>

</div>
<div class="Indented">
When you are receiving a request with the path /rest the code is returning an XML response. The content-type and everything else is taken care of by XmlResponse. You can build much more complex REST API’s an return XML response which is probably mot commonly used.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-9.5">9.5</a> Session Management <a class="Label" name="sec:Session-Management"> </a>
</h2>
<div class="Unindented">
Lift is a stateful framework and naturally this state needs to be managed. You may already be familiar with HttpSession and and how a J(2)EE web container identifies an HttpSession; either by a JSESSIONID cookie or by a JSESSIONID URI sequence (in case of URL rewriting). Similarly, Lift uses a LiftSession reference which is not actually “persisted” in HttpSession. As a matter of fact Lift does not really use the HttpSession provided by the web container to maintain conversational state, but rather uses a bridge between the <tt>HttpSession</tt> and the <tt>LiftSession</tt>. This bridge is impersonated by <tt>SessionToServletBridge</tt> class which implements <i>javax.servlet.http.HttpSessionBindingListener</i> and <i>javax.servlet.http.HttpSessionActivationListener</i> and works like this:
</div>
<ol>
<li>
When receiving an HTTP Request and there was no stateless dispatch function to execute, Lift does the stateful processing. But before doing that it checks to see if there is a <tt>LiftSession</tt> associated with this HTTP session ID. This mapping is kept on a SessionMaster Scala actor. 
</li>
<li>
If there is no associated LiftSession in the SessionMaster actor, create it and add a SessionToServletBridge attribute on HttpSession. This will make Lift aware of the session when the container terminates the HttpSession or when the HTTP session is about to be passivated or activated.
</li>
<li>
When the container terminates the HTTP session, SessionToServletBridge sends a message to the SessionMaster Actor to terminate the LiftSession, which includes the following steps:<ol>
<li>
Call any defined LiftSession.onAboutToShutdownSession hooks
</li>
<li>
Send a ShutDown message to all Comet Actors pertaining to this session
</li>
<li>
Clean up any internal LiftSession state
</li>
<li>
Call LiftSession.onShutdownSession hooks
</li>

</ol>

</li>

</ol>
<div class="Unindented">
The SessionMaster Actor is also protected by another watcher Actor. This watcher Actor receives the Exit messages of the watched Actors. When it receives an Exit message it will call the users’ failure functions and restart the watched actor (Please see ActorWatcher.failureFuncs). 
</div>
<div class="Indented">
Even while Lift is handling session management you still have the ability to manually add attributes to the HttpSession object. We do not recommend this unless you really must. A simpler way to keep your own session variables, is to use <tt>SessionVar</tt>s. For more details about SessionVar please see the fundamental chapter <a class="Reference" href="#sec:Session-and-Request">3.11↑</a>
</div>
<div class="Indented">
The next question would probably be “So we have internal session management, how do we cope with that in a clustered environment? ... how are sessions replicated?” the answer is, they aren’t. There is no intention to use the web container’s session replication as these technologies appears to be inferior to other solutions on the market. Relying on Java serialization brings a lot of performance concerns and alternative technologies have been investigated and they are still under investigation. Until there is a standard session replication technology you can still cluster you application using “sticky session”. This meas that all requests pertaining to a HTTP session must be processed by the same cluster node. This can be done by software or hardware load balancers, as they would dispatch the requests based on JSESSIONID cookie. Another approach is that the dispatching is done based on some URI or query parameters. For example, a query parameter like serverid=1 is configured in the load balancer to always be dispatched to the node 1 of the cluster, and so on. There are some downsides for the sticky session approach. For instance you are logged in the application and do your stuff. Suddenly the node designated to your session crashes. At this moment you lost your session. The next subsequent request would be automatically dispatched by the load balancer to another cluster node and depending how your application is built this may mean that you need to log in again or if part of the state was persisted in DB you may resume your work from some point avoiding re-login ... but this is application specific behavior that is beyond the scope of this discussion. The advantages of sticky sessions are related with application performance since in this model the state does not need to be replicated in all cluster nodes which for significant state information can be quite time/resources consuming.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.5.1">9.5.1</a> Lift garbage collection
</h3>
<div class="Unindented">
As you have seen, Lift tailors Scala functions with client side artifacts (XHTML input elements, Ajax requests etc.). Naturally these functions are kept into the session state. Also for every rendered page, a page ID is generated and functions bound for these pages as asociated with this page ID. In order to prevent accumulation of such mappings, Lift has a mechanism of purging unused functions. Basically the idea is
</div>
<ol>
<li>
On client side, a script periodically sends to the server an Ajax request impersonating a lift GC request. 
</li>
<li>
On service side Lift updates the timestamps of the functions associated with this page ID. The functions older then <tt>LiftRules.unusedFunctionsLifeTime</tt> (default value is 10 minutes) become eligible for garbage collection as they are de-referenced from the current session. The frequency of such Ajax requests is given by <tt>LiftRules.liftGCPollingInterval</tt>. By default it is set to 75 seconds.
</li>
<li>
Each Ajax request contains includes the page ID as new function may be bound as a result of processing the Ajax request, dependin on the application code. Such function that are dynamically bound are automatically associated with the same page ID.
</li>

</ol>
<div class="Unindented">
You can of course turn off this garbage collection mechanism by setting <tt>LiftRules.enableLiftGC = false</tt> typically in your Boot. You can also fine tune the garbage collection mechanims to fit your application needs, by changing the default LiftRules variables.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
LiftRules gabage collection variables
</div>
<pre class="listing brush: scala">/**    
 * By default lift uses a garbage-collection mechanism of removing 
 * unused bound functions from LiftSesssion
 * Setting this to false will disable this mechanims and there will 
 * be no Ajax polling request attempted.    
 */ 
var enableLiftGC = true;
​
/**    
 * If Lift garbage collection is enabled, functions that are not seen 
 * in the page for this period of time (given in milliseonds) will be
 * discarded, hence eligible for garbage collection. The default value
 * is 10 minutes.    
 */   
var unusedFunctionsLifeTime: Long = 10 minutes
​
/**    
 * The polling interval for background Ajax requests to prevent
 * functions of being garbage collected.   
 * Default value is set to 75 seconds.
 */   
var liftGCPollingInterval: Long = 75 seconds
​
/**   
 * The polling interval for background Ajax requests to prevent functions
 * of being garbage collected.  
 * This will be applied if the Ajax request will fail. Default value is
 * set to 15 seconds.  
 */ 
var liftGCFailureRetryTimeout: Long = 15 seconds 
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-9.6">9.6</a> Miscellaneous Lift Features
</h2>
<div class="Unindented">
In this section we will discuss various features that can prove helpful in building rich Lift applications.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.6.1">9.6.1</a> Wrapping Lift’s processing logic<a class="Label" name="sub:Wrapping-Lift's-processing"> </a>
</h3>
<div class="Unindented">
Lift provides the ability to allow user functions to be part of processing lifecycle. In these cases Lift allows you to provide your own functions and the actual Lift’s processing function is passed to your function. Hence your own function is responsible of calling the actual Lift’s processing logic. 
</div>
<div class="Indented">
But let’s see how exactly you can do this.<div class="listing">
<div class="caption">
LoanWrapper example
</div>
<pre class="listing brush: scala"> class Boot {   
  def boot {    
    ...   
    S.addAround(new LoanWrapper { // Y   
      def apply[T](f: =&gt; T): T = {   
        println("Y -&gt; hello to the request!")  
        val result = f // Let Lift do normal request processing.   
        println("Y -&gt; goodbye!")  
        result   
      }   
    })   
    S.addAround(new LoanWrapper { // X   
      def apply[T](f: =&gt; T): T = {   
        println("X -&gt; hello to the request!")   
        val result = f // Let Lift do normal request processing.   
        println("X -&gt; goodbye!")   
        result
      }   
    })   
 }  
​
</pre>
</div>

</div>
<div class="Indented">
The code looks pretty straight-forward in the sense that we add two <tt>LoanWrapper</tt> instances to the <tt>S</tt> object. (Note that we’re using the <tt>S</tt> object not <tt>LiftRules</tt> meaning that <tt>LoanWrapper</tt>s are applicable only for stateful processing. See <a class="Reference" href="#sec:Request/Response-Lifecycle">9.2↑</a> for when exactly <tt>LoanWrapper</tt>s are invoked.) 
</div>
<div class="Indented">
So let’s see what happens when the above code processess a request from a client. You can think of the invocation sequence as <tt>X(Y(f))</tt> where f is the Lift function that impersonates the core processing. Therefore you’ll see the following output in the console:
</div>
<div class="Indented">
<div class="listing">
<pre class="listing brush: scala">X -&gt; hello to the request!
Y -&gt; hello to the request!
&lt;Lift’s logic ... whatever is printed here&gt;
Y -&gt; goodbye!
X -&gt; goodbye!
</pre>
</div>

</div>
<div class="Indented">
This feature allows you use a resource before Lift does and release them after Lift has finished processing the stateful request and before the LiftResponse object is constructed.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.6.2">9.6.2</a> Passing Template Parameters to Snippets<a class="IndexReference" name="entry-Parameters-0" href="#index-Parameters">↓</a><a class="IndexReference" name="entry-Snippet-parameters-0" href="#index-Snippet-parameters">↓</a> 
</h3>
<div class="Unindented">
In addition to the standard attributes for snippets, outlined in Section <a class="Reference" href="#sub:snippet-tag">5.1↑</a>, you can set your own attributes on the snippet element. Attributes used in this manner are called “parameters”. Listing <a class="Reference" href="#lst:Snippet-parameter-template">9.6.2↓</a> shows us setting a <tt>default</tt> parameter on our <tt>Ledger.balance</tt> snippet.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:Snippet-parameter-template"> </a>Defining a Snippet Parameter
</div>
<pre class="listing brush: scala">&lt;lift:Ledger.balance default="10"&gt;
  &lt;ledger:balance/&gt; as of &lt;ledger:time /&gt;
&lt;/lift:Ledger.balance&gt;
</pre>
</div>

</div>
<div class="Indented">
The <tt>S.attr</tt> function allows us to access all parameters defined on the snippet element itself, as shown in Listing <a class="Reference" href="#lst:Snippet-parameter-code">9.6.2↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:Snippet-parameter-code"> </a>Accessing a Snippet Parameter
</div>
<pre class="listing brush: scala">class Ledger {
  def balance (content : NodeSeq ) : NodeSeq = {
    val dflt = S.attr("default") openOr "0";
    bind ("ledger", content,
          "balance" -&gt; Text(currentLegdger.formattedBalance),
          "time" -&gt; Text((new java.util.Date).toString))
  }
}
​
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.6.3">9.6.3</a> Computing Attributes with Snippets<a class="IndexReference" name="entry-Attributes-computing-via-snippet-0" href="#index-Attributes-computing-via-snippet">↓</a>
</h3>
<div class="Unindented">
You can use snippets to compute tag attributes, as shown in Listing <a class="Reference" href="#lst:Using-a-Snippet-compute-attr">9.6.3↓</a>:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:Using-a-Snippet-compute-attr"> </a>Using a Snippet to Compute an Attribute
</div>
<pre class="listing brush: scala">// In your page you can have
&lt;div lift:snippet="MyDivThing:calcDir"&gt; ... &lt;/div&gt;
​
...
// Your snippet
class MyDivThing {   
  def calcDir = new UnprefixedAttribute("dir", "rtl", Null)
} 
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.6.4">9.6.4</a> Processing Element Attributes<a class="IndexReference" name="entry-Attributes-retrieving-from-elements-0" href="#index-Attributes-retrieving-from-elements">↓</a>
</h3>
<div class="Unindented">
Now we have seen how we can pass xml parameters to snippets but what if we want to pass parameters on the nodes that will be bound? For instance, we may want to pass the am/pm information on the time element such as:
</div>
<pre class="LyX-Code">
<tt>&lt;ledger:time ampm=”true”/&gt; </tt>
</pre>
<div class="Unindented">
to control the time display format. Listing <a class="Reference" href="#lst:Element-attribute-retrieval">9.6.4↓</a> shows how we can use the <tt>BindHelpers</tt> object to retrieve the current element’s attributes.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Retrieving Element Attributes with BindHelpers<a class="Label" name="lst:Element-attribute-retrieval"> </a>
</div>
<pre class="listing brush: scala">class Ledger {
  def balance (content : NodeSeq ) : NodeSeq = {
    val dflt = S.attr("default") openOr "0";
    bind ("ledger", content,
          "balance" -&gt; Text(currentLegdger.formattedBalance),
          "time" -&gt; {
            node: NodeSeq =&gt; println(BindHelpers.attr("ampm")); 
            Text((new java.util.Date).toString))
          })
  }
}
​
</pre>
</div>

</div>
<div class="Indented">
You can use the <tt>BindHelpers</tt> object for obtaining information about node attributes. This context is maintained internally using <tt>ThreadLocal</tt>s and closures. Note that the context is cleared after the bind method is executed. In our example above for “time” node we are actually binding a function that takes the child nodes of the <tt>&lt;ledger:time&gt;</tt> node. When our function is called by Lift we can access the BindHelpers, such ass the attributes of the current node. The sequence <tt>&lt;string&gt; -&gt; &lt;right-hand-side-expression&gt;</tt> is turned into a BindParam object using implicit conversions. It is important to note that BindParam.calcValue function is called in the correct context so that BindHelpers can be safely used.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-9.7">9.7</a> Advanced S Object Features<a class="Label" name="sub:Advanced-S-Object"> </a>
</h2>
<div class="Unindented">
The <tt>S</tt>, or Stateful, object is a very important part of Lift. The S context is created when a client request is recieved that needs to be handled as a stateful reuest. Please see <a class="Reference" href="#sec:Request/Response-Lifecycle">9.2↑</a> for more details on the state creation and handling. The actual state information is kept inside the S object using ThreadLocal<span class="FootOuter"><span class="SupFootMarker"> [O] </span><span class="HoverFoot"><span class="SupFootMarker"> [O] </span>java.lang.ThreadLocal</span></span> variables since <tt>S</tt> is a singleton. This means that if you have any code that is executed in the stateful context you can safely use any <tt>S</tt> object goodies, which include:
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.7.1">9.7.1</a> Managing cookies
</h3>
<div class="Unindented">
You can retrieve cookies from the request or set cookies to be sent in the response. Cookies are covered in section <a class="Reference" href="#sec:Cookies">3.10↑</a>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.7.2">9.7.2</a> Localization and Internationalization
</h3>
<div class="Unindented">
Localization (also called L10N) and Internationalization (also called I18N) are very important aspects of many web applications that deal with different languages. These topics are covered in chapter <a class="Reference" href="#cha:Internationalization">D↓</a>. 
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.7.3">9.7.3</a> Managing the Timezone
</h3>
<div class="Unindented">
The<tt> S.timeZone</tt> function returns the current timezone as computed by the<br/>
<tt>LiftRules.timeZoneCalculator</tt> function. By default, the <tt>LiftRules</tt> method simply executes TimeZone.getDefault, but you can provide your own <span class="formula"><i>Box</i>[<i>HttpServletRequest</i>] ⇒ <i>TimeZone</i></span> partial function to define your own behavior. Examples would include allowing users to choose their own timezone, or to use geographic lookup of the user’s IP address.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.7.4">9.7.4</a> Per-session DispatchPF functions 
</h3>
<div class="Unindented">
You can set DispatchPF functions that operate in the context of a current session. Essentially you can bind DispatchPF functions with a given name. Relevant functions are:
</div>
<ul>
<li>
<tt>S.highLevelSessionDispatcher</tt> - returns a <tt>List[LiftRules.DispatchPF]</tt>
</li>
<li>
<tt>S.highLevelSessionDispatchList</tt> - returns a <tt>List[DispatchHolder] </tt>
</li>
<li>
<tt>S.addHighLevelSessionDispatcher </tt>- maps a name with a given <tt>DispatchPF</tt>
</li>
<li>
<tt>S.removeHighLevelSessionDispatcher</tt> - removes the <tt>DispatchPF</tt> given its name
</li>
<li>
<tt>S.clearHighLevelSessionDispatcher</tt> - removes all <tt>DispatchPF</tt> associations
</li>

</ul>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.7.5">9.7.5</a> Session re-writers
</h3>
<div class="Unindented">
Session re-writers are per session functions that allow you to modify a HTTP request (URI, query parameters etc.) before the request is actually processed. This is similar with LiftRules.rewrite variable but you can apply rewriters per a given session. Hence you can have different rewrites in diferent contexts. The relevant functions are:
</div>
<ul>
<li>
<tt>S.sessionRewriter</tt> - returns a<tt> List[RewriteHolder]</tt>
</li>
<li>
<tt>S.addSessionRewriter</tt> - maps a <tt>LiftRules.RewritePF </tt>with a given name
</li>
<li>
<tt>S.removeSessionRewriter</tt> - removes a rewriter by a name
</li>
<li>
<tt>S.clearSessionRewriter</tt> - remove all session rewriters.
</li>

</ul>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.7.6">9.7.6</a> Access to HTTP headers
</h3>
<div class="Unindented">
Accessing HTTP header parameters from the request and adding HTTP header parameters to the HTTP response represent very common operations. You can easily perform these operations using the following functions:
</div>
<ul>
<li>
<tt>S.getHeaders</tt> - returns a <tt>List[(String, String)] </tt>containing all HTTP headers grouped by name and value pair
</li>
<li>
<tt>S.setHeader</tt> - sets a HTTP header parameter by specifying the name and value pair
</li>

</ul>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.7.7">9.7.7</a> Manage the document type
</h3>
<div class="Unindented">
You can also read and write the XML document type set for the current response. You can use the following functions:
</div>
<ul>
<li>
<tt>S.getDocType</tt> - returns the doc type that was set forthe current response
</li>
<li>
<tt>S.setDocType</tt> - sets a document type for the curent response object.
</li>

</ul>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.7.8">9.7.8</a> Other functions 
</h3>
<ul>
<li>
Access to the raw HttpServletRequest and HttpSession if you really need it.
</li>
<li>
Managing the function map. The function map generates an association between a String and a function. This string represents a query parameter that when Lift receives upon a HTTP request, it will execute your function. Normally these names are auto-generated by Lift but you can also provide you own name. Please see <a class="Reference" href="#sub:Lift-Function-Mapping">9.3↑</a> for more details.
</li>
<li>
Managing wrappers - see <a class="Reference" href="#sub:Wrapping-Lift's-processing">9.6.1↑</a>
</li>
<li>
Managing notices - see <a class="Reference" href="#sub:Notices/Warnings/Errors-messages">3.6↑</a>
</li>
<li>
Managing HTTP redirects - see S.redirectTo functions and <a class="Reference" href="#sec:LiftResponse-in-Detail">9.4↑</a>
</li>
<li>
Using XML attibutes of a snippet - see <a class="Reference" href="#sub:Additional-Snippet-Features">↓</a>
</li>

</ul>
<h2 class="Section">
<a class="toc" name="toc-Section-9.8">9.8</a> ResourceServer<a class="Label" name="sub:ResourceServer"> </a>
</h2>
<div class="Unindented">
ResourceServer is a Lift component that manages the serving of resources like JS, CSS etc. Well the web container can do that right? ... still container does not serve these resources if they are inside jar files. The default URI path for serving such resources is given by<tt> LiftRules.resourceServerPath</tt> variable which by default it is set to “classpath”. The folder location where the resource is looked up inside jar files is given by <tt>ResourceServer.baseResourceLocation</tt> variable which by default it is set to “toserve”. Let’s assume the following folder structure inside you Lift project:
</div>
<div class="Indented">
<tt>lift-proj/src/main/resources/toserve/css/mystyle.css</tt>
</div>
<div class="Indented">
Maven will create the toserver folder in the jar/war file generated. Then in your web page you add something like:
</div>
<div class="Indented">
<tt>&lt;link rel="stylesheet" href="/classpath/css/mystyle.css" type="text/css"/&gt;</tt>
</div>
<div class="Indented">
Because the first URI part matches with <tt>LiftRules.resourceServerPath</tt> Lift will tell ResouceServer to load this resource from ’toserve’ folder. But it will fail. There is one thing left to do. We need to tell ResouceServer to allow the loading of mystyle.css resource. We can do this from Boot by calling:
</div>
<div class="Indented">
<tt>ResourceServer.allow { </tt>
</div>
<div class="Indented">
<tt>case "css" :: _ =&gt; true </tt>
</div>
<div class="Indented">
<tt>}</tt>
</div>
<div class="Indented">
We basically told Lift here to allow any resource found in css folder under toserve. Note that toserver comes from <tt>ResourceServer.baseResourceLocation</tt> which can be changed.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-9.9">9.9</a> HTTP Authentication<a class="Label" name="sub:HTTP-Authentication"> </a><a class="IndexReference" name="entry-HTTP-authentication-0" href="#index-HTTP-authentication">↓</a><a class="IndexReference" name="entry-Authentication-0" href="#index-Authentication">↓</a>
</h2>
<div class="Unindented">
HTTP authentication is described by RFC 2617 <span class="FootOuter"><span class="SupFootMarker"> [P] </span><span class="HoverFoot"><span class="SupFootMarker"> [P] </span><a class="FlexURL" href="http://www.isi.edu/in-notes/rfc2617.txt">http://www.isi.edu/in-notes/rfc2617.txt</a></span></span>. It describes the means of protecting server resources and allowing access only to authorized entities. As you may know, any J(2)EE web container provides HTTP authentication support using JAAS<span class="FootOuter"><span class="SupFootMarker"> [Q] </span><span class="HoverFoot"><span class="SupFootMarker"> [Q] </span>Java Authentication and Authorization Service. More information can be found at <a class="FlexURL" href="http://java.sun.com/javase/6/docs/technotes/guides/security/jaas/JAASRefGuide.html">http://java.sun.com/javase/6/docs/technotes/guides/security/jaas/JAASRefGuide.html</a></span></span><a class="IndexReference" name="entry-Authentication-JAAS-0" href="#index-Authentication-JAAS">↓</a>. However, this approach has limitations. For example, if you provide your own <tt>LoginModule</tt> or <tt>CallbackHandler</tt> implementation this will not be loaded by the web application classloader but instead by the container classloader (at least in tomcat). This can lead to dependency loading issues since the web application classloader sits below the container’s classloader in the delegation chain. Lift, however, provides supports for both basic and digest authentications via a simplified, scala-oriented API that you can use directly. This API provides not only direct support for the HTTP authentication mechanisms, but also a path and role based authorization mechanism. The following sections show how we use basic authentication to protect our REST API (Chapter <a class="Reference" href="#cha:Web-Services">15 on page 1↓</a>).
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.9.1">9.9.1</a> Determining which Resources to Protect
</h3>
<div class="Unindented">
The first thing we need to do is tell Lift which resources are protected by authentication. This is done by configuring <tt>LiftRules.httpAuthProtectedResources<a class="IndexReference" name="entry-httpAuthProtectedResources-0" href="#index-httpAuthProtectedResources">↓</a></tt> with one or more <tt>PartialFunction[Req,Box[Role]]</tt><span class="FootOuter"><span class="SupFootMarker"> [R] </span><span class="HoverFoot"><span class="SupFootMarker"> [R] </span><tt>net.liftweb.http.auth.Role</tt></span></span> to match on the request. Listing <a class="Reference" href="#lst:HTTP-auth-define-resources">9.9.1↓</a> shows the PartialFunction defined in our <tt>DispatchRestAPI</tt> object (Section <a class="Reference" href="#sub:REST-Custom-Dispatch">15.4.1 on page 1↓</a>) used to protect our REST API from unauthorized access.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Defining Protected Resources<a class="Label" name="lst:HTTP-auth-define-resources"> </a>
</div>
<pre class="listing brush: scala">  // We explicitly protect GET and PUT requests in our REST API
  import net.liftweb.http.auth.AuthRole
  def protection : LiftRules.HttpAuthProtectedResourcePF = {
    case Req(List("api", "account", accountId), _, PutRequest) =&gt;
       Full(AuthRole("editAcct:" + accountId))
    case Req(List("api", "account", accountId), _, GetRequest) =&gt;
       Full(AuthRole("viewAcct:" + accountId))
    // If the account is public, don’t enforce auth
    case Req(List("api", "expense", Expense(e, true)), _, GetRequest) =&gt; Empty
    case Req(List("api", "expense", Expense(e, _)), _, GetRequest) =&gt;
      Full(AuthRole("viewAcct:" + e.account.obj.open_!.id))
  }
</pre>
</div>

</div>
<div class="Indented">
The <tt>PartialFunction</tt> matches on the <tt>Req</tt> and can either return an <tt>Empty</tt>, indicating that the given request does not require authentication, or a <tt>Full[Role]</tt>, that indicates which R<tt>ole</tt> a user requires to be authorized to access the given resource. One important thing to remember is that HTTP authentication and SiteMap access control (Section <a class="Reference" href="#sec:SiteMap-Access-Control">7.3 on page 1↑</a>) are synergistic, so make sure that you configure both properly. We will discuss <tt>Role</tt>s further in Section <a class="Reference" href="#sub:Role-Hierarchies">9.9.3↓</a>, but for now you can simply consider them as <tt>String</tt> attributes associated with the current session. Once we’ve defined which resources are to be protected, we need to hook our <tt>PartialFunction</tt> into <tt>LiftRules</tt> in the <tt>Boot.boot</tt> method, shown in Listing <a class="Reference" href="#lst:Hooking-Resource-Protection">9.9.1↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Hooking Resource Protection<a class="Label" name="lst:Hooking-Resource-Protection"> </a>
</div>
<pre class="listing brush: scala">// Hook in our REST API auth
LiftRules.httpAuthProtectedResource.append(DispatchRestAPI.protection)
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.9.2">9.9.2</a> Providing the Authentication Hook
</h3>
<div class="Unindented">
After we’ve defined what resources we want to protect, we need to configure the <tt>LiftRules.authentication</tt> function to perform the actual authentication. Lift supports both HTTP Basic and Digest authentication schemes, which we’ll cover in the next two sections.
</div>
<div class="Indented">
<div class="defskip"> </div>
</div>
<div class="Indented">
<div class="center">
<div class="Shadowbox" style="width: 75%;">
Note that in these examples we use stateful dispath (Section <a class="Reference" href="#sec:Custom-dispatch-func">3.8 on page 1↑</a>) since the <tt>User.logUserIn</tt> method utilizes a backing <tt>SessionVar</tt>. If you use stateless dispatch you will need to provide your own <tt>RequestVar</tt>s to store the current user and roles.
</div>

</div>

</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-9.9.2.1">9.9.2.1</a> HTTP Basic Authentication
</h4>
<div class="Unindented">
HTTP Basic authentication is provided by the <tt>net.liftweb.http.auth.HttpBasicAuthentication</tt> implementation class, constructed using the authentication realm name as well as a <tt>PartialFunction[(String, String, Req), Boolean]</tt> that actually does the authentication. The tuple passed to the <tt>PartialFunction</tt> consists of the attempted username password, and the request object (<tt>Req</tt>). It’s your responsibility to return <tt>true</tt> or <tt>false</tt> to indicate whether the provided credentials succeed. Listing <a class="Reference" href="#lst:Performing-Basic-Authentication">9.9.2.1↓</a> shows the code in <tt>Boot.boot</tt> that PocketChange uses to perform authentication based on the user’s email address and password. Note that when authentication succeeds for a given user not only do we return true, but we set the user as logged in (via <tt>User.logUserIn</tt>) and we compile a set of all of the <tt>Role</tt>s that the user so that Lift knows which protected resources the user may access. The<tt> net.liftweb.http.auth.userRoles</tt> <tt>RequestVar</tt> is a built-in construct in Lift that the authentication backend uses for bookkeeping.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Performing Basic Authentication<a class="Label" name="lst:Performing-Basic-Authentication"> </a>
</div>
<pre class="listing brush: scala">import net.liftweb.http.auth.{AuthRole,HttpBasicAuthentication,userRoles}
LiftRules.authentication = HttpBasicAuthentication("PocketChange") {
  case (userEmail, userPass, _) =&gt; {
    logger.debug("Authenticating: " + userEmail)
    User.find(By(User.email, userEmail)).map { user =&gt;
      if (user.password.match_?(userPass)) {
        logger.debug("Auth succeeded for " + userEmail)
        User.logUserIn(user)
​
        // Compute all of the user roles
        userRoles(user.editable.map(acct =&gt; AuthRole("editAcct:" + acct.id)) ++
                  user.allAccounts.map(acct =&gt; AuthRole("viewAcct:" + acct.id)))
        true
      } else {
        logger.warn("Auth failed for " + userEmail)
        false
      }
    } openOr false
  }
}
</pre>
</div>

</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-9.9.2.2">9.9.2.2</a> HTTP Digest Authentication
</h4>
<div class="Unindented">
HTTP Digest authentication is provided by the <tt>net.liftweb.http.auth.HttpDigestAuthentication</tt> implementation class. Like Basic authentication, the <tt>HttpDigestAuthentication</tt> instance is constructed with a realm name and a <tt>PartialFunction</tt>, but in this case the <tt>PartialFunction</tt> uses a tuple of <tt>(String,Req,(String)<span class="formula"> ⇒ </span>Boolean)</tt>. The first parameter is still the username, and the second parameter is the request instance, but the third parameter is a function that will compute and compare the digest for authentication based on a <i>plaintext</i> password. This means that if we want to use Digest authentication, we need to be able to retrieve a plaintext password for the user from the database somehow. Listing <a class="Reference" href="#lst:HTTP-Digest-Authentication">9.9.2.2↓</a> shows how we could do this in PocketChange if we modified the <tt>User.password</tt> field to simply be a <tt>MappedString</tt>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Performing Digest Authentication<a class="Label" name="lst:HTTP-Digest-Authentication"> </a>
</div>
<pre class="listing brush: scala">import net.liftweb.http.auth.{AuthRole,HttpBasicAuthentication,userRoles}
LiftRules.authentication = HttpBasicAuthentication("PocketChange") {
  case (userEmail, _, authenticates) =&gt; {
    logger.debug("Authenticating: " + userEmail)
    User.find(By(User.email, userEmail)).map { user =&gt;
      if (authenticates(user.password.is)) {
        logger.debug("Auth succeeded for " + userEmail)
        User.logUserIn(user)
​
        // Compute all of the user roles
        userRoles(user.editable.map(acct =&gt; AuthRole("editAcct:" + acct.id)) ++
                  user.allAccounts.map(acct =&gt; AuthRole("viewAcct:" + acct.id)))
        true
      } else {
        logger.warn("Auth failed for " + userEmail)
        false
      }
    } openOr false
  }
}
</pre>
</div>

</div>
<div class="Indented">
Another important factor with Digest authentication is that it uses nonces<span class="FootOuter"><span class="SupFootMarker"> [S] </span><span class="HoverFoot"><span class="SupFootMarker"> [S] </span><a class="FlexURL" href="http://en.wikipedia.org/wiki/Cryptographic_nonce">http://en.wikipedia.org/wiki/Cryptographic_nonce</a></span></span> for authenticating the client, and the nonces have a limited lifetime. The default nonce lifetime is 30 seconds, but you can configure this by overriding the <tt>HttpDigestAuthentication.nonceValidityPeriod</tt> method.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-9.9.3">9.9.3</a> Role Hierarchies<a class="Label" name="sub:Role-Hierarchies"> </a>
</h3>
<div class="Unindented">
So far we’ve discussed <tt>Role</tt>s as essentially flat constructs. A <tt>Role</tt>, however, is an n-ary tree structure, meaning that when we assign a <tt>Role</tt> to a protected resource we can actually provide a hierarchy. Figure <a class="Reference" href="#fig:Roles-hierarchy-example">9.4↓</a> shows an example of one such hierarchy. In this example, the Admin is the “superuser” role for admins, and can do what any sub-role can do and more. The Site-Admin can monitor the application, the User-Admin can manage users, and then we specify a set of location-specific roles: the Romania-Admin that can manage users from Romania, US-Admin that can manage users from US and UK-Admin that can only manage users from UK. With this hierarchy a User-Admin can manage users from anywhere but a Site-Admin can not manage any users. A Romania-Admin can’t monitor the site, nor it can manage the US or UK users.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="fig:Roles-hierarchy-example"> </a><div class="figure">
<div class="center">
<img class="embedded" src="images/roles.png" alt="figure images/roles.png" style="width: 4in; max-width: 1692px; height: auto; max-height: 654px;"/>

</div>
<div class="caption">
Figure 9.4 Roles hierarchy example
</div>

</div>

</div>

</div>
<div class="Indented">
Given this Role hierarchy, Listing <a class="Reference" href="#lst:Using-Role-Hierarchies">9.9.3↓</a> shows how we can implement this in our code by creating our Role hierarchy and then using the Role.getRoleByName method to locate the proper Role when we perform authentication. In this example we’re restricting access to the <tt>/users/ro</tt> path to only users with the “Romania-Admin” role. However, our fictional “John” user is assigned the “User-Admin” role, so he will be able to access that path.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using Role Hierarchies<a class="Label" name="lst:Using-Role-Hierarchies"> </a>
</div>
<pre class="listing brush: scala">import auth._
​
class Boot {
  def boot = {
    ...
    val roles = 
      AuthRole("Admin", 
        AuthRole("Site-Admin"),
        AuthRole("User-Admin", 
            AuthRole("Romania-Admin"),
            AuthRole("US-Admin"),
            AuthRole("UK-Admin")
        )
    )
​
    LiftRules.protectedResource.append {    
      case (ParsePath("users" :: "ro" :: _, _, _, _)) =&gt; 
        roles.getRoleByName("Romania-Admin")
    }
   
    LiftRules.authentication = HttpBasicAuthentication("lift") {  
      case ("John", "12test34", req) =&gt; 
        println("John is authenticated !")
        userRoles(AuthRole("User-Admin")) 
        true    
    }  
​
   ...
  }
}
</pre>
</div>

</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-10">10</a> Lift and JavaScript<a class="Label" name="cha:Lift-and-Javascript"> </a>
</h1>
<div class="Unindented">
In this chapter we’ll be discussing some of the techniques that Lift provides for simplifying and abstracting access to JavaScript on the client side. Using these facilities follows Lift’s model of separating code from presentation by allowing you to essentially write JavaScript code in Scala. Lift also provides a layer that allows you to use advanced JavaScript functionality via either the JQuery<span class="FootOuter"><span class="SupFootMarker"> [T] </span><span class="HoverFoot"><span class="SupFootMarker"> [T] </span><a class="URL" href="http://jquery.com/">http://jquery.com/</a></span></span> or YUI<span class="FootOuter"><span class="SupFootMarker"> [U] </span><span class="HoverFoot"><span class="SupFootMarker"> [U] </span><a class="URL" href="http://developer.yahoo.com/yui/">http://developer.yahoo.com/yui/</a></span></span> user interface libraries.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-10.1">10.1</a> JavaScript high level abstractions
</h2>
<div class="Unindented">
You may have noticed that Lift already comes with rich client side functionality in the form of AJAX and COMET support (chapter <a class="Reference" href="#cha:AJAX-and-COMET">11↓</a>). Whenever you use this support, Lift automatically generates the proper <tt>&lt;script&gt;</tt> elements in the returned page so that the libraries are included. Lift goes one step further, however, by providing a class hierarchy representing JavaScript expressions. For example, with an AJAX form element in Lift the callback method must return JavaScript code to update the client side. Instead of just returning a raw JavaScript string to be interpreted by the client, you return an instance of the <tt>JsCmd</tt><span class="FootOuter"><span class="SupFootMarker"> [V] </span><span class="HoverFoot"><span class="SupFootMarker"> [V] </span>net.liftweb.http.js.JsCmd</span></span> trait (either directly or via implicit conversion) that is transformed into the proper JavaScript for the client.
</div>
<div class="Indented">
<tt>JsCmd</tt> represents a JavaScript command that can be executed on the client. There is an additional “base” trait called <tt>JsExp</tt> that represents a JavaScript expression.The differences between them are not usually important to the developer, since a <tt>JsExp</tt> instance is implicitly converted to a <tt>JsCmd</tt>. Also note that while Lift’s JavaScript classes attempt to keep things type-safe there are some limitations; in particular, Lift can’t check semantic things like whether the variable you’re trying to access from a given <tt>JsCmd</tt> actually exists. Besides the obvious use in techniques like AJAX and COMET, Lift also makes it simple to attach JavaScript to regular Scala XML objects, such as form fields.
</div>
<div class="Indented">
As a simple example, let’s look at how we might add a simple alert to a form if it doesn’t validate. In this example, we’ll assume we have a <tt>name</tt> form field that shouldn’t be blank. Listing <a class="Reference" href="#lst:Simple-Form-Validation">10.1↓</a> shows a possible binding from our form snippet. Let’s break this down a bit: the first thing is that in order to reference form elements (or any elements for that matter) from JavaScript, they need to have an <tt>id</tt> attribute. We add the id attribute<a class="IndexReference" name="entry-XML-attributes-0" href="#index-XML-attributes">↓</a> to our text field by passing a <tt>Pair[String,String]</tt>. Next, we need to define our actual validation. We do this by adding some javascript to the <tt>onclick</tt> attribute of our submit button. The onclick attribute evaluates whatever javascript is assigned when the button is clicked; if the javascript evaluates to true then submission continues. If it evaluates to false then submission is aborted. In our case, we use the JsIf case class to check to see if the value of our myName field is equal to an empty string. In this case the JE object holds an implicit conversion from a Scala string to a Str (JavaScript string) instance. The second argument to JsIf is the body to be executed if the condition is true. In our case we want to pop up an alert to the user and stop form submission. The JsCmd trait (which Alert mixes in) provides a “&amp;” operator which allows you to chain multiple commands together. Here we follow the Alert with a JsReturn, which returns the specified value; again, there’s an implicit conversion from Boolean to JsExp, so we can simply provide the “false” value.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Simple Form Validation<a class="Label" name="lst:Simple-Form-Validation"> </a>
</div>
<pre class="listing brush: scala">import JsCmds._
import JE._
​
var myName = ""
bind(...
  "name" -&gt; text(myName, myName = _, "id" -&gt; "myName"),
  "submit" -&gt; submit("Save", ..., "onclick" -&gt; 
    JsIf(JsEq(ValById("myName"), ""), 
      Alert("You must provide a name") &amp; JsReturn(false))
    )
)
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-10.1.1">10.1.1</a> JsCmd and JsExp overview
</h3>
<div class="Unindented">
If you peruse the Lift API docs you’ll find a large number of traits and classes under the JsCmds and JE objects; these provide the vast majority of the functionality you would need to write simple JavaScript code directly in Lift. Having said that, however, it’s important to realize that the Lift classes are intended to be used for small code fragments. If you need to write large portions of JavaScript code for your pages, we recommend writing that code in <i>pure</i> JavaScript in an external file and then including that file in your pages. In particular, if you write your code as JavaScript functions, you can use the <tt>JE.Call</tt> class to execute those functions from your Lift code. Table <a class="Reference" href="#tab:Top-Level-JsCmds">10.1↓</a> gives a brief overview of the available JsCmds, while table <a class="Reference" href="#tab:Top-Level-JE-abstractions">10.2↓</a> shows the JE expression abstractions.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="tab:Top-Level-JsCmds"> </a><div class="table">
<div class="center">
<table>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">After</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Executes the given JsCmd fragment after a given amount of time</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">Alert</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Corresponds directly to the JavaScript alert function</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">CmdPair</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Executes two JsCmd fragments in order</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">FocusOnLoad</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Forces focus on the given XML element when the document loads</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">Function</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Defines a JavaScript function with name, parameter list, and JsCmd body</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">JsBreak, JsContinue, JsReturn</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Corresponds directly to the JavaScript “break”, “continue”, and “return” keywords</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">JsFor, JsForIn, JsDoWhile, JsWhile</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">These define loop constructs in JavaScript with conditions and execution bodies</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">JsHideId, JsShowId</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Hides or shows the HTML element with the given Id. This is actually handled via the LiftArtifacts’ hide and show methods</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">JsIf</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Corresponds to the JavaScript “if” statement, with a condition, body to execute if the condition is true, and optional “else” body statement</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">JsTry</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Defines a try/catch block tha can optionally alert if an exception is caught</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">JsWith</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Defines a with statement to reduce object references</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">OnLoad</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Defines a JavaScript statement that is executed on page load</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">Noop</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Defines an empty JavaScript statement</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">RedirectTo</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Uses window.location to redirect to a new page</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">ReplaceOptions</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Replaces options on a form Select with a new list of options.</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">Run</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Executes the given string as raw javascript</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">Script</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Defines a &lt;script&gt; element with proper CDATA escaping, etc to conform to XHTML JavaScript support</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">SetElemById</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Assigns a statement to a given element by id. Optional parameters allow you to specify properties on the element</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">SetExp</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Defines an assignment to an arbitrary JavaScript expression from another JavaScript expression</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">SetHtml</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Sets the contents of a given HTML node by Id to a given NodeSeq. This is especially useful in Ajax calls that update parts of the page</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.25in;">
<span class="small">SetValById</span>
</td>
<td align="left" valign="bottom" style="width: 4.5in;">
<span class="small">Defines an assignment to a given element’s “value” property</span>
</td>

</tr>

</table>

</div>
<div class="caption">
Table 10.1 Basic JsCmds
</div>

</div>

</div>

</div>
<div class="Indented">
<div class="float">
<a class="Label" name="tab:Top-Level-JE-abstractions"> </a><div class="table">
<div class="center">
<table>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">AnonFunc</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Defines an anonymous JavaScript function</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">Call</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Calls a JavaScript function by name, with parameters</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">ElemById</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Obtains a DOM element by its Id, with optional property access</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">FormToJson</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Converts a given form (by Id) into a JSON representation</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">Id, Style, Value</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Represents the “id”, “style” and “value” element attributes</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">JsArray</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Constructs a JavaScript array from a given set of JavaScript expressions</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">JsEq, JsNotEq, JsGt, JsGtEq, JsLt, JsLtEq</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Comparison tests between two JavaScript expressions. JsExp instances also have a “===” operator which is equivalent to JsEq</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">JsTrue, JsFalse, JsNull</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Represents the “true”, “false”, and “null” values</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">JsFunc</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Similar to Call; executes a JavaScript function</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">JsObj</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Represents a JavaScript object with a Map for properties</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">JsRaw</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Represents a raw JavaScript fragment. You can use this if Lift doesn’t provide functionality via abstractions</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">JsVal</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Represents an abritrary JavaScript value</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">JsVar</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Represents a JavaScript variable, with optional property access</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">Num</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Represents a JavaScript number. JE contains implicit conversions from Scala numeric types to Num</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">Str</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Represents a Javascript String. JE contains implicit conversions from a Scala String to Str</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">Stringify</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Calls JSON.stringify to convert a JavaScript object into a JSON string representation</span>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1.5in;">
<span class="small">ValById</span>
</td>
<td align="left" valign="top" style="width: 4in;">
<span class="small">Represents the “value” property of a given element by Id</span>
</td>

</tr>

</table>

</div>
<div class="caption">
Table 10.2 Basic JE abstractions
</div>

</div>

</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-10.1.2">10.1.2</a> JavaScript Abstraction Examples
</h3>
<div class="Unindented">
As you can see, Lift provides a large coverage of JavaScript functionality through its abstraction layer. Even if you’ve done a lot of JavaScript, however, the abstractions don’t always map one-to-one and it can take some effort to wrap your head around it. We’re going to provide a few examples to help you understand how it works. We’ll start off with a simple example of an Ajax callback (Ajax is covered in chapter <a class="Reference" href="#cha:AJAX-and-COMET">11↓</a>). Listing <a class="Reference" href="#lst:Using-SetHtml">10.1.2↓</a> shows how we can update an HTML element with new content via the Ajax call. In this case, we’re changing a chart image based on some passed parameters. Our HTML needs to contain an element with an id of “tx_graph”; this element will have its children <i>replaced</i> with whatever NodeSeq we pass as the second argument.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using SetHtml<a class="Label" name="lst:Using-SetHtml"> </a>
</div>
def updateGraph() = {<pre class="listing brush: scala">  val dateClause : String = ...
  val url = "/graph/" + acctName + "/" + graphType + dateClause
  JsCmds.SetHtml("tx_graph", &lt;img src={url} /&gt;)
}
</pre>
</div>

</div>
<div class="Indented">
As a more complex example, we could add some JavaScript behavior combining Ajax with some client-side state, as shown in listing <a class="Reference" href="#lst:Client-side-comparisons">10.1.2↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Client-side comparisons<a class="Label" name="lst:Client-side-comparisons"> </a>
</div>
<pre class="listing brush: scala">import js.JE._ // for implicit conversions
def moreComplexCallback (value : String) = {
  JsIf(ValById("username") === value.toLowerCase, {
    JsFunc("logAccess", "Self-share attempted").cmd &amp; Alert("You can’t share with yourself!")
  })
}
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-10.2">10.2</a> JQuery and other JavaScript frameworks
</h2>
<div class="Unindented">
We’ve mentioned earlier that Lift uses the JQuery JavaScript framework by default. Lift wouldn’t be Lift, however, if it didn’t provide a mechanism for using other frameworks. The way that lift determines which JavaScript framework to use is via the <tt>JSArtifacts</tt><span class="FootOuter"><span class="SupFootMarker"> [W] </span><span class="HoverFoot"><span class="SupFootMarker"> [W] </span>net.liftweb.http.js.JSArtifacts</span></span> trait along with the LiftRules.jsArtifacts var. Lift comes with two default implementations of JSArtifacts: <tt>JQueryArtifacts<span class="FootOuter"><span class="SupFootMarker"> [X] </span><span class="HoverFoot"><span class="SupFootMarker"> [X] </span>net.liftweb.http.js.jquery.JQueryArtifacts</span></span></tt> and <tt>YUIArtifacts</tt><span class="FootOuter"><span class="SupFootMarker"> [Y] </span><span class="HoverFoot"><span class="SupFootMarker"> [Y] </span>net.liftweb.http.js.yui.YUIArtifacts</span></span>. If you want to use a different framework, you must provide a concrete implementation of the JSArtifacts trait specific to that framework. The JQuery support in Lift extends beyond just the JSArtifacts, support; there are also a number of JSExp and JsCmd traits and classes in the <tt>net.liftweb.http.js.jquery</tt> package that provide JQuery specific implementations for standard expressions and commands.
</div>
<div class="Indented">
Changing one implementation or another can be done from LiftRules.jsArtifacts variable, which by default points to JQueryArtifacts. Typically this is done in Boot, as shown in listing <a class="Reference" href="#lst:Configuring-Lift-YUI">10.2↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Configuring Lift YUI<a class="Label" name="lst:Configuring-Lift-YUI"> </a>
</div>
<pre class="listing brush: scala"> import net.liftweb.http.js.yui.YUIArtifacts      
       
 class Boot {      
   def boot = {      
     ...      
     LiftRules.jsArtifacts = YUIArtifacts      
     ...     
 }  
</pre>
</div>

</div>
<div class="Indented">
In addition to changing LiftRules, you also need to take into account that other frameworks have their own scripts and dependencies that you’ll need to include in your pages. For YUI you would need to include the following scripts (at minimum):
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Lift YUI scripts<a class="Label" name="lst:Lift-YUI-scripts"> </a>
</div>
<pre class="listing brush: scala"> &lt;script src="/classpath/yui/yahoo.js" type="text/javascript"/&gt;
 &lt;script src="/classpath/yui/event.js" type="text/javascript"/&gt;   
 &lt;script src="/classpath/yui/dom.js" type="text/javascript"/&gt;   
 &lt;script src="/classpath/yui/connection.js" type="text/javascript"/&gt;   
 &lt;script src="/classpath/yui/json.js" type="text/javascript"/&gt;   
 &lt;script src="/classpath/liftYUI.js" type="text/javascript"/&gt;
</pre>
</div>

</div>
<div class="Indented">
Of course, to keep things simple you could either place all of these items in a template that you could embed, or you could combine the files into a single JavaScript source file.
</div>
<div class="Indented">
We have some simple recommendations on using different JavaScript frameworks from within Lift:
</div>
<ol>
<li>
If you don’t necessarily need YUI widgets or if you can find similar functionality in JQuery plugins, we recommend using the JQuery framework. Lift provides much better support out-of-the-box for JQuery
</li>
<li>
Do not mix JQuery and YUI unless you really know what you are doing. Getting both of them together leads to a number of collisions.
</li>

</ol>
<h2 class="Section">
<a class="toc" name="toc-Section-10.3">10.3</a> XML and JavaScript
</h2>
<div class="Unindented">
What we’ve covered so far is pretty much standard JavaScript behind some Lift facades. There are situations, however, when you want to do things that are complicated or outside the scope of typical JavaScript functionality. One example of this is when you need to build dynamic DOM elements from JavaScript code, say to build an HTML list. Lift has a very nice way of dealing with such situation; with a few lines of code you can achieve quite a lot. The main functionality for this is provided via the Jx* classes<span class="FootOuter"><span class="SupFootMarker"> [Z] </span><span class="HoverFoot"><span class="SupFootMarker"> [Z] </span>net.liftweb.http.js.Jx, etc</span></span>, which you can use to transform a scala.xml.NodeSeq into javascript code that generates the corresponding nodes on the client side. Listing <a class="Reference" href="#lst:Jx-trivial-example">10.3↓</a> shows a simple example of emitting a div on a page via JavaScript.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Jx trivial example<a class="Label" name="lst:Jx-trivial-example"> </a>
</div>
<pre class="listing brush: scala"> import net.liftweb.http.js._ 
 import JE._
​
 val div = Jx(&lt;div&gt;Hi there&lt;/div&gt;)
</pre>
</div>

</div>
<div class="Indented">
This code generates the following JavaScript code:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Jx Emitted Code<a class="Label" name="lst:Jx-Emitted-Code"> </a>
</div>
<pre class="listing brush: scala">function(it) {
  var df = document.createDocumentFragment();
  var vINIJ1YTZG5 = document.createElement(’div’);
  df.appendChild(vINIJ1YTZG5);
  vINIJ1YTZG5.appendChild(document.createTextNode(’Hi there’));
  return df;
}
</pre>
</div>

</div>
<div class="Indented">
As you can see, Lift took our XML code and transformed it into a JavaScript function that dynamically creates a document fragment containing the given NodeSeq. The <tt>it</tt> parameter can be any JavaScript object; we’ll cover how you use it in a moment. The name of the <i>var</i> is automatically and randomly generated to ensure uniqueness.
</div>
<div class="Indented">
Of course, if that was all Lift was doing that’s not much help. At this point we’ve only generated a function that generates XML. Let’s take a look on a more complex example that shows the real power of the Jx classes. Assume we have a JSON structure that contains an array of objects containing firstName and lastName properties. This JSON structure could look something like:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Sample JSON Structure<a class="Label" name="lst:Sample-JSON-Structure"> </a>
</div>
<pre class="listing brush: scala">var list = {
    persons: [
        {name: "Thor", race: "Asgard"}, 
        {name: "Todd", race: "Wraith"}, 
        {name: "Rodney", race: "Human"}
    ]
}
// Guess what I’ve been watching lately ?
</pre>
</div>

</div>
<div class="Indented">
Now we can use a combination of Jx classes to render this content as an HTML dynamic list:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Rendering a JSON List Via Jx<a class="Label" name="lst:Rendering-a-JSON-list"> </a>
</div>
<pre class="listing brush: scala">def renderPerson = 
  Jx(&lt;li class="item_header"&gt; {JsVar("it", "name")} 
       is {JsVar("it", "race")}&lt;/li&gt;)
Jx(&lt;ul&gt;{JxMap(JsVar("it.persons"), renderPerson)}&lt;/ul&gt;)
</pre>
</div>

</div>
<div class="Indented">
Well what this code does is this:
</div>
<ol>
<li>
Construct an &lt;ul&gt; list that contains a bunch of elements
</li>
<li>
JxMap takes a JavaScript object, in this case <tt>it.persons</tt> (remember <tt>it</tt> is the parameter of the generated function), and iterate for each element of the array and apply the renderPerson function. Of course each element of the array will be a JSON object containing name and race properties.
</li>
<li>
The <tt>renderPerson</tt> function generates a JavaScript function as we’ve already shown, and renders the JavaScript code that generates the &lt;li&gt; elements containing the name value followed by “is” followed by the race value.
</li>
<li>
If we send this generated JavaScript function to client and calling it by pass the <i>list</i> variable above It will create the following document fragment:
</li>

</ol>
<div class="Unindented">
<div class="listing">
<pre class="listing brush: scala">&lt;ul&gt;
 &lt;li class="item_header"&gt;Thor is Asgard&lt;/li&gt;
 &lt;li class="item_header"&gt;Todd is Wraith&lt;/li&gt;
 &lt;li class="item_header"&gt;Rodney is Human&lt;/li&gt;
&lt;/ul&gt;
</pre>
</div>

</div>
<div class="Indented">
With a couple of lines of code we’ve managed to generate the JavaScript code that creates document fragments dynamically. Here is the list of JX classes that you may find interesting:
</div>
<div class="Indented">
<div class="center">
<table>
<tr>
<td align="left" valign="top">
Class
</td>
<td align="left" valign="top" style="width: 4in;">
Description
</td>

</tr>
<tr>
<td align="left" valign="top">
JxBase
</td>
<td align="left" valign="top" style="width: 4in;">
The parent trait for all other Jx classes
</td>

</tr>
<tr>
<td align="left" valign="top">
JxMap
</td>
<td align="left" valign="top" style="width: 4in;">
Iterates over a JavaScript array and applies a function on each element
</td>

</tr>
<tr>
<td align="left" valign="top">
JxMatch
</td>
<td align="left" valign="top" style="width: 4in;">
Match a JsExp against a sequence of JsCase
</td>

</tr>
<tr>
<td align="left" valign="top">
JxCase
</td>
<td align="left" valign="top" style="width: 4in;">
Contains a JsExp for matching purposes and the NodeSeq to be applied in case the matching succeeds
</td>

</tr>
<tr>
<td align="left" valign="top">
JxIf
</td>
<td align="left" valign="top" style="width: 4in;">
Contains a JsExp and a NodeSeq to be applied only if JsExp is evaluated to true
</td>

</tr>
<tr>
<td align="left" valign="top">
JxIfElse
</td>
<td align="left" valign="top" style="width: 4in;">
Similar with JxIf but it contains the else branch
</td>

</tr>
<tr>
<td align="left" valign="top">
Jx
</td>
<td align="left" valign="top" style="width: 4in;">
The basic application of the transformation from a NodeSeq to the JavaScript code
</td>

</tr>

</table>

</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-10.4">10.4</a> JSON
</h2>
<div class="Unindented">
JSON<span class="FootOuter"><span class="SupFootMarker"> [A] </span><span class="HoverFoot"><span class="SupFootMarker"> [A] </span>Java Script Object Notation - <a class="URL" href="http://www.json.org">http://www.json.org</a></span></span> is a way of structuring information in JavaScript code. One of its most common uses is to represent structured information on the wire. One example would be a JavaScript AJAX API where the server response is in fact a JSON construct. Let’s look at an example first in listing <a class="Reference" href="#lst:Ajax-JSON-response">10.4↓</a>:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Ajax JSON response<a class="Label" name="lst:Ajax-JSON-response"> </a>
</div>
<pre class="listing brush: scala"> class SimpleSnippet {
  def ajaxFunc() : JsCmd = {
    JsCrVar("myObject", JsObj(("persons", JsArray(
        JsObj(("name", "Thor"), ("race", "Asgard")),
        JsObj(("name", "Todd"), ("race", "Wraith")),
        JsObj(("name", "Rodney"), ("race", "Human"))
    )))) &amp; JsRaw("alert(myObject.persons[0].name)")
  }
​
  def renderAjaxButton(xhtml: Group): NodeSeq = {
    bind("ex", xhtml,         
            "button" -&gt; SHtml.ajaxButton(Text("Press me"), ajaxFunc _))
  }
 }
</pre>
</div>

</div>
<div class="Indented">
Your template would look like listing <a class="Reference" href="#lst:AJAX-Template">10.4↓</a>:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
AJAX Template<a class="Label" name="lst:AJAX-Template"> </a>
</div>
<pre class="listing brush: scala">    ...
    &lt;lift:SimpleSnippet.renderAjaxButton&gt;
        &lt;ex:button/&gt;
    &lt;/lift:SimpleSnippet.renderAjaxButton&gt;
    ...
</pre>
</div>

</div>
<div class="Indented">
First off, we have a simple snippet function called <tt>renderAjaxButton</tt>. Here we’re binding the ex:button tag and render a XHTML button tag that when pressed will send an Ajax request to server. When this request is received, the <tt>ajaxFunc</tt> is executed and the JsCmd response is turned into a JavaScript content type response. In <tt>ajaxFunc</tt> we construct a JSON object (the same one we used previously for the persons object). We assign the JSON structure to the JavaScript variable <tt>myObject</tt> and them call alert on the first element on the persons object. The rendered JavaScript code that will be send down the wire will be:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Generated JavaScript<a class="Label" name="lst:Generated-JavaScript"> </a>
</div>
<pre class="listing brush: scala">var myObject = {’persons’: [{’name’: ’Thor’, ’race’: ’Asgard’}, 
                            {’name’: ’Todd’, ’race’: ’Wraith’} , 
                            {’name’: ’Rodney’, ’race’: ’Human’}]}; 
alert(myObject.persons[0].name);
</pre>
</div>

</div>
<div class="Indented">
So in your page when you press the button you’ll get an alert dialog saying “Thor”. Here we used the JsRaw class which basically renders the exact thing you passed to it: raw JavaScript code.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-10.4.1">10.4.1</a> JSON forms<a class="Label" name="sub:JSON-forms"> </a>
</h3>
<div class="Unindented">
Now that we’ve covered sending JSON from the server to the client, let’s look at going in the opposite direction. Lift provides a mechanism for sending form data to the server encapsulated in a JSON object. In and of itself sending the data in JSON format is relatively simple; where Lift really adds value is via the JsonHandler<span class="FootOuter"><span class="SupFootMarker"> [B] </span><span class="HoverFoot"><span class="SupFootMarker"> [B] </span>net.liftweb.http.JsonHandler</span></span> class. This class provides a framework for simplifying processing of submitted JSON data. To start, let’s look at some example template code for a JSON form:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Simple JSON form<a class="Label" name="lst:A-Simple-JSON-form"> </a>
</div>
<pre class="listing brush: scala">&lt;lift:surround with="default" at="content"&gt;      
    &lt;lift:JSONForm.head /&gt;      
    &lt;lift:JSONForm.show&gt;
      &lt;input type="text" name="name" /&gt;
      &lt;br /&gt;
      &lt;input type="text" name="value" /&gt; 
      &lt;br /&gt;  
      &lt;input type="radio" name="vehicle" value="Bike" /&gt; 
      &lt;input type="radio" name="vehicle" value="Car" /&gt; 
      &lt;input type="radio" name="vehicle" value="Airplane" /&gt; 
      &lt;br /&gt; 
      &lt;select name="cars"&gt;
        &lt;option value="volvo"&gt;Volvo&lt;/option&gt; 
        &lt;option value="saab"&gt;Saab&lt;/option&gt; 
        &lt;option value="opel"&gt;Opel&lt;/option&gt;  
        &lt;option value="audi"&gt;Audi&lt;/option&gt;  
      &lt;/select&gt;
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/lift:JSONForm.show&gt;
    &lt;div id="json_result"&gt;&lt;/div&gt; 
&lt;/lift:surround&gt;
</pre>
</div>

</div>
<div class="Indented">
A you can see, the XHTML template is relatively straightforward. The Snippet code is where things really get interesting:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
JSON Form Snippet Code
</div>
<pre class="listing brush: scala">class JSONForm {      
    def head = 
    &lt;head&gt;
    &lt;script type="text/javascript" 
            src={"/" + LiftRules.resourceServerPath + "/jlift.js"} /&gt;
    {Script(json.jsCmd)}
    &lt;/head&gt; 
   
    def show(html: Group): NodeSeq = {
        SHtml.jsonForm(json, html) 
    } 
​
    import JsCmds._ 
    object json extends JsonHandler {
        def apply(in: Any): JsCmd = SetHtml("json_result", in match { 
            case JsonCmd("processForm", _, p: Map[String, _], _) =&gt; {
                // process the form or whatever 
                println("Cars = " + urlDecode(p("cars"))) 
                println("Name = " + urlDecode(p("name"))) 
                &lt;b&gt;{p}&lt;/b&gt; 
            }
            case x =&gt; &lt;b&gt;Problem... didn’t handle JSON message {x}&lt;/b&gt;
        })
    }
}  
</pre>
</div>

</div>
<div class="Indented">
The first thing we define is the <tt>head</tt> function. Its purpose is simply to generate the JavaScript functions that set up the form handling on the client side. That means that when the submit button is clicked, the contents of the form are turned into JSON and submitted via an Ajax call to the server. The <tt>show</tt> function defines the connection between the concrete JsonHandler instance that will process the form and the template HTML that contains the form. We perform this binding with the <tt>SHtml.jsonForm</tt> method. This wraps the HTML with a <tt>&lt;form&gt;</tt> tag and sets the <tt>onsubmit</tt> event to do JSON bundling.
</div>
<div class="Indented">
The key part of the equation is our JsonHandler object. The apply method is what will be called when the JSON object is submitted to the server. If the JSON is properly parsed then you’ll get a JsonCmd instance which you can use Scala’s matching to pick apart. The apply function needs to return a JsCmd (JavaScript code), which in this case sets the HTML content of the <tt>json_result</tt> div element. When the form is stringified into its JSON representation Lift uses a command property indicating the action that needs to be done on server and the actual JSON data. In the case of JSON forms the command is always “processForm” as this is important for pattern matching as seen above. The actual form content is a Map object that can be easily use to obtain the values for each form field.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-10.5">10.5</a> JqSHtml object
</h2>
<div class="Unindented">
SHtml generated code is independent on the JavaScript framework used. However <tt>net.liftweb.http.jquery.JsSHtml</tt> object contains artifacts that are bound with JQuery framework. For instance it contains the autocomplete function that renders an input type text element but when start typing it will suggest words starting with what you typed already. Please see <a class="URL" href="http://www.pengoworks.com/workshop/jquery/autocomplete.htm">http://www.pengoworks.com/workshop/jquery/autocomplete.htm</a> for examples.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-10.6">10.6</a> A recap
</h2>
<div class="Unindented">
We’ve seen so far how we can abstract JavaScript code at Scala level using Lift’s JS abstraction. You can model endless cases by using these abstractions. But let’s take a look on another example a bit more complex. It is about a fast search where you have a text box and when you hit enter it will return the list of items that contain that sequence. The list of items will be rendered in a DIV real estate.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Example template
</div>
<pre class="listing brush: scala">​
&lt;lift:surround with="default" at="content"&gt;
  &lt;lift:Hello.ajaxian&gt;            
    &lt;text:show/&gt;    
  &lt;/lift:Hello.ajaxian&gt;      
  &lt;div id="items_list" style="width: 300px; height: 100px; overflow: auto; border: 1px solid black;"&gt;   
  &lt;/div&gt;    
&lt;/lift:surround&gt;
</pre>
</div>

</div>
<div class="Indented">
So we just have a really simple snippet and the div placeholder.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Example snippet
</div>
<pre class="listing brush: scala">​
import JE._   
import net.liftweb.http.js.jquery.JqJE._      
import net.liftweb.http.SHtml._ 
import net.liftweb.util.Helpers._
import JsCmds._ 
​
val names = "marius" :: "tyler" :: "derek" :: "dave" :: "jorge" :: "viktor" :: Nil  
​
def ajaxian(html: Group) : NodeSeq = {
    bind("text", html,
            "show"  -&gt; ajaxText("Type something", {value =&gt; {
               val matches = names.filter(e =&gt; e.indexOf(value) &gt; -1)
               SetHtml("items_list", NodeSeq.Empty) &amp; 
               JsCrVar("items", JsArray(matches.map(Str(_)):_*)) &amp;
               JsCrVar("func", Jx(&lt;ul&gt;{
                                    JxMap(JsVar("it"), Jx(&lt;li&gt;&lt;a href=""&gt;{JsVar("it")}&lt;/a&gt;&lt;/li&gt;))                                   }                                    &lt;/ul&gt;).toJs) &amp;
               (ElemById("items_list") ~&gt; JsFunc("appendChild", Call("func", JsVar("items"))))
             }})
    )
} 
</pre>
</div>

</div>
<div class="Indented">
The part with the snippet is probably already familiar to you. We are calling the ajaxText function which renders an input text element. When you hit enter an Ajax request will be sent and the anonymous function that we bound here will be executed. Here is what happens:
</div>
<ol>
<li>
First filter out the names that contain the provided value in the input text. So all element that contain that sequence.
</li>
<li>
Then return a JsExp that we are building:<ol>
<li>
SetHtml is clearing out the div element that we’re using as a real estate for our search results list
</li>
<li>
Then we re declaring a JavaScript variable which is an array containing the resulting items that matched the search criteria.
</li>
<li>
Then we are declaring thr <tt>func</tt> variable which obviously is a function. We’ve seen above how to use the Jx artifacts. Now we are building a html list (<tt>&lt;ul&gt;</tt>) that for each element from the <tt>it</tt> variable will build the <tt>&lt;li&gt;</tt> sequences. The it variable is actually the paramter that this function takes which is the items array that we declared above.
</li>
<li>
After that we are obtaining the HTML node denominated by “items_list” id and call appendChild function of the Node object. The ~&gt; function is use to call functions of objects. Of course to the appendChild function we need to provide a parameter. This parameter is the document fragment returned by <tt>func</tt> function. When we are caling the <tt>func</tt> function we are passing items variable decalred above.
</li>

</ol>

</li>

</ol>
<div class="Unindented">
As you noticed already we composed a small JavaScript code by chainin multiple JS expressions/commands using the &amp; function.
</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-11">11</a> AJAX and Comet in Lift<a class="Label" name="cha:AJAX-and-COMET"> </a>
</h1>
<div class="Unindented">
In this chapter we’re going to discuss AJAX and Comet, two approaches to improving the user experience through dynamic web pages. While a full treatment of the techniques and technologies behind these approaches is beyond the scope of this book<span class="FootOuter"><span class="SupFootMarker"> [C] </span><span class="HoverFoot"><span class="SupFootMarker"> [C] </span>There are a number of good resources on the web that you can find by searching for “AJAX”.</span></span>, we’re going to cover the basics of how AJAX and Comet work. In particular, we’re going to look at how Lift handles them behind the scenes to simplify your work.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-11.1">11.1</a> What are AJAX and Comet, really?
</h2>
<div class="Unindented">
AJAX and Comet are variations on the traditional model of the web application request/response lifecycle. In the traditional model, the user starts by making a request for a page. The server receives this request, performs processing, then sends a response back to the user. The response is then rendered by the user’s browser. At this point there are no further interactions between the user and the server until the user clicks on a link or performs some other action that starts a completely new request/response lifecycle. AJAX and Comet extend this model to allow for asynchronous updates from either the user to the server (AJAX), or from the server back to the user (Comet).
</div>
<div class="Indented">
If we take the example of adding a comment to a blog post, the traditional model has the user fill in a form, hit the submit button, and send the request to the server. The server processes and adds the comment and then sends the updated blog post back to the user with the newly added comment. At the same time, if other people are viewing the blog post, they won’t see the new comment until they reload the page.
</div>
<div class="Indented">
The AJAX model of this session changes such that the display of the new comment is not tied to the response from the server. When the user hits submit, the request to add the comment is sent to the server <i>in the background</i>. While it’s being processed by the server, a JavaScript fragment (the “J” in AJAX) updates the user’s page via DOM<span class="FootOuter"><span class="SupFootMarker"> [D] </span><span class="HoverFoot"><span class="SupFootMarker"> [D] </span>Document Object Model. More information can be found at <a class="URL" href="http://www.w3.org/DOM/">http://www.w3.org/DOM/</a></span></span> and adds the comment without the need for a full page reload. 
</div>
<div class="Indented">
Comet changes the traditional model by using a long-polling HTTP request in the background that allows the server to push data to the browser without requiring additional requests. Essentially this is like AJAX, except in the opposite direction.
</div>
<div class="Indented">
While the AJAX model increases the richness of the User Experience for a single client at a time, Comet can do the same for multiple users. Going back to our example of a blog post, Comet would enable the server to notify anyone viewing the current blog post to automatically have their pages updated when the new comment is added.
</div>
<div class="Indented">
Figures <a class="Reference" href="#subfig:Traditional-Application-Model">a↓</a>, <a class="Reference" href="#subfig:AJAX-Application-Model">b↓</a>, and <a class="Reference" href="#subfig:COMET-Application-Model">c↓</a> show graphical representations of how the models differ in terms of timeline and server interaction.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="fig:model-comparisons"> </a><div class="multifigure">
<div class="center">
<span class="float">
<a class="Label" name="subfig:Traditional-Application-Model"> </a><div class="figure">
<div class="caption">
(a) Traditional Application Model
</div>
<img class="embedded" src="images/Traditional_Model.png" alt="figure images/Traditional_Model.png" style="width: 3in; max-width: 288px; height: auto; max-height: 216px;"/>

</div>

</span>
<span class="float">
<a class="Label" name="subfig:AJAX-Application-Model"> </a><div class="figure">
<div class="caption">
(b) AJAX Application Model
</div>
<img class="embedded" src="images/Ajax_Model.png" alt="figure images/Ajax_Model.png" style="width: 3in; max-width: 288px; height: auto; max-height: 216px;"/>

</div>

</span>

</div>
<span class="float">
<a class="Label" name="subfig:COMET-Application-Model"> </a><div class="figure">
<div class="caption">
(c) Comet Application Model
</div>
<img class="embedded" src="images/COMET_Model.png" alt="figure images/COMET_Model.png" style="width: 3in; max-width: 288px; height: auto; max-height: 216px;"/>

</div>

</span>
<div class="caption">
Figure 11.1 Application Model Comparisons
</div>

</div>

</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-11.2">11.2</a> Using AJAX in Lift
</h2>
<div class="Unindented">
In previous chapters we’ve shown how to synchronously process forms (chapter <a class="Reference" href="#cha:Forms-in-Lift">6↑</a>) and use JavaScript to perform client-side behavior (chapter<a class="Reference" href="#cha:Lift-and-Javascript">10↑</a>). AJAX blends these Lift techniques to give you powerful support for asynchronous client-server interaction. As with standard form and link elements, Lift uses methods on the <tt>SHtml</tt> object to generate AJAX components in a concise manner. We’ll cover each of the AJAX-specific <tt>SHtml</tt> methods in a later section, but for now we want to cover the high-level aspects of using AJAX in Lift.
</div>
<div class="Indented">
The first thing we want to point out is that AJAX generators take callback methods just like regular element generators. The major difference is that while standard <tt>SHtml</tt> generator callbacks return <tt>scala.Any</tt>, AJAX callbacks must return a <tt>net.liftweb.http.js.JsCmd</tt>. The reason is that the return from the callback is itself a client-side callback that can be used to update the client content. An example is shown in Listing <a class="Reference" href="#lst:A-simple-AJAX-example">11.2↓</a>. In this example we generate a button, that when clicked, will log a message and then set the contents of the div named <tt>my-div</tt> to a <tt>Text</tt> element. As you can see, adding client-side content changes is trivial.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A simple AJAX example<a class="Label" name="lst:A-simple-AJAX-example"> </a>
</div>
<pre class="listing brush: scala">import _root_.net.liftweb.http.SHtml._
// The next two imports are used to get some implicit conversions
// in scope.
import _root_.net.liftweb.http.JE._
import _root_.net.liftweb.http.JsCmds._
// Use logging facilities
import _root_.net.liftweb.util.Log
​
// define a snippet method
def myFunc(html: NodeSeq) : NodeSeq = {
  bind("hello", html, "button" -&gt; ajaxButton(Text("Press me"), {() =&gt; 
    Log.info("Got an AJAX call")
    SetHtml("my-div", Text("That’s it")) 
  })
}
</pre>
</div>

</div>
<div class="Indented">
The second important aspect of Lift’s AJAX support is that behind the scenes Lift provides a robust mechanism for AJAX submission. For example, Lift provides its own JavaScript that handles retrying when the submission times out. You can control the timeout duration and retry count through <tt>LiftRule</tt>’s <tt>ajaxPostTimeout</tt> (in milliseconds) and <tt>ajaxRetryCount</tt> variables, respectively.
</div>
<div class="Indented">
The third aspect of Lift’s AJAX support is that it’s so easy to enable. Lift automatically takes care of adding the proper JavaScript libraries to your templates when they’re rendered, and sets up the proper callback dispatch for you. By default, dispatch is done relative to the <tt>/ajax_request</tt> path in your web context, but Lift allows you change this via the <tt>LiftRules.ajaxPath</tt> variable. 
</div>
<div class="Indented">
The final aspect is the flexibility the library provides. Besides standard form elements and links that can be AJAXified, Lift also provides the <tt>SHtml.ajaxCall</tt> method which constructs a <tt>JsExp</tt> that you can use directly on <i>any</i> element. In addition, it allows you to construct a <tt>String</tt> argument to your callback function via JavaScript so that you have full access to client-side data.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-11.3">11.3</a> A more complex AJAX example<a class="Label" name="sub:A-more-complex-ajax-example"> </a>
</h2>
<div class="Unindented">
Let’s take a look on a comparison example. We’ve seen how to use <tt>SHtml.ajaxButton</tt>, so let’s see in Listing <a class="Reference" href="#lst:Ajax-comparison-example">11.3↓</a> how can we achieve the same effect using <tt>SHtml.ajaxCall</tt> and <tt>SHtml.ajaxInvoke</tt>:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
AJAX comparison example<a class="Label" name="lst:Ajax-comparison-example"> </a>
</div>
<pre class="listing brush: scala">​
class SimpleSnippet {
  import _root_.net.liftweb.http.js.{JE,JsCmd,JsCmds}
  import JsCmds._ // For implicits
  import JE.{JsRaw,Str}
​
  def ajaxFunc1() : JsCmd = JsRaw("alert(’Button1 clicked’)")
​
  def ajaxFunc2(str: String) : JsCmd = {
    println("Received " + str)
    JsRaw("alert(’Button2 clicked’)")
  }
​
  def ajaxFunc3() : JsCmd = JsRaw("alert(’Button3 clicked’)")
​
  def renderAJAXButtons(xhtml: Group): NodeSeq = {
    bind("ex", xhtml,         
            "button1" -&gt; SHtml.ajaxButton("Press me", ajaxFunc1 _),
            "button2" -&gt; 
              // ajaxCall and ajaxInvoke actually returns a pair (String, JsExp). 
              // The String is used for garbage collection, so we only need
              // to use the JsExp element (_2).
              &lt;button onclick={SHtml.ajaxCall(Str("Button-2"), ajaxFunc2 _)._2}&gt;
                Press me 2&lt;/button&gt;,
            "button3" -&gt; 
              &lt;button onclick={SHtml.ajaxInvoke(ajaxFunc3 _)._2}&gt;
                Press me 3&lt;/button&gt;)
 }
}
​
</pre>
</div>

</div>
<div class="Indented">
Basically, in Listing <a class="Reference" href="#lst:Ajax-comparison-example">11.3↑</a>, we created three AJAX buttons using three different SHtml functions. The difference between <tt>ajaxCall</tt> and <tt>ajaxInvoke</tt> is that for <tt>ajaxCall</tt> you can specify a <tt>JsExp</tt> parameter that will be executed on the client side. The result of this <tt>JsExp</tt> will be sent to the server. In our case this parameter is simply a static String, <tt>Str(“Button-2”)</tt>, but you can provide any <tt>JsExp</tt> code here to calculate a client-side value to be passed to your callback. For an overview of the rest of the <tt>SHtml</tt> generator functions please see Chapter <a class="Reference" href="#cha:Forms-in-Lift">6↑</a>.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-11.4">11.4</a> AJAX Generators in Detail<a class="Label" name="sub:AJAX-Generators-in-detail"> </a>
</h2>
<div class="Unindented">
The following table provides a brief synopsis of the AJAX generator methods on the<br/>
 <tt>net.liftweb.http.SHtml</tt> object:
</div>
<div class="Indented">
<table>
<tr>
<td align="left" valign="top">
Function name
</td>
<td align="left" valign="top" style="width: 4in;">
Description
</td>

</tr>
<tr>
<td align="left" valign="top">
ajaxButton
</td>
<td align="left" valign="top" style="width: 4in;">
Renders a button that will submit an AJAX request to server
</td>

</tr>
<tr>
<td align="left" valign="top">
a
</td>
<td align="left" valign="top" style="width: 4in;">
Renders an anchor tag that when clicked will submit an AJAX request
</td>

</tr>
<tr>
<td align="left" valign="top">
makeAJAXCall
</td>
<td align="left" valign="top" style="width: 4in;">
Renders the JavaScript code that will submit an AJAX request
</td>

</tr>
<tr>
<td align="left" valign="top">
span
</td>
<td align="left" valign="top" style="width: 4in;">
Renders a span element that when clicked will execute a <tt>JsCmd</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
ajaxCall
</td>
<td align="left" valign="top" style="width: 4in;">
Renders the JavaScript code that will submit an AJAX request but it will also send the value returned by the <tt>JsExp</tt> provided. 
</td>

</tr>
<tr>
<td align="left" valign="top">
ajaxInvole
</td>
<td align="left" valign="top" style="width: 4in;">
Similar to <tt>ajaxCall</tt> but there is no value to be computed and sent to the server
</td>

</tr>
<tr>
<td align="left" valign="top">
toggleKids
</td>
<td align="left" valign="top" style="width: 4in;">
Provides the toggle effect on an element. When clicked it will also send an AJAX call
</td>

</tr>
<tr>
<td align="left" valign="top">
ajaxText
</td>
<td align="left" valign="top" style="width: 4in;">
Renders an input text element that will send an AJAX request on blur.
</td>

</tr>
<tr>
<td align="left" valign="top">
jsonText
</td>
<td align="left" valign="top" style="width: 4in;">
Renders an input type text element the will send a JSON request on blur.
</td>

</tr>
<tr>
<td align="left" valign="top">
ajaxCheckbox
</td>
<td align="left" valign="top" style="width: 4in;">
Renders a checkbox element that when clicked will send an AJAX call
</td>

</tr>
<tr>
<td align="left" valign="top">
ajaxSelect
</td>
<td align="left" valign="top" style="width: 4in;">
Renders a select element then sends an AJAX call when the value changes
</td>

</tr>
<tr>
<td align="left" valign="top">
ajaxForm
</td>
<td align="left" valign="top" style="width: 4in;">
Wraps a <tt>NodeSeq</tt> that represents the form’s content and makes an AJAX call when the form is submitted.
</td>

</tr>
<tr>
<td align="left" valign="top">
jsonForm
</td>
<td align="left" valign="top" style="width: 4in;">
Similar to <tt>ajaxForm</tt>, but on the client side, the form is JSONified and the JSON content sent to the server and processed by <tt>JsonHandler</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
swappable
</td>
<td align="left" valign="top" style="width: 4in;">
Renders a span that contains one visible element and the other hidden. When the visible element is clicked it will be hidden and the other one will be shown
</td>

</tr>

</table>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-11.5">11.5</a> Comet and Lift<a class="Label" name="sec:COMET"> </a>
</h2>
<div class="Unindented">
Figure <a class="Reference" href="#subfig:COMET-Application-Model">c↑</a> diagrams the interaction between client and server in the Comet. model. There are several resources on the web that explain the history and specific techniques related to Comet<span class="FootOuter"><span class="SupFootMarker"> [E] </span><span class="HoverFoot"><span class="SupFootMarker"> [E] </span><a class="URL" href="http://en.wikipedia.org/wiki/Comet_(programming)">http://en.wikipedia.org/wiki/Comet_(programming)</a> is a good start.</span></span>, so we won’t get too detailed here. In essence Comet is not a technology but a technique which allows a web application to push messages from server to client. There are a couple of approaches used to make this work, but the approach that Lift uses is long polling, so that’s what we’ll be covering here. As an example, consider a web chat application where you can chat real-time with friends. Let’s take a quick look at how receiving a message using Comet works in Lift:
</div>
<ol>
<li>
The client sends an AJAX request to the server asking for any new messages.
</li>
<li>
The server does not respond immediately but waits until there is a message that needs to be sent for that client. 
</li>
<li>
When a message is available, the server responds to the initial request from the client with the new message(s).
</li>
<li>
The client receives the response, processes it, and issues another AJAX request, and the process continues.
</li>

</ol>
<div class="Unindented">
Of course, things are more complicated then that. For instance, it may take a while until the response is actually returned to the client. During this delay, the connection could be dropped for any number of reasons. The client should be smart enough to re-establish the connection automatically. But there is another problem - scalability. If we have these long-running connections, the server would typically put the processing threads into a waiting state until messages are available to send back to the client. Having many waiting threads is a scalability killer because numerous threads from the web container’s thread pool will lie in the wait state doing nothing until, before you know it, your entire thread pool is empty. The immediate consequence is that your server can not do any other request processing. Because of this, a thread-per-connection approach combined with long-running connections is totally unacceptable.
</div>
<div class="Indented">
The key to scalability is NON-BLOCKING IO. Most operating systems support non-blocking I/O, which actually means that when you utilize an I/O resource for reading or writing (say the streams from a socket) there is no blocking operation. So if you read from a stream your read function would immediately return regardless of whether there is data available or not. In Java, non-blocking I/O is provided by the Java New I/O (NIO) library using Selectors and perhaps the Reactor pattern<span class="FootOuter"><span class="SupFootMarker"> [F] </span><span class="HoverFoot"><span class="SupFootMarker"> [F] </span>A nice overview of NIO is at <a class="URL" href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></span></span>. This has a major impact on scalability because the threads are only held as long as there is work to do. Once they’re finished with the available data, they are returned to the thread pool so that they may be reused for processing other requests. In this model the threads are allocated to connections only when data is available for processing, which inherently leads to better resource utilization.
</div>
<div class="Indented">
<div class="defskip"> </div>
</div>
<div class="Indented">
<div class="center">
<div class="Shadowbox" style="width: 75%;">
Note: This is somewhat off-topic, but if you’re looking to do a lot of work with NIO and networking, we recommend looking at the Apache MINA project at <a class="URL" href="http://mina.apache.org/">http://mina.apache.org/</a>. MINA provides some nice abstractions for NIO that allows you use a stateful approach to developing NIO applications without having to deal with a lot of the underlying details of using NIO.
</div>

</div>

</div>
<div class="Indented">
<div class="defskip"> </div>
</div>
<div class="Indented">
Having nonblocking I/O enabled by the web container also has a major impact on application scalability with regard to long-lived connections from client to server. In addition, the Lift framework has support for Jetty Continuations, which work like this: 
</div>
<ol>
<li>
You application receives a request and wants to wait to respond, as there is no message yet.
</li>
<li>
You call suspend on the Jetty Continuation object. Here, Jetty will throw a special exception that will be caught in the container. The current thread is immediately returned to the thread pool, so it can process other requests.
</li>
<li>
Assume that, after a while, you have a message for that particular client. You call resume on the same Continuation object. This time, Jetty will actually replay the initial HTTP request, and your servlet behaves like that request was just received from the client and, of course, returns the appropriate response.
</li>

</ol>
<div class="Unindented">
More details on Jetty’s Continuations are available on the Jetty web site at <a class="FlexURL" href="http://docs.codehaus.org/display/JETTY/Continuations">http://docs.codehaus.org/display/JETTY/Continuations</a>. 
</div>
<div class="Indented">
If you run your Lift application in a Jetty container, Lift will automatically detect that and utilize the Continuation mechanism. Currently, on other containers, Comet in Lift will still work but won’t scale as well because Continuations aren’t supported. However, the Servlet 3.0 spec contains a more generic facility, called Suspended Requests, that will make this feature usable across a variety of containers.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-11.5.1">11.5.1</a> Actors in Scala
</h3>
<div class="Unindented">
It is important to understand that Comet support in Lift is primarily driven via Scala Actors. We won’t go into too much detail regarding Scala Actors, as you can find very detailed information in the paper by Philipp Haller, <i>Actors that Unify Threads And Events</i><span class="FootOuter"><span class="SupFootMarker"> [G] </span><span class="HoverFoot"><span class="SupFootMarker"> [G] </span><a class="FlexURL" href="http://lamp.epfl.ch/~phaller/doc/haller07coord.pdf">http://lamp.epfl.ch/~phaller/doc/haller07coord.pdf</a></span></span>. 
</div>
<div class="Indented">
Scala Actors are based on the concepts of the Erlang<span class="FootOuter"><span class="SupFootMarker"> [H] </span><span class="HoverFoot"><span class="SupFootMarker"> [H] </span><a class="URL" href="http://erlang.org/">http://erlang.org/</a></span></span> Actors model where an Actor is an asynchronous component that receives messages and sends or replies to messages. In Erlang, processes communicate via a very simple and effective messaging system built into the VM.
</div>
<div class="Indented">
In Scala, however, Actors are supported at the library level and not at the language level. While less integrated, this does provide greater flexibility as the Actors library evolution does not impact the language itself. Since Scala typically sits on top of the JVM, Scala Actors are not bound to processes but rather to JVM threads. The key to understanding the scalability of Scala Actors is that there is no one-to-one relationship between Actors and Threads. For instance, when an Actor is waiting for a message we don’t end up having a thread waiting for a lock. Instead, the Actor body is impersonated by a closure that captures the rest of the computation. This closure is ’cached’ internally until a message is designated for this Actor to consume. In particular, Scala’s Actor library leverages the <tt>match</tt> construct to allow very fine-grained selection of messages for processing. Another interesting note is that the Actor body (<tt>react</tt> function) never returns normally; in fact, the return type of the react function is <tt>Nothing</tt>.
</div>
<div class="Indented">
Let’s take a look on a simple Actor-based example in Listing <a class="Reference" href="#lst:PingPong-example">11.5.1↓</a>:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
PingPong example<a class="Label" name="lst:PingPong-example"> </a>
</div>
<pre class="listing brush: scala">import scala.actors._ 
import scala.actors.Actor._
​
object PingPong extends Application {
  var count = 0;
  val pong = actor {
    loop {
      react {
        case Ping =&gt; println("Actor Pong Received Ping")
          sender ! Pong
        case Stop =&gt; println("Stopping Pong")         
          exit()
       }
    }
  }
  val ping = actor {
    pong ! Ping
    loop {
      react {
        case Pong =&gt; println("Actor Ping Received Pong")
           count = count + 1;
        if (count &lt; 3) {
          sender ! Ping
        } else {
          sender ! Stop
          println("Stopping Ping")
          exit()
        }
      }
    }
  }
}
case object Ping 
case object Pong 
case object Stop
</pre>
</div>

</div>
<div class="Indented">
This is a trivial example in which we have two Actors exchanging <tt>Ping</tt>, <tt>Pong</tt> and <tt>Stop</tt> messages (note that the messages are case objects for pattern matching purposes). Also note that we did not explicitly used threads anywhere. We also did not use any thread blocking technique such as synchronized blocks. The reason is that we don’t have to. Actors’ message-passing mechanism is generally thread-safe (although deadlock is still possible due to dependent Actors<span class="FootOuter"><span class="SupFootMarker"> [I] </span><span class="HoverFoot"><span class="SupFootMarker"> [I] </span><a class="URL" href="http://ruben.savanne.be/articles/concurrency-in-erlang-scala">http://ruben.savanne.be/articles/concurrency-in-erlang-scala</a></span></span>). Note that threads are used internally and in this specific example the execution may even occur on the same thread. The reason is that internally the Actors library uses a thread pool, and when an Actor receives a message the execution occurs in a thread from the thread pool. This is also a key to Actors’ scalability, because they allow threads to be used very efficiently and returned to the pool as soon as the Actor consumes the message.
</div>
<div class="Indented">
Getting deeper into the details of actions is beyond the scope of this book, but we recommend that you read other materials in order to fully understand Scala actors. In particular, Philipp Haller has a nice page summarizing papers and tutorials on actors at <a class="FlexURL" href="http://lamp.epfl.ch/~phaller/actors.html">http://lamp.epfl.ch/~phaller/actors.html</a>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-11.5.2">11.5.2</a> Building a Comet Application in Lift
</h3>
<div class="Unindented">
As we have seen, Comet support in Lift is provided by Scala Actors. Lift greatly simplifies the use of Actors by providing a <tt>CometActor</tt> trait that does almost all the work. You simply extend <tt>CometActor</tt> with your own class and fill in some implementation methods. 
</div>
<div class="Indented">
<div class="center">
<div class="Shadowbox" style="width: 75%;">
Note that your CometActor classes needs to exist in a <tt>comet</tt> subpackage as configured by <tt>LiftRules.addToPackages</tt>. For example, if you call <tt>LiftRules.addToPackages(“com.myapp”)</tt> in your boot method, your comet actors must exist in the <tt>com.myapp.comet</tt> package.
</div>

</div>

</div>
<div class="Indented">
Let’s take a look at a simple example. Let’s say that we want to build a Clock snippet where the server will update the client page with the current server time every 10 seconds. First, we need a template, as shown in Listing <a class="Reference" href="#lst:Comet-Clock-markup">11.5.2↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Comet Clock markup example<a class="Label" name="lst:Comet-Clock-markup"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:surround with="default" at="content"&gt;
    &lt;lift:comet type="Clock" name="Other"&gt;
        Current Time: &lt;clk:time&gt;Missing Clock&lt;/clk:time&gt;
    &lt;/lift:comet&gt;  
&lt;/lift:surround&gt;
</pre>
</div>

</div>
<div class="Indented">
In our template, we use the <tt>&lt;lift:comet&gt;</tt> tag to bind the <tt>CometActor</tt> to the portion of the template where it will render content, and the body of the <tt>&lt;lift:comet&gt;</tt> tag is quite similar to the body of a snippet. The <tt>&lt;clk:time&gt;</tt> tag will be bound by the <tt>Clock</tt> actor. The <tt>type</tt> attribute tells Lift which <tt>CometActor</tt> to call, and the <tt>name</tt> attribute is the name of this <tt>CometActor</tt>. The <tt>name</tt> attribute is a discriminator that allows you to have more then one <tt>CometActor</tt> of the same type on a given page. Next, we need to define our actor as shown in Listing <a class="Reference" href="#lst:Clock-Comet-Actor">11.5.2↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Clock Comet Actor example<a class="Label" name="lst:Clock-Comet-Actor"> </a>
</div>
<pre class="listing brush: scala">package com.myapp.comet
​
class Clock extends CometActor {
  override def defaultPrefix = Full("clk")   
​
  def render = bind("time" -&gt; timeSpan)
  
  def timeSpan = (&lt;span id="time"&gt;{timeNow}&lt;/span&gt;)
​
  // schedule a ping every 10 seconds so we redraw
  ActorPing.schedule(this, Tick, 10000L) 
​
  override def lowPriority : PartialFunction[Any, Unit] = {
    case Tick =&gt; {
      println("Got tick " + new Date());
      partialUpdate(SetHtml("time", Text(timeNow.toString))) 
      // schedule an update in 10 seconds
      ActorPing.schedule(this, Tick, 10000L) 
    }
  }
}
case object Tick
</pre>
</div>

</div>
<div class="Indented">
First, our actor defines the default prefix, which should be used for all nodes that will be bound inside <tt>&lt;lift:comet&gt;</tt> tag. In our case, we’re using the <tt>clk</tt> prefix.
</div>
<div class="Indented">
Next, we have the <tt>render</tt> function where we do the binding between the <tt>&lt;clk:time&gt;</tt> node and the result of the <tt>timespan</tt> function. Basically, the <tt>&lt;clk:time&gt;</tt> node will be replaced by the <tt>span</tt> element returned by the <tt>timespan</tt> function. It is important to note that Comet content rendered by the <tt>&lt;lift:comet&gt;</tt> tag is a <tt>&lt;span&gt;</tt> tag by default. This default can be changed by overriding the <tt>parentTag</tt> function in your comet actor.
</div>
<div class="Indented">
<tt>timeNow</tt> is a function from the <tt>net.liftweb.util.TimeHelpers</tt> trait that returns the current system time. We use the <tt>net.liftweb.util.ActorPing.schedule</tt> method to send a <tt>Tick</tt> message back to our actor after 10 seconds. This method is part of the the <tt>Clock</tt> class default constructor, and therefore will be called when the <tt>Clock</tt> class is instantiated. 
</div>
<div class="Indented">
Finally, we have the <tt>lowPriority</tt> function that returns a <tt>PartialFunction</tt>. To process messages in your CometActor, you can override the following functions: <tt>highPriority</tt>,<br/>
<tt>mediumPriority</tt>, and <tt>lowPriority</tt>. This multiplicity of functions is just a way of prioritizing application messages. The only thing that we do here is to pattern match the messages. In this simple example, we have only the <tt>Tick</tt> object. When a <tt>Tick</tt> is sent by the <tt>ActorPing</tt>, our code gets executed and the following actions occur:
</div>
<ol>
<li>
We print the current time to the console (just for fun)
</li>
<li>
We call <tt>partialUpdate</tt> function. With a partial update we can update specific fragments on the client side and not actually re-render the entire content that the CometActor may produce. This optimization allows us to send something very specific to be updated on the client side. If we call <tt>reRender(true)</tt> instead, the entire real estate on the client side will be re-rendered. Getting back to our <tt>partialUpdate</tt> call, we are basically sending a <tt>JsCmd</tt> that we use to set the XHTML content for the element that has the id “time”. This is the <tt>span</tt> element returned by the <tt>timeSpan</tt> function. Since <tt>partialUpdate</tt> takes a <tt>JsCmd</tt>, you can use it to do just about anything on the client side accessible from JavaScript.
</li>
<li>
We tell <tt>ActorPing</tt> to send another Tick message after 10 seconds. 
</li>

</ol>
<div class="Unindented">
As you have seen, with just a few lines of code, we were able to create a Clock application in which the server updates the client every 10 seconds. Of course, this is just a trivial example, but now, you should have a clear picture of how CometActor works, so you can build more complex cases for your Lift application.
</div>
<div class="Indented">
<div class="defskip"> </div>
</div>
<div class="Indented">
<div class="center">
<div class="Shadowbox" style="width: 75%;">
Note: As described earlier It is also possible to use notices (notice/warning/error) from your comet actor. The CometActor trait already has notice, warning and error methods on it that will properly handle sending these messages to the client. Do not use the notice/warning/error methods on S, since they assume a stateful response and will not work from within a Comet callback.
</div>

</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-11.6">11.6</a> Coordinating Between Multiple Comet Clients
</h2>
<div class="Unindented">
So far, our example has only shown a self-contained <tt>CometActor</tt> for the clock. But what if we want to have interaction between different clients? Scala’s actors are still the answer, but with a twist—we can use a singleton actor object that coordinates with the CometActor objects so that it can send messages to all of them. First, we define our singleton actor, as shown in Listing <a class="Reference" href="#lst:Singleton-Actor">11.6↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Singleton Actor<a class="Label" name="lst:Singleton-Actor"> </a>
</div>
<pre class="listing brush: scala">case class SubscribeClock(clock : Clock)
case class UnsubClock(clock : Clock)
​
object ClockMaster extends Actor {
  private var clocks : List[Clock] = Nil
  def act = loop {
    react {
       case SubscribeClock(clk) =&gt;
        clocks ::= clk
      case UnsubClock(clk) =&gt;
        clocks -= clk
      case Tick =&gt;
        clocks.foreach(_ ! Tick)
    }
  }
}
</pre>
</div>

</div>
<div class="Indented">
We’ve defined two case classes representing messages for subscribing and unsubscribing to the <tt>ClockMaster</tt> actor. The <tt>ClockMaster</tt> itself is a simple Actor (not a <tt>CometActor</tt>) that defines a simple message loop. It can either subscribe a new clock, unsubscribe to an existing clock, or distribute a Tick to all subscribed clocks. The other half of this equation slightly modifies our Clock class (as shown in Listing <a class="Reference" href="#lst:Modified-Clock-Class">11.6↓</a>) so that it subscribes and unsubscribes to the ClockMaster at initialization and shutdown, respectively. 
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Modified Clock Class<a class="Label" name="lst:Modified-Clock-Class"> </a>
</div>
<pre class="listing brush: scala">...
override def localSetup {
  ClockMaster ! SubscribeClock(this)
  super.localSetup()
}
override def localShutdown {
  ClockMaster ! UnsubClock(this)
  super.localShutdown()
}
</pre>
</div>

</div>
<div class="Indented">
Now, we can add an AJAX button (to an administration page, of course) that would allow the administrator to update everyone’s clocks at once. Listing <a class="Reference" href="#lst:The-Admin-Tick">11.6↓</a> shows how we would bind in the button. 
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
The Admin Tick<a class="Label" name="lst:The-Admin-Tick"> </a>
</div>
<pre class="listing brush: scala">bind("admin", xhtml, "tick" -&gt;
     SHtml.ajaxButton("Tock!", {
        () =&gt; ClockMaster ! Tick
     }))
</pre>
</div>

</div>
<div class="Indented">
Here’s what’s happening behind the scenes in our modified Clock application. Lift first identifies a Comet request by matching against the path given by the <tt>LiftRules.cometPath</tt> variable. Essentially the flow is as follows:
</div>
<ol>
<li>
Lift gets a Comet request.
</li>
<li>
Lift checks the <tt>CometActor</tt>s to see if there are any messages. If there are no messages to be sent to this client, and the application is running in a Jetty container, the Jetty continuation is suspended, but no response is actually sent to client.
</li>
<li>
Later, when your Comet actor is asked to render or partially update, the response is calculated, and the Jetty continuation is resumed. 
</li>
<li>
When Lift gets the resumed request from the container it returns the response calculated by the <tt>CometActor</tt> to the client.
</li>

</ol>
<div class="Unindented">
Note that <tt>CometActor</tt>s work even if you are not using Jetty container; the only issue is that you won’t benefit from the improved scalability of the suspend/resume mechanism offered by the Jetty container.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-11.7">11.7</a> Summary
</h2>
<div class="Unindented">
In this chapter, we explored how easily you can create AJAX and Comet interfaces in Lift. We discussed the underlying techniques used for AJAX and Comet, as well as how Lift provides support functions and classes to simplify writing apps that utilize these techniques. We showed examples of how to use the <tt>SHtml</tt> object to create AJAX-enabled form elements and how to customize things like the AJAX request path in Lift. We reviewed Scala actors and how the <tt>CometActor</tt> trait is used to make a Comet event handler. We also discussed how Lift works to alleviate scalability issues with Comet on supported containers. Finally, we wrote a simple Clock application and showed how you can mix AJAX and Comet in the same application. 
</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-12">12</a> JPA Integration<a class="Label" name="cha:JPA-Integration"> </a>
</h1>
<div class="Unindented">
<div class="Framed" style="width: 100%;">
This chapter is still under active development. The contents will change.
</div>

</div>
<div class="Indented">
The Java Persistence API<span class="FootOuter"><span class="SupFootMarker"> [J] </span><span class="HoverFoot"><span class="SupFootMarker"> [J] </span><a class="FlexURL" href="http://java.sun.com/javaee/overview/faq/persistence.jsp">http://java.sun.com/javaee/overview/faq/persistence.jsp</a></span></span>, or JPA<a class="IndexReference" name="entry-JPA-0" href="#index-JPA">↓</a> for short, is the evolution of a number of frameworks in Java to provide a simple database access layer for plain java objects (and, transitively, Scala objects). JPA was developed as part of the Enterprise Java Beans 3 (EJB3) specification, with the goal of simplifying the persistence model. Prior versions had used the Container Managed Persistence (CMP<a class="IndexReference" name="entry-CMP-0" href="#index-CMP">↓</a>) framework, which required many boilerplate artifacts in the form of interfaces and XML descriptors. As part of the overarching theme of EJB3 to simplify and use convention over configuration, JPA uses sensible defaults and annotations<a class="IndexReference" name="entry-annotations-0" href="#index-annotations">↓</a> heavily, while allowing for targetted overrides of behavior via XML descriptors. JPA also does away with many of the interfaces used in CMP and provides a single <tt>javax.persistence.EntityManager</tt><a class="IndexReference" name="entry-EntityManager-0" href="#index-EntityManager">↓</a> class for all persistence operations. An additional benefit is that JPA was designed so that it could be used both inside and outside of the Enterprise container, and several projects (Hibernate<a class="IndexReference" name="entry-Hibernate-0" href="#index-Hibernate">↓</a>, TopLink<a class="IndexReference" name="entry-TopLink-0" href="#index-TopLink">↓</a>, JPOX<a class="IndexReference" name="entry-JPOX-0" href="#index-JPOX">↓</a>, etc) provide standalone implementations of <tt>EntityManager</tt>.
</div>
<div class="Indented">
As we’ve seen in chapter <a class="Reference" href="#cha:mapper_and_record">8↑</a>, Lift already comes with a very capable database abstraction layer, so why would we want to use something else? There are a number of reasons:
</div>
<ol>
<li>
JPA is easily accessible from both Java and Scala. If you are using Lift to complement part of a project that also contains Java components, JPA allows you to use a common database layer between both and avoid duplication of effort. It also means that if you have an existing project based on JPA, you can easily integrate it into Lift
</li>
<li>
JPA gives you more flexibility with complex and/or large schemas. While Lift’s Mapper provides most of the functionality you would need, JPA provides additional lifecycle methods and mapping controls when you have complex needs. Additionally, JPA has better support for joins and relationships between entities.
</li>
<li>
JPA can provide additional performance improvements via second-level object caching. It’s possible to roll your own in Lift, but JPA allows you to cache frequently-accessed objects in memory so that you avoid hitting the database entirely
</li>

</ol>
<h2 class="Section">
<a class="toc" name="toc-Section-12.1">12.1</a> Introducing JPA
</h2>
<div class="Unindented">
In order to provide a concrete example to build on while learning how to integrate JPA, we’ll be building a small Lift app to manage a library of books. The completed example is available under the Lift Git<a class="IndexReference" name="entry-Git-0" href="#index-Git">↓</a> repository in the sites directory, and is called “JPADemo”. Basic coverage of the JPA operations is in section <a class="Reference" href="#sec:JPA-Examples">12.5 on page 1↓</a>; if you want more detail on JPA, particularly with advanced topics like locking and hinting, there are several very good tutorials to be found online<span class="FootOuter"><span class="SupFootMarker"> [K] </span><span class="HoverFoot"><span class="SupFootMarker"> [K] </span><a class="FlexURL" href="http://java.sun.com/developer/technicalArticles/J2EE/jpa/">http://java.sun.com/developer/technicalArticles/J2EE/jpa/</a>, <a class="FlexURL" href="http://www.jpox.org/docs/1_2/tutorials/jpa_tutorial.html">http://www.jpox.org/docs/1_2/tutorials/jpa_tutorial.html</a></span></span>. Our first step is to set up a master project<a class="IndexReference" name="entry-master-project-0" href="#index-master-project">↓</a> for Maven. This project will have two modules under it, one for the JPA library and one for the Lift application. In a working directory of your choosing, issue the following command:
</div>
<pre class="LyX-Code">
mvn archetype:generate \
  -DarchetypeRepository=http://scala-tools.org/repo-snapshots \
  -DarchetypeGroupId=net.liftweb \
  -DarchetypeArtifactId=lift-archetype-jpa-basic \
  -DarchetypeVersion=1.1-SNAPSHOT \
  -DgroupId=com.foo.jpaweb \
  -DartifactId=JPADemo \
  -Dversion=1.0-SNAPSHOT
</pre>
<div class="Unindented">
This will use the JPA archetype to create a new project for you with modules for the persistence and web portions of the project.
</div>
<div class="Indented">
<div class="center">
<div class="Shadowbox" style="width: 75%;">
Note: The reason we have split the module out into two projects is that it aids deployment on Jave EE servers to have the Persistence module be an independent JAR file. If you don’t need that, you can simply merge the contents of the two modules into a single project and it will work standalone. Note that you’ll need to merge the pom.xml file’s dependencies and plugin configurations from all three POMs. Lift comes with an archetype that handles this already, albeit without the demo code we show here. Simply use the lift-archetype-jpa-blank-single archetype and you’ll get a blank project (with minimal files for JPA and Lift) that you can use for your app. There’s also a blank archetype that uses two modules if you want that, called lift-archetype-jpa-blank.
</div>

</div>

</div>
<div class="Indented">
You will get a prompt asking you to confirm the settings we’ve chosen; just hit <tt>&lt;enter&gt;</tt>. As of this writing we have to use the snapshot version of the archetype because it didn’t make the Lift 1.0 deadline, but otherwise it’s a stable archetype. You will also see some Velocity warnings about invalid references; these can be safely ignored and will hopefully be fixed by 1.1. After the archetype is generated, you should have the following tree structure:
</div>
<pre class="LyX-Code">
JPADemo
|-- README
|-- pom.xml
|-- spa
|   |-- pom.xml
|   ‘-- src ...
‘-- web
    |-- pom.xml
    ‘-- src ...
</pre>
<div class="Unindented">
If you look at the source directories, you’ll see that our code is already in place! If you’re making your own application you can either use the previously mentioned blank archetypes to start from scratch, or use the basic archetype and modify the POMs, Scala code and templates to match your needs. For now, let’s go over the contents of the project.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-12.1.1">12.1.1</a> Using Entity Classes<a class="IndexReference" name="entry-entity-class-0" href="#index-entity-class">↓</a> in Scala
</h3>
<div class="Unindented">
The main components of a JPA library are the entity classes that comprise your data model. For our example application we need two primary entities: Author and Book. Let’s take a look at the Author class first, shown in listing <a class="Reference" href="#lst:Author.scala">G.1.1 on page 1↓</a>. The listing shows our import of the entire javax.persistence package as well as several annotations on a basic class. For those of you coming from the Java world in JPA, the annotations should look very familiar. The major difference between Java and Scala annotations is that each parameter in a Scala annotation is considered a val, which explains the presence of the val keyword in lines 12, 15 and 17-18. In line 17 you may also note that we must specify the target entity class; although Scala uses generics, the generic types aren’t visible from Java, so the Java JPA libraries can’t deduce the correct type. You may also notice that on line 18 we need to use the Java collections classes for Set, List, etc. With a little bit of implicit conversion magic (to be shown later), this has very little impact on our code. On final item item to note is that the Scala compiler currently does not support nested annotations <span class="FootOuter"><span class="SupFootMarker"> [L] </span><span class="HoverFoot"><span class="SupFootMarker"> [L] </span><a class="FlexURL" href="https://lampsvn.epfl.ch/trac/scala/ticket/294">https://lampsvn.epfl.ch/trac/scala/ticket/294</a></span></span>, so where we would normally use them (join tables, named queries, etc), we will have to use the orm.xml descriptor, which we cover next.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-12.1.2">12.1.2</a> <a class="Label" name="sub:Using-the-orm.xml"> </a>Using the orm.xml<a class="IndexReference" name="entry-orm.xml-0" href="#index-orm.xml">↓</a> descriptor
</h3>
<div class="Unindented">
As we stated in the last section, there are some instances where the Scala compiler doesn’t fully cover the JPA annotations (nested annotations in particular). Some would also argue that queries and other ancillary data (table names, column names, etc) should be separate from code. Because of that, JPA allows you to specify an external mapping descriptor to define and/or override the mappings for your entity classes<a class="IndexReference" name="entry-entity-classes-0" href="#index-entity-classes">↓</a>. The basic orm.xml file starts with the DTD type declaration, as shown in listing <a class="Reference" href="#lst:orm.xml">G.1.2 on page 1↓</a>. Following the preamble, we can define a package that will apply to all subsequent entries so that we don’t need to use the fully-qualified name for each class. In our example, we would like to define some named queries for each class. Putting them in the orm.xml allows us to modify them without requiring a recompile. The complete XML Schema Definition can be found at <a class="FlexURL" href="http://java.sun.com/xml/ns/persistence/orm_1_0.xsd">http://java.sun.com/xml/ns/persistence/orm_1_0.xsd</a>.
</div>
<div class="Indented">
In this case we have used the orm.xml file to augment our entity classes. If, however, we would like to override the configuration, we may use that as well on a case-by-case basis. Suppose we wished to change the column name for the Author’s <tt>name</tt> property. We can add (per the XSD) a section to the Author entity element as shown in listing <a class="Reference" href="#lst:JPA-Author-override">12.1.2↓</a>. The <tt>attribute-override</tt> element lets us change anything that we would normally specify on the <tt>@Column</tt> annotation. This gives us an extremely powerful method for controlling our schema mapping outside of the source code. We can also add named queries<a class="IndexReference" name="entry-named-queries-0" href="#index-named-queries">↓</a> in the orm.xml so that we have a central location for defining or altering the queries.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:JPA-Author-override"> </a>Author override
</div>
  &lt;entity class="Author"&gt;<pre class="listing brush: xml">    &lt;named-query name="findAllAuthors"&gt;
      &lt;query&gt;&lt;![CDATA[from Author a order by a.name]]&gt;&lt;/query&gt;
    &lt;/named-query&gt;
    &lt;attribute-override name="name"&gt;
      &lt;column name="author_name" length="30" /&gt;
    &lt;/attribute-override&gt;
  &lt;/entity&gt;
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-12.1.3">12.1.3</a> Working with Attached and Detached Objects<a class="Label" name="sub:Working-with-Attached"> </a>
</h3>
<div class="Unindented">
JPA operates with entities in one of two modes: attached and detached. An attached object is one that is under the direct control of a live JPA session. That means that the JPA provider monitors the state of the object and writes it to the database at the appropriate time. Objects can be attached either explicitly via the <tt>persist</tt> and <tt>merge</tt> methods (section <a class="Reference" href="#sub:Persisting,-merging-and-removing">12.5.1↓</a>), or implicitly via query results, the <tt>getReference</tt> method or the <tt>find</tt> method.
</div>
<div class="Indented">
As soon as the session ends, any formerly attached objects are now considered detached. You can still operate on them as normal objects but any changes are not directly applied to the database. If you have a detached object, you can re-attach it to your current session with the <tt>merge</tt> method; any changes since the object was detached, as well as any subsequent changes to the attached object, will be applied to the database at the appropriate time. The concept of object attachment is particularly useful in Lift because it allows us to generate or query for an object in one request cycle and then make modifications and merge in a different cycle.
</div>
<div class="Indented">
As an example, our library application provides a summary listing of authors on one page (<tt>src/main/webapp/authors/list.html</tt>) and allows editing of those entities on another (<tt>src/main/webapp/authors/add.html</tt>). We can use the <tt>SHtml.link</tt> generator on our list page, combined with a <tt>RequestVar</tt>, to pass the instance (detached once we return from the list snippet) to our edit snippet. Listing <a class="Reference" href="#lst:Passing-Detached-Instances">12.1.3↓</a> shows excerpts from our library application snippets demonstrating how we hand off the instance and do a merge within our edit snippets submission processing function (<tt>doAdd</tt>).
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Passing Detached Instances Around an Application<a class="Label" name="lst:Passing-Detached-Instances"> </a>
</div>
<pre class="listing brush: scala">// in src/main/scala/net/liftweb/jpademo/snippets/Author.scala
...package and imports ... 
class AuthorOps {
  def list (xhtml : NodeSeq) : NodeSeq = {
    val authors = ...
    authors.flatMap(author =&gt; bind("author", xhtml, ...
        // use the link closure to capture the current
        // instance for edit insertion
        "edit" -&gt; SHtml.link("add.html",
           () =&gt; authorVar(author), Text(?("Edit")))))
  }
  ...
  // Set up a requestVar to track the author object for edits and adds
  object authorVar extends RequestVar(new Author())
  // helper def
  def author = authorVar.is
  def add (xhtml : NodeSeq) : NodeSeq = {
    def doAdd () = {
      ...
      // merge and save the detached instance
      Model.mergeAndFlush(author)
      ...
    }
    // Hold a val here so that the closure grabs it instead of the def
    val current = author
    // Use a hidden element to reinsert the instance on form submission
    bind("author", xhtml,
      "id" -&gt; SHtml.hidden(() =&gt; authorVar(current)), ...,
      "submit" -&gt; SHtml.submit(?("Save"), doAdd))
  }
}
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-12.2">12.2</a> <a class="Label" name="sec:Obtaining-an-EM"> </a>Obtaining a Per-Session EntityManager
</h2>
<div class="Unindented">
Ideally, we would like our JPA access to be as seamless as possible, particularly when it comes to object lifecycle. In JPA, objects can be attached to a current persistence session, or they can be detached from a JPA session. This gives us a lot of flexibility (which we’ll use later) in dealing with the objects themselves, but it also means that we need to be careful when we’re accessing object properties. JPA can use lazy retrieval for instance properties; in particular, this is the default behavior for collection-based properties. What this means is that if we’re working on a detached object and we attempt to access a collection contained in the instance, we’re going to get an exception that the session that the object was loaded in is no longer live. What we’d really like to do is have some hooks into Lift’s request cycle that allows us to set up a session when the request starts and properly close it down when the request ends. We still have to be careful with objects that have been passed into our request (from form callbacks, for instance), but in general this will guarantee us that once we’ve loaded an object in our snippet code we have full access to all properties at any point within our snippets.
</div>
<div class="Indented">
Fortunately for us, Lift provides just such a mechanism. In fact, Lift supports several related mechanisms for lifecycle management<span class="FootOuter"><span class="SupFootMarker"> [M] </span><span class="HoverFoot"><span class="SupFootMarker"> [M] </span>Notably, <tt>S.addAround</tt> with the <tt>LoanWrapper</tt></span></span>, but for now we’re going to focus on just one: the <tt>RequestVar</tt><a class="IndexReference" name="entry-RequestVar-1" href="#index-RequestVar">↓</a>. A <tt>RequestVar</tt> represents a variable associated with the lifetime of the request. This is in contrast to <tt>SessionVar</tt>, which defines a variable for the lifetime of the user’s session. <tt>RequestVar</tt> gives us several niceties over handling request parameters ourselves, including type safety and a default value. We go into more detail on <tt>RequestVars</tt> and <tt>SessionVars</tt> in section <a class="Reference" href="#sec:Session-and-Request">3.11 on page 1↑</a>. In addition to the Lift facilities, we also use the ScalaJPA project<span class="FootOuter"><span class="SupFootMarker"> [N] </span><span class="HoverFoot"><span class="SupFootMarker"> [N] </span><a class="FlexURL" href="http://scala-tools.org/mvnsites-snapshots/scalajpa/">http://scala-tools.org/mvnsites-snapshots/scalajpa/</a>, source code available at <a class="URL" href="http://github.com/dchenbecker/scalajpa/tree">http://github.com/dchenbecker/scalajpa/tree</a></span></span> to handle some of the boilerplate of utilizing JPA. ScalaJPA provides some nice traits that “Scalafy” the JPA <tt>EntityManager</tt> and <tt>Query</tt> interfaces, as well as accessors that make retrieving an EM simple. To use ScalaJPA we simply add the following dependency to our POM. 
</div>
<pre class="LyX-Code">
&lt;dependency&gt;
  &lt;groupId&gt;org.scala-tools&lt;/groupId&gt;
  &lt;artifactId&gt;scalajpa&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</pre>
<div class="Unindented">
Note that at the time of writing the library is at 1.0-SNAPSHOT, but should be promoted to 1.0 soon.
</div>
<div class="Indented">
We leverage ScalaJPA’s <tt>LocalEMF</tt> and <tt>RequestVarEM</tt> traits to provide a simple <tt>RequestVar</tt> interface to obtain the EM via local lookup (i.e. via the <tt>javax.persistence.Persistence</tt> class), as shown in listing <a class="Reference" href="#lst:Setting-up-EM">12.2 on page 1↓</a>. It’s trivial to use JNDI instead by substituting the <tt>JndiEMF</tt> trait for the <tt>LocalEMF</tt> trait, but the details of setting up the JNDI persistence module are beyond the scope of this book.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:Setting-up-EM"> </a>Setting up an EntityManager via RequestVar
</div>
<pre class="listing brush: scala">import _root_.org.scala_libs.jpa._
object Model extends LocalEMF("jpaweb") with RequestVarEM
</pre>
</div>

</div>
<div class="Indented">
Once we have this object set up, we can access all of the <tt>ScalaEntityManager</tt> methods directly on <tt>Model</tt>.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-12.3">12.3</a> Handling Transactions<a class="IndexReference" name="entry-Transactions-0" href="#index-Transactions">↓</a>
</h2>
<div class="Unindented">
We’re not going to go into too much detail here; there are better documents available<span class="FootOuter"><span class="SupFootMarker"> [O] </span><span class="HoverFoot"><span class="SupFootMarker"> [O] </span><a class="FlexURL" href="http://java.sun.com/developer/EJTechTips/2005/tt0125.html">http://java.sun.com/developer/EJTechTips/2005/tt0125.html</a></span></span> if you want to go into depth on how the Java Transaction API (JTA) or general transactions work. Essentially, a transaction is a set of operations that are performed atomically; that is, they either all complete successfully or none of them do. The classic example is transferring funds between two bank accounts: you subtract the amount from one account and add it to the other. If the addition fails and you’re not operating in the context of a transaction, the client has lost money!
</div>
<div class="Indented">
In JPA, transactions are required. If you don’t perform your operations within the scope of a transaction you will either get an exception (if you’re using JTA), or you will spend many hours trying to figure out why nothing is being saved to the database. There are two ways of handling transactions under JPA: resource local and JTA. Resource local transactions are what you use if you are managing the EM factory yourself (corresponding to the <tt>LocalEMF</tt> trait). Similarly, JTA is what you use when you obtain your EM via JNDI. Technically it’s also possible to use JTA with a locally managed EM, but that configuration is beyond the scope of this book.
</div>
<div class="Indented">
Generally, we would recommend using JTA where it’s free (i.e., when deploying to a Java EE container) and using resource-local when you’re using a servlet container such as Jetty or Tomcat. If you will be accessing multiple databases or involving resources like EJBs, it is much safer to use JTA so that you can utilize distributed transactions. Choosing between the two is as simple as setting a property in your persistence.xml file (and changing the code to open and close the EM). Listing <a class="Reference" href="#lst:Setting-the-transaction-type">12.3↓</a> shows examples of setting the <tt>transaction-type</tt> attribute to <tt>RESOURCE_LOCAL</tt> and to JTA. If you want to use JTA, you can also omit the <tt>transaction-type</tt> attribute since JTA is the default.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:Setting-the-transaction-type"> </a>Setting the transaction type
</div>
<pre class="listing brush: xml">&lt;persistence-unit name="jpaweb" transaction-type="RESOURCE_LOCAL"&gt;
  &lt;non-jta-datasource&gt;myDS&lt;/non-jta-datasource&gt;
​
&lt;persistence-unit name="jpaweb" transaction-type="JTA"&gt;
  &lt;jta-datasource&gt;myDS&lt;/jta-datasource&gt;
</pre>
</div>

</div>
<div class="Indented">
You must make sure that your EM setup code matches what you have in your <tt>persistence.xml</tt>. Additionally, the database connection must match; with JTA, you <i>must</i> use a <tt>jta-data-source</tt> (obtained via JNDI) for your database connection. For resource-local, you can either use a <tt>non-jta-datasource</tt> element or you can set the provider properties, as shown in listing <a class="Reference" href="#lst:Setting-resource-local-properties">12.3 on page 1↓</a>. In this particular example we’re setting the properties for Hibernate, but similar properties exist for TopLink<span class="FootOuter"><span class="SupFootMarker"> [P] </span><span class="HoverFoot"><span class="SupFootMarker"> [P] </span><a class="FlexURL" href="http://www.oracle.com/technology/products/ias/toplink/JPA/essentials/toplink-jpa-extensions.html">http://www.oracle.com/technology/products/ias/toplink/JPA/essentials/toplink-jpa-extensions.html</a></span></span>, JPOX<span class="FootOuter"><span class="SupFootMarker"> [Q] </span><span class="HoverFoot"><span class="SupFootMarker"> [Q] </span><a class="FlexURL" href="http://www.jpox.org/docs/1_2/persistence_unit.html">http://www.jpox.org/docs/1_2/persistence_unit.html</a></span></span>, and others.
</div>
<div class="Indented">
If you’ll be deploying into a JEE container, such as JBoss or GlassFish, then you get JTA support almost for free since JTA is part of the JEE spec. If you want to deploy your application on a lightweight container like Jetty or Tomcat, we would recommend that you look into using an external JTA coordinator such as JOTM, Atomikos, or JBoss Transaction Manager, since embedding a JTA provider in your container is a nontrivial task.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:Setting-resource-local-properties"> </a>Setting resource-local properties for Hibernate
</div>
<pre class="listing brush: xml">&lt;persistence&gt;
   &lt;persistence-unit name="jpaweb" transaction-type="RESOURCE_LOCAL"&gt;
      &lt;properties&gt;
         &lt;property name="hibernate.dialect" value="org.hibernate.dialect.PostgreSQLDialect"/&gt;
         &lt;property name="hibernate.connection.driver_class" value="org.postgresql.Driver"/&gt;
         &lt;property name="hibernate.connection.username" value="somUser"/&gt;
         &lt;property name="hibernate.connection.password" value="somePass"/&gt;
         &lt;property name="hibernate.connection.url" value="jdbc:postgresql:jpaweb"/&gt;
      &lt;/properties&gt;
   &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</pre>
</div>

</div>
<div class="Indented">
One final note in regard to transactions is how they’re affected by Exceptions. Per the spec, any exceptions thrown during the scope of a transaction, other than<br/>
<tt>javax.persistence.NoResultException</tt> or <tt>javax.persistence.NonUniqueResultException</tt>, will cause the transaction to be marked for rollback.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-12.4">12.4</a> <a class="Label" name="sec:ScalaEntityManager-and-ScalaQuery"> </a>ScalaEntityManager and ScalaQuery
</h2>
<div class="Unindented">
Now that we’ve gone through setting up our <tt>EntityManager</tt>, let’s look at how we actually use them in an application. As a convenience, ScalaJPA defines two thin wrappers on the existing <tt>EntityManager</tt><span class="FootOuter"><span class="SupFootMarker"> [R] </span><span class="HoverFoot"><span class="SupFootMarker"> [R] </span><a class="FlexURL" href="http://java.sun.com/javaee/5/docs/api/javax/persistence/EntityManager.html">http://java.sun.com/javaee/5/docs/api/javax/persistence/EntityManager.html</a></span></span> and <tt>Query</tt><span class="FootOuter"><span class="SupFootMarker"> [S] </span><span class="HoverFoot"><span class="SupFootMarker"> [S] </span><a class="FlexURL" href="http://java.sun.com/javaee/5/docs/api/javax/persistence/Query.html">http://java.sun.com/javaee/5/docs/api/javax/persistence/Query.html</a></span></span> interfaces to provide more Scala-friendly methods. This means that we get Scala’s collection types (i.e. <tt>List</tt> instead of <tt>java.util.List</tt>) and generic signatures so that we can avoid explicit casting. The <tt>ScalaEntityManager</tt> trait provides a wrapper on the <tt>EntityManager</tt> class, and is included as part of the <tt>RequestVarEM</tt> trait that we’ve mixed into our <tt>Model</tt> object. The API for <tt>ScalaEntityManager</tt> can be found at <a class="FlexURL" href="http://scala-tools.org/mvnsites/scalajpa/scaladocs/org/scala_libs/jpa/ScalaEntityManager.html">http://scala-tools.org/mvnsites/scalajpa/scaladocs/org/scala_libs/jpa/ScalaEntityManager.html</a>.
</div>
<div class="Indented">
Next, we have the <tt>ScalaQuery</tt> trait, with API docs at <a class="FlexURL" href="http://scala-tools.org/mvnsites/scalajpa/scaladocs/org/scala_libs/jpa/ScalaQuery.html">http://scala-tools.org/mvnsites/scalajpa/scaladocs/org/scala_libs/jpa/ScalaQuery.html</a>. Like <tt>ScalaEntityManager</tt>, this is a thin wrapper on the <tt>Query</tt> interface. In particular, methods that return entities are typed against the <tt>ScalaQuery</tt> itself, so that you don’t need to do any explicit casting in your client code. We also have some utility methods to simplify setting a parameter list as well as obtaining the result(s) of the query. 
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-12.5">12.5</a> <a class="Label" name="sec:JPA-Examples"> </a>Operating on Entities
</h2>
<div class="Unindented">
In this section we’ll demonstrate how to work with entities and cover some important tips on using JPA effectively.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-12.5.1">12.5.1</a> <a class="Label" name="sub:Persisting,-merging-and-removing"> </a>Persisting, Merging and Removing Entities
</h3>
<div class="Unindented">
The first step to working with any persistent entities is to actually persist them. If you have a brand new object, you can do this with the <tt>persist</tt> method:
</div>
<pre class="LyX-Code">
val myNewAuthor = new Author; myNewAuthor.name = "Wilma"
Model.persist(myNewAuthor)
</pre>
<div class="Unindented">
This attaches the <tt>myNewAuthor</tt> object to the current persistence session. Once the object is attached it should be visible in any subsequent queries, although it may not be written to the database just yet (see section <a class="Reference" href="#sub:The-importance-of-flush">12.5.6↓</a>). Note that the <tt>persist</tt> method is only intended for brand new objects. If you have a detached object and you try to use <tt>persist</tt> you will most likely get an <tt>EntityExistsException</tt> as the instance you’re merging is technically conflicting with itself. Instead, you want to use the <tt>merge</tt> method to re-attach detached objects:
</div>
<pre class="LyX-Code">
val author = Model.merge(myOldAuthor)
</pre>
<div class="Unindented">
An important thing to note is that the <tt>merge</tt> method doesn’t actually attach the object passed to it; instead, it makes an attached <i>copy</i> of the passed object and returns the copy. If you mistakenly merge without using the returned value:
</div>
<pre class="LyX-Code">
Model.merge(myOldAuthor)
myOldAuthor.name = “Fred”
</pre>
<div class="Unindented">
you’ll find that subsequent changes to the object won’t be written to the database. One nice aspect of the <tt>merge</tt> method is that it intelligently detects whether the entity you’re merging is a new object or a detached object. That means that you can use <tt>merge</tt> everywhere and let it sort out the semantics. For example, in our library application, using <tt>merge</tt> allows us to combine the adding and editing functionality into a single snippet; if we want to edit an existing <tt>Author</tt> we pass it into the method. Otherwise, we pass a brand new <tt>Author</tt> instance into the method and the merge takes care of either case appropriately.
</div>
<div class="Indented">
Removing an object is achieved by calling the <tt>remove</tt> method:
</div>
<pre class="LyX-Code">
Model.remove(myAuthor)
</pre>
<div class="Unindented">
The passed entity is detached from the session immediately and will be removed from the database at the appropriate time. If the entity has any associations on it (to collections or other entities), they will be cascaded as indicated by the entity mapping. An example of a cascade is shown in the <tt>Author</tt> listing on page <a class="Reference" href="#lst:Author.scala">1↓</a>. The books collection has the cascade set to REMOVE, which means that if an author is deleted, all of the books by that author will be removed as well. The default is to not cascade anything, so it’s important that you properly set the cascade on collections to avoid constraint violations when you remove entities. It’s also useful to point out that you don’t actually need to have an entity loaded to remove it. You can use the <tt>getReference</tt> method to obtain a proxy that will cause the corresponding database entry to be removed:
</div>
<pre class="LyX-Code">
Model.remove(Model.getReference(classOf[Author], someId))
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-12.5.2">12.5.2</a> Loading an Entity
</h3>
<div class="Unindented">
There are actually three ways to load an entity object in your client code: using <tt>find</tt>, <tt>getReference</tt> or a query. The simplest is to use the <tt>find</tt> method: 
</div>
<pre class="LyX-Code">
val myBook = Model.find(classOf[Book], someId)
</pre>
<div class="Unindented">
The <tt>find</tt> method takes two parameters: the class that you’re trying to load and the value of the ID field of the entity. In our example, the <tt>Book</tt> class uses the <tt>Long</tt> type for its ID, so we would put a <tt>Long</tt> value here. It returns either a <tt>Full</tt> <tt>Box</tt> (section <a class="Reference" href="#sec:Box-(or-Scala's">C.2 on page 1↓</a>) if the entity is found in the database, otherwise it returns <tt>Empty</tt>. With <tt>find</tt>, the entity is loaded immediately from the database and can be used in both attached and detached states. 
</div>
<div class="Indented">
The next method you can use is the <tt>getReference</tt> method:
</div>
<pre class="LyX-Code">
val myBook = Model.getReference(classOf[Book], someId)
</pre>
<div class="Unindented">
This is very similar to the <tt>find</tt> method with a few key differences. First, the object that is returned is a lazy proxy for the entity. That means that no database load is required to occur when you execute the method, although providers may do at least a check on the existence of the ID. Because this is a lazy proxy, you usually don’t want to use the returned object in a detached state unless you’ve accessed its fields while the session was open. The normal use of <tt>getReference</tt> is when you want to set up a relationship between two (or more) entities, since you don’t need to query all of the fields just to set a foreign key. For example:
</div>
<pre class="LyX-Code">
myBook.author = Model.getReference(classOf[Author], authorId)
</pre>
<div class="Unindented">
When <tt>myBook</tt> is flushed to the database the EM will correctly set up the relationship. The final difference is in how unknown entities are handled. Recall that the <tt>find</tt> method returns <tt>Empty</tt> if the entity cannot be found; with <tt>getReference</tt>, however, we don’t query the database until the reference is used. Because of this, the <tt>javax.persistence.EntityNotFoundException</tt> is thrown when you try to access an undefined entity for the first time (this also marks the transaction for rollback). 
</div>
<div class="Indented">
The third method for loading an entity would be to use a query (named or otherwise) to fetch the entity. As an example, here’s a query equivalent of the <tt>find</tt> method:
</div>
<pre class="LyX-Code">
val myBook = 
  Model.createQuery[Book]("from Book bk where bk.id = :id")
       .setParams("id" -&gt; someId).findOne
</pre>
<div class="Unindented">
The advantage here is that we have more control over what is selected by using the query language to specify other properties. One caveat is that when you use the <tt>findOne</tt> method you need to ensure that the query will actually result in a unique entity; otherwise, the EM will throw a <tt>NonUniqueResultException</tt>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-12.5.3">12.5.3</a> Loading Many Entities
</h3>
<div class="Unindented">
Corresponding to the <tt>findOne</tt> method is the <tt>findAll</tt> method, which returns all entities based on a query. There are two ways to use <tt>findAll</tt>; the first is to use the convenience <tt>findAll</tt> method defined in the <tt>ScalaEntityManager</tt> class:
</div>
<pre class="LyX-Code">
val myBooks = Model.findAll("booksByYear", "year" -&gt; myYear)
</pre>
<div class="Unindented">
This requires the use of a named query for the first arg, and subsequent args are of the form (“paramName” -&gt; value). Named queries<a class="IndexReference" name="entry-named-queries-1" href="#index-named-queries">↓</a> can be defined in your orm.xml<a class="IndexReference" name="entry-orm.xml-1" href="#index-orm.xml">↓</a>, as shown in section <a class="Reference" href="#sub:Using-the-orm.xml">12.1.2 on page 1↑</a>. Named queries are highly recommended over ad-hoc queries since they allow you to keep the queries in one location instead of being scattered all over your code. Named queries can also be pre-compiled by the JPA provider, which will catch errors at startup (or in your unit tests, hint hint) instead of when the query is run inside your code.
</div>
<div class="Indented">
The second method is to create a <tt>ScalaQuery</tt> instance directly and then set parameters and execute it. In reality this is exactly what the <tt>Model.findAll</tt> method is doing. The advantage here is that with the <tt>ScalaQuery</tt> instance you can do things like set hinting, paging, and so on. For instance, if you wanted to do paging on the books query, you could do
</div>
<pre class="LyX-Code">
val myBooks = Model.createNamedQuery(“booksByYear”)
                   .setParams(“year” -&gt; myYear)
                   .setMaxResults(20)
                   .setFirstResult(pageOffset).findAll
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-12.5.4">12.5.4</a> Using Queries Wisely
</h3>
<div class="Unindented">
In general we recommend that you use named queries throughout your code. In our experience, the extra effort involved in adding a named query is more than offset by the time it saves you if you ever need to modify the query. Additionally, we recommend that you use named parameters in your queries. Named parameters are just that: parameters that are inserted into your query by name, in contrast to positional parameters. As an example, here is the same query using named and positional parameters:
</div>
<div class="List">
<span class="List-entry">Named parameters</span><span class="List-contents"><tt>select user from User where (user.name like :searchString or user.email like :searchString) and user.widgets &gt; :widgetCount</tt></span>
</div>
<div class="List">
<span class="List-entry">Positional parameters</span><span class="List-contents"><tt>select user from User where (user.name like ? or user.email like ?) and user.widgets &gt; ?</tt></span>
</div>
<div class="Unindented">
This example shows several advantages of named parameters over positional parameters:
</div>
<ol>
<li>
You can reuse the same parameter within the same query and you only set it once. In the example about we would set the same parameter twice using positional params
</li>
<li>
The parameters can have meaningful names.
</li>
<li>
With positional params you may have to edit your code if you need to alter your query to add or remove parameters
</li>

</ol>
<div class="Unindented">
In any case, you should generally use the parameterized query types as opposed to hand constructing your queries; using things like string concatenation opens up your site to SQL injection attacks unless you’re very careful. For more information on queries there’s an excellent reference for the EJBQL on the Hibernate website at <a class="FlexURL" href="http://www.hibernate.org/hib_docs/entitymanager/reference/en/html/queryhql.html">http://www.hibernate.org/hib_docs/entitymanager/reference/en/html/queryhql.html</a>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-12.5.5">12.5.5</a> Converting Collection Properties
</h3>
<div class="Unindented">
The <tt>ScalaEntityManager</tt> and <tt>ScalaQuery</tt> methods are already defined so that they return Scala-friendly collections such as <tt>scala.collection.jcl.BufferWrapper</tt> or <tt>SetWrapper</tt>. We have to use Java Collections<span class="FootOuter"><span class="SupFootMarker"> [T] </span><span class="HoverFoot"><span class="SupFootMarker"> [T] </span><a class="FlexURL" href="http://java.sun.com/docs/books/tutorial/collections/index.html">http://java.sun.com/docs/books/tutorial/collections/index.html</a></span></span> “under the hood” and then wrap them because JPA doesn’t understand Scala collections. For the same reason, collections in your entity classes must also use the Java Collections classes. Fortunately, Scala has a very nice framework for wrapping Java collections. In particular, the <tt>scala.collection.jcl.Conversions</tt> class contains a number of implicit conversions<a class="IndexReference" name="entry-implicit-conversions-0" href="#index-implicit-conversions">↓</a>; all you have to do is import them at the top of your source file like so:
</div>
<pre class="LyX-Code">
import scala.collection.jcl.Conversions._
</pre>
<div class="Unindented">
Once you’ve done that the methods are automatically in scope and you can use collections in your entities as if they were real Scala collections. For example, we may want to see if our Author has written any mysteries:
</div>
<pre class="LyX-Code">
val suspenseful = author.books.exists(_.genre = Genre.Mystery)
</pre>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-12.5.6">12.5.6</a> <a class="Label" name="sub:The-importance-of-flush"> </a>The importance of flush() and Exceptions
</h3>
<div class="Unindented">
It’s important to understand that in JPA the provider isn’t required to write to the database until the session closes or is flushed. That means that constraint violations aren’t necessarily checked at the time that you persist, merge or remove and object. Using the flush method forces the provider to write any pending changes to the database and immediately throw any exceptions resulting from any violations. As a convenience, we’ve written the <tt>mergeAndFlush</tt>, <tt>persistAndFlush</tt>, and <tt>removeAndFlush</tt> methods to do persist, merge and remove with a subsequent flush, as shown in listing <a class="Reference" href="#lst:Auto-flush-methods">12.5.6↓</a>, taken from the Author snippet code. You can also see that because we flush at this point, we can catch any JPA-related exceptions and deal with them here. If we don’t flush at this point, the exception would be thrown when the transaction commits, which is often very far (in code) from where you would want to handle it.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Auto-flush methods<a class="Label" name="lst:Auto-flush-methods"> </a>
</div>
def doAdd () = {<pre class="listing brush: scala">  if (author.name.length == 0) {
    error("emptyAuthor", "The author’s name cannot be blank")
  } else {
    try {
      Model.mergeAndFlush(author)
     redirectTo("list.html")
    } catch {
      case ee : EntityExistsException =&gt; error("Author already exists")
      case pe : PersistenceException =&gt; 
        error("Error adding author"); Log.error("Error adding author", pe)
    }
  }
}
</pre>
</div>

</div>
<div class="Indented">
Although the combo methods simplify things, we recommend that if you will be doing multiple operations in one session cycle that you use a single flush at the end:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Multiple JPA ops<a class="Label" name="lst:Multiple-JPA-ops"> </a>
</div>
<pre class="listing brush: scala">val container = Model.find(classOf[Container], containerId)
Model.remove(container.widget)
container.widget = new Widget("Foo!")
// next line only required if container.widget doesn’t cascade PERSIST
Model.persist(container.widget)
Model.flush()
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-12.5.7">12.5.7</a> Validating Entities
</h3>
<div class="Unindented">
Since we’ve already covered the Mapper framework and all of the extra functionality that it provides beyond being a simple ORM, we felt that we should discuss one of the more important aspects of data handling as it pertains to JPA: validation of data.
</div>
<div class="Indented">
JPA itself doesn’t come with a built-in validation framework, although the upcoming JPA 2.0 may use the JSR 303 (Bean Validation) framework as its default. Currently, Hibernate Validator is one of the more popular libraries for validating JPA entities, and can be used with any JPA provider. More information is available at the project home page: <a class="URL" href="http://www.hibernate.org/412.html">http://www.hibernate.org/412.html</a>.
</div>
<div class="Indented">
The validation of entities with Hibernate Validator is achieved, like the JPA mappings, with annotations. Listing <a class="Reference" href="#lst:The-Author-class-validations">12.5.7↓</a> shows a modified Author class with validations for the name. In this case we have added a NotNull validation as well as a Length check to ensure we are within limits. 
</div>
<div class="Indented">
<div class="smallskip"> </div>
</div>
<div class="Indented">
<div class="center">
<div class="Shadowbox" style="width: 75%;">
Note: Unfortunately, due to the way that the validator framework extracts entity properties, we have to rework our entity to use a getter/setter for any properties that we want to validate; even the <tt>scala.reflect.BeanProperty</tt> annotation won’t work. 
</div>

</div>

</div>
<div class="Indented">
<div class="smallskip"> </div>
</div>
<div class="Indented">
Validation can be performed automatically via the <tt>org.hibernate.validator.event.JPAValidateListener</tt> EntityListener, or programmatically via the <tt>org.hibernate.validator.ClassValidator</tt> utility class. In the listing we use <tt>ClassValidator</tt> and match on the array returned from <tt>getInvalidValues</tt> for processing. Further usage and configuration is beyond the scope of this book.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
The Author class with Hibernate Validations<a class="Label" name="lst:The-Author-class-validations"> </a>
</div>
<pre class="listing brush: scala">...
class Author {
  ...
  var name : String = ""
  @Column{val unique = true, val nullable = false}
  @NotNull
  @Length{val min = 3, val max = 100}
  def getName() = name
  def setName(nm : String) { name = nm }
  ...
} 
// In the snippet class
class AuthorOps {
  ...
  val authorValidator = new ClassValidator(classOf[Author])
  def add (xhtml : NodeSeq) : NodeSeq = {
    def doAdd () = {
      authorValidator.getInvalidValues(author) match {
        case Array() =&gt;
          try {
            Model.mergeAndFlush(author)
            ...
          } catch {
            ...
          }     
        case errors =&gt; {
          errors.foreach(err =&gt; S.error(err.toString)) 
        }      
      }
    ...
  }
}
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-12.6">12.6</a> Supporting User Types
</h2>
<div class="Unindented">
JPA can handle any Java primitive type, their corresponding Object versions (java.lang.Long, java.lang.Integer, etc), and any entity classes comprised of these types <span class="FootOuter"><span class="SupFootMarker"> [U] </span><span class="HoverFoot"><span class="SupFootMarker"> [U] </span>It can technically handle more; see the JPA spec, section 2.1.1 for details</span></span>. Occasionally, though, you may have a requirement for a type that doesn’t fit directly with those specifications. One example in particular would be Scala’s enumerations<a class="IndexReference" name="entry-enumerations-0" href="#index-enumerations">↓</a>. Unfortunately, the JPA spec currently doesn’t have a means to handle this directly, although the various JPA providers such as Toplink and Hibernate provide mechanisms for resolving custom user types. JPA does provide direct support for <i>Java</i> enumerations, but that doesn’t help us here since Scala enumerations aren’t an extension of Java enumerations. In this example, we’ll be using Hibernate’s <tt>UserType</tt> to support an enumeration for the <tt>Genre</tt> of a <tt>Book</tt>.
</div>
<div class="Indented">
We begin by implementing a few helper classes besides the Genre enumeration itself. First, we define an <tt>Enumv</tt> trait, shown in listing <a class="Reference" href="#lst:Enumv-Trait">G.1.3 on page 1↓</a>. Its main purpose is to provide a <tt>valueOf</tt> method that we can use to resolve the enumerations database value to the actual enumeration. We also add some extra methods so that we can encapsulate a description along with the database value. Scala enumerations can use either <tt>Ints</tt> or <tt>Strings</tt> for the identity of the enumeration value (unique to each val), and in this case we’ve chosen <tt>Strings</tt>. By adding a map for the description (since Scala enumeration values must extend the <tt>Enumeration#Value</tt> class and therefore can’t carry the additional string) we allow for the additional info. We could extend this concept to make the <tt>Map</tt> carry additional data, but for our purposes this is sufficient. 
</div>
<div class="Indented">
In order to actually convert the <tt>Enumeration</tt> class into the proper database type (<tt>String</tt>, <tt>Int</tt>, etc), we need to implement the Hibernate <tt>UserType</tt> interface, shown in listing <a class="Reference" href="#lst:EnumvType">G.1.4 on page 1↓</a>. We can see on line 18 that we will be using a <tt>varchar</tt> column for the enumeration value. Since this is based on the Scala <tt>Enumeration</tt>’s <tt>Value</tt> method, we could technically use either <tt>Integer</tt> or character types here. We override the <tt>sqlTypes</tt> and <tt>returnedClass</tt> methods to match our preferred type, and set the <tt>equals</tt> and <tt>hashCode</tt> methods accordingly. Note that in Scala, the “==” operator on objects delegates to the <tt>equals</tt> method, so we’re not testing reference equality here. The actual resolution of database column value to <tt>Enumeration</tt> is done in the <tt>nullSafeGet</tt> method; if we decided, for instance, that the null value should be returned as unknown, we could do this here with some minor modifications to the <tt>Enumv</tt> class (defining the unknown value, for one).The rest of the methods are set appropriately for an immutable object (<tt>Enumeration</tt>). The great thing about the <tt>EnumvType</tt> class, is that it can easily be used for a variety of types due to the “et” constructor argument; as long as we mix in the <tt>Enumv</tt> trait to our <tt>Enumeration</tt> objects, we get persistence essentially for free. If we determined instead that we want to use <tt>Integer</tt> enumeration IDs, we need to make minor modifications to the <tt>EnumvType</tt> to make sure arguments match and we’re set.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:Genre-and-GenreType"> </a>Genre and GenreType
</div>
package com.foo.jpaweb.model<pre class="listing brush: scala">​
object Genre extends Enumeration with Enumv {
  val Mystery = Value("Mystery", "Mystery")
  val Science = Value("Science", "Science")
  val Theater = Value("Theater", "Drama literature")
  // more values here...
}
​
class GenreType extends EnumvType(Genre) {}
</pre>
</div>

</div>
<div class="Indented">
Finally, the <tt>Genre</tt> object and the associated <tt>GenreType</tt> is shown in listing <a class="Reference" href="#lst:Genre-and-GenreType">12.6↑</a>. You can see that we create a singleton <tt>Genre</tt> object with specific member values for each enumeration value. The <tt>GenreType</tt> class is trivial now that we have the <tt>EnumvType</tt> class defined. To use the <tt>Genre</tt> type in our entity classes, we simply need to add the proper <tt>var</tt> and annotate it with the <tt>@Type</tt> annotation, as shown in listing <a class="Reference" href="#lst:Using-the-@Type">12.6↓</a>. We need to specify the type of the var due to the fact that the actual enumeration values are of the type <tt>Enumeration.Val</tt>, which doesn’t match our <tt>valueOf</tt> method in the <tt>Enumv</tt> trait. We also want to make sure we set the enumeration to some reasonable default; in our example we have an <i>unknown</i> value to cover that case.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:Using-the-@Type"> </a>Using the @Type annotation
</div>
  @Type{val ‘type‘ = "com.foo.jpaweb.model.GenreType"}<pre class="listing brush: scala">  var genre : Genre.Value = Genre.unknown
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-12.7">12.7</a> Running the Application
</h2>
<div class="Unindented">
Now that we’ve gone over everything, it’s time to run the application. Because we’ve split up the app into separate SPA and WEB modules, we need to first run
</div>
<pre class="LyX-Code">
mvn install
</pre>
<div class="Unindented">
From the SPA module directory to get the persistence module added to your maven repository. Once that is done, you can go to the WEB module directory and run
</div>
<pre class="LyX-Code">
mvn jetty:run
</pre>
<div class="Unindented">
To get it started.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-12.8">12.8</a> Summing Up
</h2>
<div class="Unindented">
As we’ve shown in this chapter, the Java Persistence API provides a robust, flexibile framework for persisting data to your database, and does so in a manner that integrates fairly well with Lift. We’ve demonstrated how you can easily write entities using a combination of annotations and the orm.xml descriptor, how to define your own custom user types to handle enumerations, the intricacies of working with transactions in various contexts, and leveraging the ScalaJPA framework to simplify your persistence setup. 
</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-13">13</a> Third Party Integrations
</h1>
<div class="Unindented">
In this chapter we’ll explore how you can integrate Lift with some well-known third party libraries and applications
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-13.1">13.1</a> OpenID Integration
</h2>
<div class="Unindented">
The OpenID Foundation<span class="FootOuter"><span class="SupFootMarker"> [V] </span><span class="HoverFoot"><span class="SupFootMarker"> [V] </span><a class="FlexURL" href="http://openid.net/">http://openid.net/</a></span></span> explain OpenID as:
</div>
<div class="Indented">
“OpenID eliminates the need for multiple usernames across different websites, simplifying your online experience.
</div>
<div class="Indented">
You get to choose the OpenID Provider that best meets your needs and most importantly that you trust. At the same time, your OpenID can stay with you, no matter which Provider you move to. And best of all, the OpenID technology is not proprietary and is completely free. For businesses, this means a lower cost of password and account management, while drawing new web traffic. OpenID lowers user frustration by letting users have control of their login. For geeks, OpenID is an open, decentralized, free framework for user-centric digital identity. OpenID takes advantage of already existing internet technology (URI, HTTP, SSL, Diffie-Hellman) and realizes that people are already creating identities for themselves whether it be at their blog, photostream, profile page, etc. With OpenID you can easily transform one of these existing URIs into an account which can be used at sites which support OpenID logins.
</div>
<div class="Indented">
OpenID is still in the adoption phase and is becoming more and more popular, as large organizations like AOL, Microsoft, Sun, Novell, etc. begin to accept and provide OpenIDs. Today it is estimated that there are over 160-million OpenID enabled URIs with nearly ten-thousand sites supporting OpenID logins.”
</div>
<div class="Indented">
Lift provides openId support using onepID4Java<span class="FootOuter"><span class="SupFootMarker"> [W] </span><span class="HoverFoot"><span class="SupFootMarker"> [W] </span>http://code.google.com/p/openid4java/</span></span>. It provides two fundamental traits <tt>net.liftweb.openId.OpenIdVendor</tt> and <tt>net.liftweb.openId.OpenIdConsumer. OpenIdVendor</tt> contains variables such as:
</div>
<ul>
<li>
PathRoot - The path sequence for processing OpenID requests. The default value is “openid”
</li>
<li>
LoginPath - The path sequence for processing login requests. The default value is “login”. The login path will be /openid/login
</li>
<li>
LogoutPath - The path sequence for processing logout requests. The default value is “logout”. The login path will be /openid/logour
</li>
<li>
ResponsePath - The path sequence for processing login requests. The default value is “response”. The login path will be /openid/response
</li>
<li>
PostParamName - The form parameter name containing the OpeID identity URL entered by the user
</li>

</ul>
<div class="Unindented">
Also the vendor trait contains the loginForm function that returns the login form containing an input text field for the OpenID identity and the submit button. The form will point to /&lt;PathRoot&gt;/&lt;LoginPath&gt; where PathRoot and LoginPath are the variables described above. Here is an example:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
OpenID example
</div>
<pre class="listing brush: scala">// Your template
​
&lt;lift:OpenID.form&gt;
  &lt;openId:renderForm/&gt;
&lt;/lift:OpenID.form&gt;
​
// Your snippet
​
class OpenID {
​
  def renderForm(xhtml: NodeSeq) : NodeSeq = {
    SimpleOpenIdVendor.loginForm
  }
​
}
​
class Boot {
​
  ...
  // This is needed in order to process the login and logout requests and also to process
  // the response comming from OpenID provider
  LiftRules.dispatch.append(SimpleOpenIdVendor.dispatchPF)
  ...
​
}
​
​
</pre>
</div>

</div>
<div class="Indented">
That is pretty much all you need to add into your Lift application. The authentication flow is:
</div>
<ol>
<li>
User accesses your lift page that contains the OpenID form
</li>
<li>
User enters his/her OpenID identity URL and submits the form. Note that you don’t have to use the default login form asyou can construct your own as long as the form is submitted to the correct path and contains the correct input text parameter name.
</li>
<li>
The dispatchPF function that we appended above will process the /openid/login request and will send the authentication request to the Identity Provider site
</li>
<li>
Identity Provider will validate the user and redirect back to your Lift application to /openid/response path.
</li>
<li>
The response is validated using OpenId4Java library
</li>
<li>
<tt>OpenIdConsumer.postLogin</tt> gets called.
</li>

</ol>
<div class="Unindented">
The SimpleOpenIDVendor looks like:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
SimpleOpenIDVendor
</div>
<pre class="listing brush: scala">trait SimpleOpenIdVendor extends OpenIdVendor {   
  type UserType = Identifier   
  type ConsumerType = OpenIdConsumer[UserType]
  
  def currentUser = OpenIdUser.is
  def postLogin(id: Box[Identifier],res: VerificationResult): Unit = {
    id match {
      case Full(id) =&gt; S.notice("Welcome "+id)
      case _ =&gt; S.error("Failed to authenticate")
    }
    OpenIdUser(id)
  }
  def logUserOut() {
    OpenIdUser.remove   
  }
  def displayUser(in: UserType): NodeSeq = Text("Welcome "+in)
  def createAConsumer = new AnyRef with OpenIDConsumer[UserType]
}
object SimpleOpenIdVendor extends SimpleOpenIdVendor 
</pre>
</div>

</div>
<div class="Indented">
Note the postLogin implementation. Of course if you need a more complex post-login processing you can extend OpenIdVendor by yourself. 
</div>
<div class="Indented">
During this message exchange between the Identity Provider ans your Lift application, Lift utilizes a couple of SessionVars:
</div>
<ul>
<li>
OpenIdObject - holds an OpenIdConsumer
</li>
<li>
OpenIdUser - holding an org.openid4java.discovery.Identifier
</li>

</ul>
<h2 class="Section">
<a class="toc" name="toc-Section-13.2">13.2</a> AMQP 
</h2>
<div class="Unindented">
AMQP stands for <b>A</b>dvanced <b>M</b>essage <b>Q</b>ueuing <b>P</b>rotocol<span class="FootOuter"><span class="SupFootMarker"> [X] </span><span class="HoverFoot"><span class="SupFootMarker"> [X] </span>http://jira.amqp.org/confluence/display/AMQP/Advanced+Message+Queuing+Protocol</span></span>. It is an open Internet protocol for messaging. It is concepted as a binary representation of messages. Lift facilitates the work with AMQP using the RabbitMQ<span class="FootOuter"><span class="SupFootMarker"> [Y] </span><span class="HoverFoot"><span class="SupFootMarker"> [Y] </span>http://www.rabbitmq.com/</span></span> Java implementation. There are two fundamental classes:
</div>
<ul>
<li>
<tt>net.liftweb.amqp.AMQPSender</tt> - used for sending AMQP messages
</li>
<li>
<tt>net.liftweb.amqp.AMQPDispatcher</tt> - used for receiving AMQP messages
</li>

</ul>
<div class="Unindented">
Let’s see how we can use Lift to send AMQP messages
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
AMQP sending messages example<a class="Label" name="lst:AMQP-sending-messages"> </a>
</div>
<pre class="listing brush: scala">​
  import net.liftweb.amqp._
  import com.rabbitmq.client._ 
​
  val params = new ConnectionParameters
  // All of the params, exchanges, and queues are all just example data.
  params.setUsername("guest")
  params.setPassword("guest")
  params.setVirtualHost("/")
  params.setRequestedHeartbeat(0)
  val factory = new ConnectionFactory(params)
  val amqp = new StringAMQPSender(factory, "localhost", 5672, "mult", "routeroute")
  amqp.start
  amqp ! AMQPMessage("hi") 
</pre>
</div>

</div>
<div class="Indented">
As you can see the <tt>AMQSender</tt> is leveraging Scala actors to send messages. Scala actors and AMQP messaging concepts play very well together.
</div>
<div class="Indented">
Now let’s see how we can receive and process AMQP messages:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
AMQP receiving messages example
</div>
<pre class="listing brush: scala">​
import net.liftweb.amqp._
import com.rabbitmq.client._ 
​
/**
 * Example Dispatcher that listens on an example queue and exchange. Use this
 * as your guiding example for creating your own Dispatcher.
 *
 */
class ExampleSerializedAMQPDispatcher[T](factory: ConnectionFactory, host: String, port: Int)
    extends AMQPDispatcher[T](factory, host, port) {
​
  override def configure(channel: Channel) {
    // Get the ticket.
    val ticket = channel.accessRequest("/data")
    // Set up the exchange and queue
    channel.exchangeDeclare(ticket, "mult", "direct")
    channel.queueDeclare(ticket, "mult_queue")
    channel.queueBind(ticket, "mult_queue", "mult", "routeroute")
    // Use the short version of the basicConsume method for convenience.
    channel.basicConsume(ticket, "mult_queue", false, new SerializedConsumer(channel, this))
  }
}
​
/**
 * Example class that accepts Strings coming in from the
 * ExampleSerializedAMQPDispatcher.
 */
class ExampleStringAMQPListener {
  val params = new ConnectionParameters
  params.setUsername("guest")
  params.setPassword("guest")
  params.setVirtualHost("/")
  params.setRequestedHeartbeat(0)
  val factory = new ConnectionFactory(params)
  // thor.local is a machine on your network with rabbitmq listening on port 5672
  val amqp = new ExampleSerializedAMQPDispatcher[String](factory, "thor.local", 5672)
  amqp.start
​
  // Example Listener that just prints the String it receives.
  class StringListener extends Actor {
    def act = {
      react {
        case msg@AMQPMessage(contents: String) =&gt; println("received: " + msg); act
      }
    }
  }
  val stringListener = new StringListener()
  stringListener.start
  amqp ! AMQPAddListener(stringListener) 
} 
</pre>
</div>

</div>
<div class="Indented">
First of all don’t get scared about this. The above classes are already existent so you can just reuse them. However the point of showing them here is to understand how to use a AMQP consumer, how to configure it to match the client settings from the Listing 1.3<a class="Reference" href="#lst:AMQP-sending-messages">13.2↑</a>. The key here is to see how the actual messages are consumed. Note the StringListener actor is consumming the <tt>AMQPMessage</tt> but the actor itself it provided to <tt>AMQPDispatcher</tt>. What happens is that when a real AMQP message is received by <tt>AMQPDispatcher</tt> it will just forward it to the user’sActor for actuall processing. SerializedConsumer class is actually doing the transformation of the raw data (array of byte-s) into <tt>AMQPMessage</tt> messages.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-13.3">13.3</a> PayPal
</h2>
<div class="Unindented">
Paypal<span class="FootOuter"><span class="SupFootMarker"> [Z] </span><span class="HoverFoot"><span class="SupFootMarker"> [Z] </span>https://www.paypal.com</span></span> is the notorious service that allows you to do online payment transactions. Lift supports both 
</div>
<div class="Indented">
PDT(Payment Data Transferr)<span class="FootOuter"><span class="SupFootMarker"> [A] </span><span class="HoverFoot"><span class="SupFootMarker"> [A] </span>https://www.paypal.com/en_US/i/IntegrationCenter/scr/scr_ppPDTDiagram_513x282.gif</span></span>as well as 
</div>
<div class="Indented">
IPN(Instant Payment Notification)<span class="FootOuter"><span class="SupFootMarker"> [B] </span><span class="HoverFoot"><span class="SupFootMarker"> [B] </span>https://www.paypal.com/en_US/i/IntegrationCenter/scr/scr_ppIPNDiagram_555x310.gif</span></span> API’ sprovided by PayPal. We won’t be getting into PayPal API details as this information can be found on PayPal site. However let’s see how we’d use PDT and IPN.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
PDT Example
</div>
<pre class="listing brush: scala">import net.liftweb.paypal._
​
object MyPayPalPDT extends PayPalPDT {
  override def pdtPath = "paypal_complete"
  def paypalAuthToken = Props.get("paypal.authToken") openOr "cannot find auth token from props file"
​
  def pdtResponse: PartialFunction[(PayPalInfo, Req), LiftResponse] = {
    case (info, req) =&gt; println("— in pdtResponse"); DoRedirectResponse("/account_admin/index");
  }
}
​
// in Boot
​
def boot(){
  ...
  LiftRules.statelessDispatchTable.append(MyPayPalPDT)
  ...
}
​
</pre>
</div>

</div>
<div class="Indented">
That is pretty much it. <tt>pdtResponse</tt> function allows you to determine the behavior of you application upon receiving the reponse from PayPal.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
IPN Example
</div>
<pre class="listing brush: scala">import net.liftweb.paypal._
​
object MyPayPalIPN extends PayPalIPN {
  def actions = {
    case (ClearedPayment, info, req) =&gt; // do your processing here
    case (RefundedPayment, info, req) =&gt; // do refund processing 
  }
}
​
// in Boot
​
def boot(){
  ...
  LiftRules.statelessDispatchTable.append(MyPayPalIPN)
  ...
}
​
</pre>
</div>

</div>
<div class="Indented">
As you can see everything is pretty strightforward. Just pattern match on the <tt>PaypalTransactionStatus</tt>. It is worth to note sthat IPN is a ’machine-to-machine’ API which happens in the background without the end user interraction.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-13.4">13.4</a> Facebook
</h2>
<div class="Unindented">
Facebook<span class="FootOuter"><span class="SupFootMarker"> [C] </span><span class="HoverFoot"><span class="SupFootMarker"> [C] </span>http://www.facebook.com</span></span> is the well known site that simply allows people to easily interract, build social graphs share photos etc. Facebook also exposes HTTP API’s<span class="FootOuter"><span class="SupFootMarker"> [D] </span><span class="HoverFoot"><span class="SupFootMarker"> [D] </span>http://wiki.developers.facebook.com/index.php/API</span></span> that allows other applications to interract with it. Lift framework allows your application to easily interract with Facebook by providing an abstraction layer over the Facebook API. Here is an example:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Facebook example
</div>
<pre class="listing brush: scala">​
import net.liftweb.ext_api.facebook._
​
FacebookRestApi.apiKey = &lt;your API key&gt;;
FacebookRestApi.secret = &lt;your secret&gt;;
​
// The api key is ontained from System.getProperty("com.facebook.api_key")
// The secreat is obtained from System.setProperty("com.facebook.secret", key) 
​
​
// Invoke stateless calls
val respNode: Node = FacebookClient !? AuthCreateToken
val authToken = // extract authToken from respNode
​
// Obtain a stateful client based on the authToken
val faceBookClient = FacebookClient fromAuthToken(authToken)
​
faceBookClient !? GetFriendLists
​
</pre>
</div>

</div>
<div class="Indented">
Once you have the FacebookClient you can invoke numerous API methods described by <tt>FacebookMethod</tt> or <tt>SessionlessFacebookMethod</tt>. In the above examplewe are creating the FaceBook context by first obtaining an authToken and then obtaining a <tt>faceBookClient</tt> reference bound to the newly created session. After that we’re just ontaining the friends list.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-13.5">13.5</a> XMPP
</h2>
<div class="Unindented">
XMPP<span class="FootOuter"><span class="SupFootMarker"> [E] </span><span class="HoverFoot"><span class="SupFootMarker"> [E] </span>http://xmpp.org/</span></span> stands for e<b>X</b>tensible <b>M</b>essaging and <b>P</b>resence <b>P</b>rotocol. It is an XML-based protocol used for presence and realtime communication such as instant messaging (Jabber and GoogleTalk being two of the more famous users). It is developed by the Jabber<span class="FootOuter"><span class="SupFootMarker"> [F] </span><span class="HoverFoot"><span class="SupFootMarker"> [F] </span>http://xmpp.org/about/jabber.shtml</span></span> open-source community. Lift provides an XMPP dispatcher implementation that your application can use to receive instant messages, manage rosters etc. This support relies on the Smack <span class="FootOuter"><span class="SupFootMarker"> [G] </span><span class="HoverFoot"><span class="SupFootMarker"> [G] </span>http://www.igniterealtime.org/downloads/index.jsp</span></span> XMPP client library and utilizes Scala actors for the interface. Here is an example:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
XMPP Example
</div>
<pre class="listing brush: scala">import net.liftweb.xmpp._
​
/**
 * An example Chat application that prints to stdout.
 *
 * @param username is the username to login to at Google Talk: format: something@gmail.com
 * @param password is the password for the user account at Google Talk.
 */
class ConsoleChatActor(val username: String, val password: String) extends Actor {
  def connf() = new ConnectionConfiguration("talk.google.com", 5222, "gmail.com")
  def login(conn: XMPPConnection) = conn.login(username, password)
  val xmpp = new XMPPDispatcher(connf, login)
  xmpp.start
​
  val chats: Map[String, List[Message]] = new HashMap[String, List[Message]]
  val rosterMap: HashMap[String, Presence] = new HashMap[String, Presence]
  var roster: Roster = null
  def act = loop
​
  def loop { 
   react {
      case Start =&gt; {
        xmpp ! AddListener(this)
        xmpp ! SetPresence(new Presence(Presence.Type.available))
        loop
      }
      case NewChat(c) =&gt; {
        chats += (c.getParticipant -&gt; Nil)
        loop
      }
      case RecvMsg(chat, msg) =&gt; {
        println("RecvMsg from: " + msg.getFrom + ": " + msg.getBody);
        loop 
      }
      case NewRoster(r) =&gt; {
        println("getting a new roster: " + r)
        this.roster = r
        val e: Array[Object] = r.getEntries.toArray.asInstanceOf[Array[Object]]
        for (entry &lt;- e) {
          val user: String = entry.asInstanceOf[RosterEntry].getUser
          rosterMap += (user -&gt; r.getPresence(user))
        }
        loop
      }
​
      case RosterPresenceChanged(p) =&gt; { 
        val user = StringUtils.parseBareAddress(p.getFrom)
        println("Roster Update: " + user + " " + p)
        // It’s best practice to ask the roster for the presence. This is because
        // multiple presences can exist for one user and the roster knows which one 
        // has priority. 
        rosterMap += (user -&gt; roster.getPresence(user))
        loop
      }
      case RosterEntriesDeleted(e) =&gt; {
        println(e) 
        loop 
      } 
      case RosterEntriesUpdated(e) =&gt; {
        println(e)
        loop
      }
      case RosterEntriesAdded(e) =&gt; { 
        println(e)
        loop 
      }
      case a =&gt; println(a); loop
    }
  }
  def createChat(to: String) {
    xmpp ! CreateChat(to)
  }
  def sendMessage(to: String, msg: String) {
    xmpp ! SendMsg(to, msg)
  }
​
 /**
  * @returns an Iterable of all users who aren’t unavailable along with their Presence
  */
 def availableUsers: Iterable[(String, Presence)] = {
   rosterMap.filter((e) =&gt; e._2.getType() != Presence.Type.unavailable)
 }
}
​
object ConsoleChatHelper {
  /**
   * @param u is the username
   * @param p is the password
   */
  def run(u: String, p: String) = {
    val ex = new ConsoleChatActor(u, p)
    ex.start 
    ex ! Start 
    ex 
  }
}
​
// To start the dispatcher just call:
​
ConsoleChatHelper.run(userName, password);
​
...
</pre>
</div>

</div>
<div class="Indented">
The above is an example how you can integrate your application with an XMPP server and how messages are pocessed.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-13.6">13.6</a> Lucene/Compass Integration
</h2>
<div class="Unindented">
<div class="Framed" style="width: 100%;">
This chapter is still under active development. The contents will change.
</div>

</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-14">14</a> Lift Widgets<a class="Label" name="cha:Lift-Widgets"> </a>
</h1>
<div class="Unindented">
In this chapter we’re going to discuss widgets in Lift. A widget is essentially a library of Scala and JavaScript code that together provide packaged XHTML fragments for display on the client browser. In other web frameworks (JSF, Struts, etc) these are sometimes called components. An example of a widget would be small library that automatically embeds a Calendar instance (section <a class="Reference" href="#sub:Calendar-widgets">14.1.2↓</a>), or a helper library to sort HTML tables (section <a class="Reference" href="#sub:TableSorter-widget">14.1.1↓</a>). Typically widgets embody dynamic behavior on the client side, which is what makes them so attractive; static client-side content is already dead simple to generate in Lift with snippets, so the extra sauce of JavaScript binding and Ajax callbacks really makes advanced functionality easy.
</div>
<div class="Indented">
Lift’s widgets are intended to minimize effort on your part. Unlike some other frameworks where widgets/components require the use of specific traits or special XML binding, Lift (and Scala’s) inherent flexibility with XML, JavaScript abstraction, and snippet generators make using widgets as simple as dropping in a few lines of code to your existing snippets or views.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-14.1">14.1</a> Current Lift Widgets
</h2>
<div class="Unindented">
To start, we’ll cover the current set of widgets included in Lift at the time of writing this book. These widgets are contained in the lift-widgets module, which means you’ll need to add the dependency to your pom.xml if you want to use them (section <a class="Reference" href="#sub:Adding-a-Dependency">A.5.1↓</a>). While this list will likely grow over time, remember that widgets are based on the fundamentals of Scala’s XML functionality as well as Lift’s JavaScript support (chapter <a class="Reference" href="#cha:Lift-and-Javascript">10↑</a>), so the same general rules apply to all of them. At the end of the chapter we’ll cover writing your own widgets (section <a class="Reference" href="#sec:How-to-build-widgets">14.2↓</a>).
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-14.1.1">14.1.1</a> TableSorter widget<a class="Label" name="sub:TableSorter-widget"> </a>
</h3>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-14.1"> </a><div class="figure">
<div class="center">
<img class="embedded" src="images/tablesorter.png" alt="figure images/tablesorter.png" style="width: 5in; max-width: 947px; height: auto; max-height: 130px;"/>

</div>
<div class="caption">
Figure 14.1 TableSorter widget
</div>

</div>

</div>

</div>
<div class="Indented">
The TableSorter widget is based on the TableSorter jQuery plugin<span class="FootOuter"><span class="SupFootMarker"> [H] </span><span class="HoverFoot"><span class="SupFootMarker"> [H] </span><a class="URL" href="http://tablesorter.com/docs/">http://tablesorter.com/docs/</a></span></span>. Basically, the TableSorter widget allows you to take an existing HTML table (THEAD and TBODY tags are required) and add sorting to columns in the table. By default, the widget handles sorting of numeric, currency, and other value types automatically. The full capabilities of the plugin are beyond the scope of the widget, however; if you need more features you’ll have to set up the JavaScript yourself instead of using the widget.
</div>
<div class="Indented">
The first step in using the widget is to call the <tt>TableSorter.init </tt>function in your Boot class to make Lift aware of the resources used by this widget. Then, you need to set up a table in your page (either statically in the template or via a snippet):
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
TableSorter Template
</div>
<pre class="listing brush: xml">&lt;lift:surround with="default" at="content"&gt;
    &lt;lift:TableSorterDemo/&gt;
    &lt;table id="table-id" class="tablesorter"&gt; ... &lt;/table&gt;
&lt;/lift:surround&gt;
</pre>
</div>

</div>
<div class="Indented">
Note that you need to have an <tt>id</tt> attribute on the table and add the <tt>tablesorter</tt> class to the table element. Next you simply call the TableSorter widget from a snippet:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
TableSorter Snippet
</div>
<pre class="listing brush: scala">class TableSorterDemo {
 def render(xhtml: NodeSeq): NodeSeq = TableSorter("table-id")
}
​
</pre>
</div>

</div>
<div class="Indented">
The argument to TableSorter is the HTML element <tt>id</tt> of the table you want sorted. The TableSorter code relies on head merge (section <a class="Reference" href="#sec:Head-Merge">↓</a>) to put the appropriate JavaScript and jQuery functions into the returned page.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-14.1.2">14.1.2</a> Calendar widgets<a class="Label" name="sub:Calendar-widgets"> </a>
</h3>
<div class="Unindented">
There are three calendar widgets corresponding to month, week and day views. These widgets display calendars with a similar look and feel to Microsoft Outlook or Google Calendar.They provide basic functionality for display, but you can easily customize CSS and JavaScript hooks for calendar items to fit your application requirements.
</div>
<div class="Paragraph">
<a class="toc" name="toc-Paragraph-1"></a>Calendar Month-View
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-14.2"> </a><div class="figure">
<div class="center">
<img class="embedded" src="images/month-view.png" alt="figure images/month-view.png" style="width: 5in; max-width: 730px; height: auto; max-height: 375px;"/>

</div>
<div class="caption">
Figure 14.2 Calendar Month-View
</div>

</div>

</div>

</div>
<div class="Indented">
This widget allows you to create month view calendars in your web page, manage your calendar events etc. The first thing you need to do is call the <tt>CalendarMonthView.init</tt> function in your Boot class; this performs initialization by telling Lift’s <tt>ResourceServer</tt> about the paths to JavaScripts and stylesheets needed by this widget since these dependencies are embedded in the same jar file (we’ll cover this topic more in section <a class="Reference" href="#sec:How-to-build-widgets">14.2↓</a>).
</div>
<div class="Indented">
The template for our widget example is relatively straightforward, as shown in listing <a class="Reference" href="#lst:Month-view-template">1↓</a>. Basically, we provide a binding element where the calendar will be rendered.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Month view template<a class="Label" name="lst:Month-view-template"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:surround with="default" at="content"&gt;
    &lt;h2&gt;Calendar Month View Demo&lt;/h2&gt;
    &lt;lift:CalendarMonthViewDemo&gt; 
           &lt;cal:widget/&gt;
    &lt;/lift:CalendarMonthViewDemo&gt;
&lt;/lift:surround&gt; 
</pre>
</div>

</div>
<div class="Indented">
In our snippet code, listing <a class="Reference" href="#lst:Month-view-snippet">1↓</a>, we first perform some setup of the widget. The Calendar widget takes a <tt>java.util.Calendar</tt> instance telling it which month to display. Additionally, it takes a Seq[CalendarItem] of items to be displayed on the calendar. Finally, it takes three arguments containing optional JavaScript functions to be called when an item, day, or week is clicked, respectively. In our example we’re not showing any events or setting up any callbacks.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Month view snippet<a class="Label" name="lst:Month-view-snippet"> </a>
</div>
<pre class="listing brush: scala">class CalendarMonthViewDemo {
  def render(html: Group) : NodeSeq = {
    val c = Calendar.getInstance;
    c.set(MONTH, 0)     
    bind("cal", html,
         "widget" -&gt; CalendarMonthView(c, Nil, Empty, Empty, Empty)
    )
  }
</pre>
</div>

</div>
<div class="Indented">
In addition, CalendarMonthView can also take a MonthViewMeta instance as the second argument so that you can control the first day of the week and the locale used for formatting dates and times. For instance, we could set the calendar to use Monday as the first day of the week:
</div>
<div class="Indented">
<div class="listing">
<pre class="listing brush: scala">"widget" -&gt; CalendarMonthView(c, 
              MonthViewMeta(Calendar.MONDAY, Locale.getDefault),
              Nil, Empty, Empty, Empty)
</pre>
</div>

</div>
<div class="Indented">
Of course, without anything to display or do this isn’t very useful, so let’s look at how you create CalendarItems. 
</div>
<div class="Indented">
Listing <a class="Reference" href="#lst:CalendarItem-example">1↓</a> shows how we can create a calendar item for a meeting on June 5th at 2:30 pm. We have to set up another Calendar instance to hold the time of the meeting, then we use the CalendarItem helper object to set up the actual item instance. The first parameter is the id of the div that will be created for the item. This can be used from other scripts if needed. The second argument is the time of the event. The third argument is the CalendarType of the event, in this case, a meeting. The optional method on CalendarItem allows you to set optional attributes essentially via a sequence of <span class="formula">(<i>CalendarItem</i>) ⇒ <i>CalendarItem</i></span> functions. This technique is used since CalendarItems are immutable and modifying them returns new instances.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
CalendarItem example<a class="Label" name="lst:CalendarItem-example"> </a>
</div>
<pre class="listing brush: scala">val time = Calendar.getInstance
time.setTime(DateFormat.pars("2009-06-05 2:30pm"))
val meeting = CalendarItem("4", time, CalendarType.MEETING) optional (
        _ end(time),
        _ subject("Important Meeting!"))
</pre>
</div>

</div>
<div class="Indented">
The widget renders not only the XHTML to display the calendar, but it generates the <tt>&lt;script&gt;</tt> and CSS tags using head merge to control display. One common customization of the widget would be to override the CSS used; to do this, provide your own <tt>style.css</tt> file under the WEB-INF/classes/calendars/monthview directory in your project. Because Lift uses the classpath to load resources, your style.css file will be “found” before the default one bundled in the lift-widgets jar file. You can use the default <tt>style.css</tt> as a starting point<span class="FootOuter"><span class="SupFootMarker"> [I] </span><span class="HoverFoot"><span class="SupFootMarker"> [I] </span><a class="URL" href="http://github.com/dpp/liftweb/tree/master/lift-widgets/src/main/resources/toserve/calendars/monthview/style.css">http://github.com/dpp/liftweb/tree/master/lift-widgets/src/main/resources/toserve/calendars/monthview/style.css</a></span></span>.
</div>
<div class="Indented">
The final thing we’d like to cover for the Month view is the JavaScript callbacks. These callbacks are constructed using the AnonFunc JavaScript artifact, which essentially constructs an anonymous function on the client side. Listing <a class="Reference" href="#lst:Calendar-callback-example">1↓</a> shows an example of using the callbacks to redirect to an event view page for the given event when the item is clicked. In this example we assume that the id of each calendar item is its unique id in the ORM (section <a class="Reference" href="#sub:Object-Relationships">8.1.4↑</a>) and that we have a rewrite rule set up to handle item viewing (section <a class="Reference" href="#sec:URL-Rewriting">3.7↑</a>). 
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Calendar callback example<a class="Label" name="lst:Calendar-callback-example"> </a>
</div>
<pre class="listing brush: scala">import JsCmds._
val itemClick = Full(
  AnonFunc("elem, param", JsRaw("alert(elem);")
</pre>
</div>

</div>
<div class="Paragraph">
<a class="toc" name="toc-Paragraph-2"></a>Calendar Week-View
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-14.3"> </a><div class="figure">
<div class="center">
<img class="embedded" src="images/week-view.png" alt="figure images/week-view.png" style="width: 5in; max-width: 901px; height: auto; max-height: 359px;"/>

</div>
<div class="caption">
Figure 14.3 Calendar Week-View
</div>

</div>

</div>

</div>
<div class="Indented">
The CalendarWeekView widget provides a weekly view of the calendar. The same general principles apply as for month view. Again, you need to initialize the CalendarWeekView by calling the <tt>CalendarWeekView.init</tt> function in your Boot class. 
</div>
<div class="Indented">
Listing <a class="Reference" href="#lst:Week-View-example">2↓</a> shows a snippet returning a week view. As you can see, we still use a Calendar instance to set the time, and we also provide a WeekViewMeta in this example to set the first day of the week and the locale. The <tt>list</tt> argument is a Seq[CalendarItem], constructed exactly the same as for a month view. Finally, we provide a JavaScript item callback. Note that there aren’t day or week callbacks available.
</div>
<div class="Indented">
<div class="listing">
 <div class="caption">
Week view example<a class="Label" name="lst:Week-View-example"> </a>
</div>
<pre class="listing brush: scala">class CalendarWeekViewDemo {
 def render(html: Group) : NodeSeq = {
  val c = Calendar.getInstance
  c.set(DAY_OF_MONTH, 17)
  c.set(MONTH, 4)
  bind("cal", html,
       "widget" -&gt; CalendarWeekView(c, 
         WeekViewMeta(MONDAY, Locale.getDefault()),
         list,
         itemClick))
 }
}
</pre>
</div>

</div>
<div class="Paragraph">
<a class="toc" name="toc-Paragraph-3"></a>Calendar Day-View
</div>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-14.4"> </a><div class="figure">
<div class="center">
<img class="embedded" src="images/day-view.png" alt="figure images/day-view.png" style="width: 5in; max-width: 564px; height: auto; max-height: 364px;"/>

</div>
<div class="caption">
Figure 14.4 Calendar Day-View 
</div>

</div>

</div>

</div>
<div class="Indented">
The CalendarDayView widget renders a calendar for a single day. The usage is essentially the same as for the month and week views, as shown in listing <a class="Reference" href="#lst:Day-view-example">3↓</a>:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Day view example<a class="Label" name="lst:Day-view-example"> </a>
</div>
<pre class="listing brush: scala">class CalendarDayViewDemo {
 def render(html: Group) : NodeSeq = {
   val c = Calendar.getInstance
   c.set(DAY_OF_MONTH, 17)
   c.set(MONTH, 4)
   bind("cal", html,
        "widget" -&gt; CalendarDayView(c, 
          DayViewMeta(Locale.getDefault()),
          list, itemClick)
   )
 } 
​
</pre>
</div>

</div>
<div class="Indented">
The parameters are essentially the same, except that the Calendar object represents the day that we want to render and we pass a DayViewMeta containing just the Locale for internationalization purposes. Again, only an item click callback is available.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-14.1.3">14.1.3</a> RSS Feed widget
</h3>
<div class="Unindented">
<div class="float">
<a class="Label" name="Figure-14.5"> </a><div class="figure">
<div class="center">
<img class="embedded" src="images/rssfeed.png" alt="figure images/rssfeed.png" style="width: 4in; max-width: 505px; height: auto; max-height: 284px;"/>

</div>
<div class="caption">
Figure 14.5 RSSFeed widget
</div>

</div>

</div>

</div>
<div class="Indented">
The RSS feed widget, like its name implies, simply renders RSS feeds. This widget does not need initialization in Boot since it has no dependencies on JavaScript, CSS, etc. In your snippet you simply use the RSSFeed helper object with the RSS feed URL:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
RSSFeed example
</div>
<pre class="listing brush: scala">class RSSFeedDemo {
  def render(xhtml: NodeSeq): NodeSeq = {
    RSSFeed("http://www.praytothemachine.com/evil/index.php/feed/")
  }
}
</pre>
</div>

</div>
<div class="Indented">
Although the RSSFeed widget doesn’t provide its own CSS, the generated elements do have CSS classes attached to them that you can provide styling for:
</div>
<div class="Description">
<span class="Description-entry">rsswidget</span> This class is attached to the outer div that contains all of the feed elements
</div>
<div class="Description">
<span class="Description-entry">rsswidgettitle</span> This class is attached to the &lt;li&gt; that holds the title of the feed
</div>
<div class="Description">
<span class="Description-entry">rsswidgetitem</span> This class is attached to each &lt;li&gt; element that holds an RSS item
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-14.1.4">14.1.4</a> Gravatar widget
</h3>
<div class="Unindented">
Gravatars are <b>g</b>lobally <b>r</b>ecognized <b>avatars</b><span class="FootOuter"><span class="SupFootMarker"> [J] </span><span class="HoverFoot"><span class="SupFootMarker"> [J] </span><a class="URL" href="http://gravatar.com">http://gravatar.com</a></span></span>. You can add your picture at the Gravatar website and associate it with one or more email addresses. Sites that interact with Gravatar can fetch your picture and display it, which is what the Gravatar widget does. Listing <a class="Reference" href="#lst:Gravatar-example">14.1.4↓</a> shows an example snippet that will render the Gravatar for the currentUser into a <tt>&lt;div&gt;</tt>, if available. The default size of the Gravatar is 42x42 pixels, but you can override this with additional parameters on the Gravatar.apply method. Additionally, you can filter the Gravatar based on its rating (the default rating is “G” only).
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Gravatar example<a class="Label" name="lst:Gravatar-example"> </a>
</div>
<pre class="listing brush: scala">class GravatarDemo {
  def render(xhtml: NodeSeq) :NodeSeq = {
   Gravatar(currentUser.email)
  }
}
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-14.1.5">14.1.5</a> TreeView widget
</h3>
<div class="Unindented">
The TreeView widget transforms an unordered list (<tt>&lt;ul&gt;</tt>) into a tree-like structure using the TreeView JQuery plugin <span class="FootOuter"><span class="SupFootMarker"> [K] </span><span class="HoverFoot"><span class="SupFootMarker"> [K] </span><a class="URL" href="http://docs.jquery.com/Plugins/Treeview">http://docs.jquery.com/Plugins/Treeview</a></span></span>. Each nested unordered list gets decorated with a +/- sign that allows you to collapse or expand the entire sublist, as shown in figure <a class="Reference" href="#fig:TreeView-widget">14.6↓</a>.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="fig:TreeView-widget"> </a><div class="figure">
<div class="center">
<img class="embedded" src="images/treeview.png" alt="figure images/treeview.png" style="width: 3.5in; max-width: 458px; height: auto; max-height: 311px;"/>

</div>
<div class="caption">
Figure 14.6 TreeView widget
</div>

</div>

</div>

</div>
<div class="Indented">
To use this widget you first need to initialize the widget by calling the <tt>TreeView.init</tt> function in your Boot class. For basic usage, your snippet looks like listing <a class="Reference" href="#lst:TreeView-snippet">14.1.5↓</a>. The first argument is the id of the unordered list that you want transformed into a tree. The second argument is a JSON object that is used to configure the tree view. In our example, we’re setting the treeview to animate opening and closing of nodes with a 90 millisecond delay; for more options see the treeview jQuery documentation page.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
TreeView snippet<a class="Label" name="lst:TreeView-snippet"> </a>
</div>
<pre class="listing brush: scala">class TreeViewDemo {
  def render(xhtml: Group): NodeSeq = {
    TreeView("example", JsObj(("animated" -&gt; 90)))
  }
}
</pre>
</div>

</div>
<div class="Indented">
In addition to transforming static lists into trees, the TreeView widget also supports asynchronous loading of trees and nodes via Ajax calls. In order to do this, you still need to provide an empty <tt>&lt;ul&gt;</tt> element with an id attribute; this is essentially modified in place as portions of the tree are loaded. Next, you provide two functions that are used to retrieve the Tree data:
</div>
<ol>
<li>
A function <span class="formula">() ⇒ <i>List</i>[<i>Tree</i>]</span> to load the initial view of the tree. This is what will be displayed to the client when the page loads, so if you want some nodes to be available without having to make an Ajax call this is where you define it.We will explain the Tree class in a moment.
</li>
<li>
A function <span class="formula">(<i>String</i>) ⇒ <i>List</i>[<i>Tree</i>]</span> to load the children of a given node (the String argument is the node’s id)
</li>

</ol>
<div class="Unindented">
The Tree class defines each node in the tree and contains several values that define the appearance and behavior of the node:
</div>
<div class="Description">
<span class="Description-entry">text</span> The text to be displayed in the list item. 
</div>
<div class="Description">
<span class="Description-entry">id</span> The optional HTML id of the element
</div>
<div class="Description">
<span class="Description-entry">classes</span> An optional string defining CSS classes to be assigned to the element
</div>
<div class="Description">
<span class="Description-entry">expanded</span> A boolean controlling whether the element will be expanded initially (only valid if the haschildren is true or if the children list is populated)
</div>
<div class="Description">
<span class="Description-entry">hasChildren</span> If this is set to true but the children value is Nil, then the TreeView widget will dynamically load the children of this node as described in item #2 above
</div>
<div class="Description">
<span class="Description-entry">children</span> A List[Tree] defining the children of this element. Setting this value will prevent Ajax from being used to retrieve the list of children from the server on expansion
</div>
<div class="Unindented">
The Tree companion object has a number of overloaded apply methods that make it easy to set one or more of these values without having to set all of them.
</div>
<div class="Indented">
To provide a concrete example, listing <a class="Reference" href="#lst:Tree-example">14.1.5↓</a> shows implementations of the loadTree and loadNode functions corresponding to the two Ajax functions used to dynamically construct the tree.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Tree example<a class="Label" name="lst:Tree-example"> </a>
</div>
<pre class="listing brush: scala">def loadTree () = {
  Tree("No children") :: 
  Tree("One static child", Tree("Lone child") :: Nil) ::
  Tree("Dynamic node", "myDynamic", true) :: Nil
}
​
def loadNode (id : String) : List[Tree] = id match {
  case "myDynamic" =&gt; 
    Tree("Child one") ::
    Tree("Child two") :: Nil
  case _ =&gt; Nil
}
</pre>
</div>

</div>
<div class="Indented">
In this example the initial view will show three nodes; the third node (“Dynamic node”) will fetch its children via an Ajax call when expanded. The <tt>loadNode</tt> method will then handle this call by adding two static leaf nodes to the tree.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-14.1.6">14.1.6</a> Sparklines widget
</h3>
<div class="Unindented">
The Sparklines widget is based on Will Larson’s excellent Sparklines JavaScript library<span class="FootOuter"><span class="SupFootMarker"> [L] </span><span class="HoverFoot"><span class="SupFootMarker"> [L] </span><a class="URL" href="http://www.willarson.com/code/sparklines/sparklines.html">http://www.willarson.com/code/sparklines/sparklines.html</a></span></span>. Sparklines are essentially small, high resolution charts embedded in text that provide a wealth of information in a compact representation<span class="FootOuter"><span class="SupFootMarker"> [M] </span><span class="HoverFoot"><span class="SupFootMarker"> [M] </span>The term “Sparkline” was introduced by Edward Tufte in his book <i>Beautiful Evidence</i>. Dr. Tufte’s work is a must read for anyone who si working with visualizing large volumes of data.</span></span>.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="fig:Sparklines-bar-chart"> </a><div class="figure">
<div class="center">
<img class="embedded" src="images/sparklines.png" alt="figure images/sparklines.png" style="width: 3.5in; max-width: 503px; height: auto; max-height: 202px;"/>

</div>
<div class="caption">
Figure 14.7 Sparklines bar chart
</div>

</div>

</div>

</div>
<div class="Indented">
As with our other widgets, you need to initialize the widget in your Boot class by calling <tt>Sparklines.init</tt>. Listing <a class="Reference" href="#lst:Sparklines-snippet">14.1.6↓</a> shows a simple snippet utilizing the widget to produce the graph shown in figure <a class="Reference" href="#fig:Sparklines-bar-chart">14.7↑</a>. In your template you need to provide a canvas element with an <tt>id</tt> attribute that will be used by the widget for its content. In our example we provide a JsArray (an abstracted JavaScript array) with our data, as well as a JSON object containing options for the chart<span class="FootOuter"><span class="SupFootMarker"> [N] </span><span class="HoverFoot"><span class="SupFootMarker"> [N] </span>More options can be found on Will Larson’s Sparklines web page</span></span>. We’ve set our options to draw percentage lines for the bar chart as well as filling in the area between the percentage lines. Finally, we call the Sparklines.onLoad method to generate the chart drawing code (the chart will be drawn when the page is loaded). The Sparklines library currently handles bar and line charts, which are chosen via the SparklineStyle enumeration.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Sparklines snippet<a class="Label" name="lst:Sparklines-snippet"> </a>
</div>
<pre class="listing brush: scala">class SparklinesDemo {
  def render(html: NodeSeq): NodeSeq = {
    val data = JsArray(100,500,300,200,400,500,400,400,
                       100,200, 345, 412, 111, 234, 490);
    val opts = JsObj(("percentage_lines" -&gt; JsArray(0.5, 0.75)),
                     ("fill_between_percentage_lines" -&gt; true),
                     ("extend_markings" -&gt; false));
    Sparklines.onLoad("bar", SparklineStyle.BAR, data, opts);
  }
}
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-14.2">14.2</a> How to build a widget<a class="Label" name="sec:How-to-build-widgets"> </a>
</h2>
<div class="Unindented">
As we explained in the introduction, there is no magic formula when building a widget since Lift and Scala provide so much base functionality without having to resort to restrictions like traits or static XML binding. However, there are a few items to note if you want to design your own widgets
</div>
<div class="Indented">
Generally it’s useful to make your widget a self-contained JAR file to simplify dependency management and deployment. Including things like style sheets and javascript libraries in your package is quite straightforward if you’re using Maven, but the question then becomes how do you access these resources from a Lift application. Fortunately, Lift provides some very simple mechanisms for using class loaders to retrieve resources. The basic functionality is handled through the <tt>ResourceServer</tt> object<span class="FootOuter"><span class="SupFootMarker"> [O] </span><span class="HoverFoot"><span class="SupFootMarker"> [O] </span>net.liftweb.http.ResourceServer</span></span>, which we cover in detail in section <a class="Reference" href="#sub:ResourceServer">9.8↑</a>. This object controls resource loading, and in particular handles where resources can be loaded from. Listing <a class="Reference" href="#lst:Adding-ResourceServer-permissions">14.2↓</a> shows an example init method (similar to those that we’ve previously used for the existing widgets) that tells the ResourceServer that it can load resources from the path “/classpath/mywidget”. You would locate these resources under the <tt>mywidget</tt> package in your widget project.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Adding ResourceServer permissions<a class="Label" name="lst:Adding-ResourceServer-permissions"> </a>
</div>
import _root_.net.liftweb.http.ResourceServer<pre class="listing brush: scala">def init() {     
  ResourceServer.allow{
    case "iframewidget" :: _ =&gt; true     
  }
}
</pre>
</div>

</div>
<div class="Indented">
Once you’ve set up the appropriate permissions, your widget can generate links or scripts that load from within the classpath, as shown in listing <a class="Reference" href="#lst:Sample-widget-rendering">14.2↓</a>. In this example we’ve defined a simple (and slightly ridiculous) widget that renders a given URL into an IFrame element.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Sample widget rendering<a class="Label" name="lst:Sample-widget-rendering"> </a>
</div>
<pre class="listing brush: scala">class IFrameWidget {
  def render(url : String) = 
    &lt;head&gt;
      &lt;link type="text/css" rel="stylesheet" 
         href={LiftRules.resourceServerPath + "/iframewidget/style.css"/&gt;
    &lt;/head&gt;
    &lt;div class="iframeDiv"&gt;
      &lt;iframe src={url}&gt;
        &lt;p&gt;Your browser doesn’t support IFrames&lt;/p&gt;
      &lt;/iframe&gt;
    &lt;/div&gt;
}
</pre>
</div>

</div>
<div class="Indented">
Note the path that we used uses the <tt>LiftRules.resourceServerPath </tt>variable. It’s preferable to use this mechanism instead of hardcoding “/classpath” to allow for end-user flexibility. We also use head merge to make sure the proper stylesheet is loaded for the page.
</div>
<div class="Indented">
As you can see, defining your own widget is not much different than writing a snippet. The major difference is in making resources accessible while bundling and making sure that you avoid hardcoding properties that are configurable by the end-users of your widget.
</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-15">15</a> RESTful Web Services<a class="Label" name="cha:Web-Services"> </a>
</h1>
<div class="Unindented">
Many web applications today offer an API<span class="FootOuter"><span class="SupFootMarker"> [P] </span><span class="HoverFoot"><span class="SupFootMarker"> [P] </span>Application Programming Interface</span></span> that allows others to extend the functionality of the application. An API is a set of exposed functions that is meant to allow third parties to reuse elements of the application. There is a number of sites that catalog the available APIs, such as ProgrammableWeb (see <a class="FlexURL" href="http://www.programmableweb.com/">http://www.programmableweb.com/</a>). An example of a site that has combined the GoogleMaps and Flickr APIs is FlickrVision.com<span class="FootOuter"><span class="SupFootMarker"> [Q] </span><span class="HoverFoot"><span class="SupFootMarker"> [Q] </span><a class="URL" href="http://flickrvision.com/">http://flickrvision.com/</a></span></span>. FlickrVision allows users to visualize where in the world recent photos have been taken by combining the geolocation information embedded in the photos and the mapping system of GoogleMaps. This is just one example of an API mashup, and there are countless other examples.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-15.1">15.1</a> Some Background on REST
</h2>
<div class="Unindented">
Before we dive into the details of building a RESTful API with Lift, let’s start by discussing a little about REST and the protocol that it sits atop: HTTP. If you’re already familiar with REST and HTTP, feel free to skip to the implementation in Section <a class="Reference" href="#sec:A-Simple-API-pocketchange">15.2↓</a>.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-15.1.1">15.1.1</a> A Little Bit about HTTP
</h3>
<div class="Unindented">
As we build our web service, it will to be helpful to know a few things about HTTP<span class="FootOuter"><span class="SupFootMarker"> [R] </span><span class="HoverFoot"><span class="SupFootMarker"> [R] </span>Hypertext Transfer Protocol</span></span> requests and responses. If you’re comfortable with the Request-Response cycle then feel free to jump to Section <a class="Reference" href="#sec:What-is-REST?">15.1.2↓</a> to get down to business.
</div>
<div class="Indented">
A simplification of how the web works is that clients, typically web browsers, send HTTP Requests to servers, which respond with HTTP Responses. Let’s take a look at an exchange between a client and a server.
</div>
<div class="Indented">
We’re going to send a GET request to the URI <a class="FlexURL" href="http://demo.liftweb.net/">http://demo.liftweb.net/</a> using the <tt>cURL</tt> utility. We’ll enable dumping the HTTP protocol header information so that you can see all of the information associated with the request and response. The cURL utility sends the output shown in Listing <a class="Reference" href="#lst:cURL-Output">15.1.1↓</a>:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
cURL Request<a class="Label" name="lst:cURL-Output"> </a>
</div>
<pre class="listing brush: scala">$ curl -v http://demo.liftweb.net/ 
* About to connect() to demo.liftweb.net port 80 (#0) 
*   Trying 64.27.11.183... connected 
* Connected to demo.liftweb.net (64.27.11.183) port 80 (#0) 
&gt; GET / HTTP/1.1 
&gt; User-Agent: curl/7.19.0 (i386-apple-darwin9.5.0) libcurl/7.19.0 zlib/1.2.3 
&gt; Host: demo.liftweb.net 
&gt; Accept: */*
</pre>
</div>

</div>
<div class="Indented">
And gets the corresponding response, shown in Listing <a class="Reference" href="#lst:cURL-Response">15.1.1↓</a>, from the server:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
cURL Response<a class="Label" name="lst:cURL-Response"> </a>
</div>
<pre class="listing brush: scala">&lt; HTTP/1.1 200 OK 
&lt; Server: nginx/0.6.32 
&lt; Date: Tue, 24 Mar 2009 20:52:55 GMT 
&lt; Content-Type: text/html 
&lt; Connection: keep-alive 
&lt; Expires: Mon, 26 Jul 1997 05:00:00 GMT 
&lt; Set-Cookie: JSESSIONID=5zrn24obipm5;Path=/ 
&lt; Content-Length: 8431 
&lt; Cache-Control: no-cache; private; no-store; 
  must-revalidate; max-stale=0; post-check=0; pre-check=0; max-age=0 
&lt; Pragma: no-cache 
&lt; X-Lift-Version: 0.11-SNAPSHOT 
&lt;  
&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns:lift="http://liftweb.net" xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;....
</pre>
</div>

</div>
<div class="Indented">
This seems pretty straightforward: we ask for a resource, and the server returns it to us. Take a look at the HTTP request. We’d like to point out the method called, in this case a <tt>“GET”, </tt>and the<tt> </tt>URI,<tt> </tt>which is “http://demo.liftweb.net/”. Method calls and addresses are what make the web work. You can think of the web as a series of method calls on varying resources, where the URI (Uniform Resource Identifier) identifies the resource upon which the method will be called.
</div>
<div class="Indented">
Methods are defined as part of the HTTP standard, and we’ll use them in our API. In addition to <tt>GET</tt>, the other HTTP methods are <tt>POST</tt>, <tt>DELETE</tt>, <tt>PUT</tt>, <tt>HEAD</tt>, and<tt> OPTIONS</tt>. You may also see methods referred to as actions or verbs. In this chapter, we will focus on using <tt>GET</tt> and <tt>PUT</tt> for our API. 
</div>
<div class="Indented">
As do Requests, Responses come with a few important pieces of information. Of note are the Response Code and the Entity Body. In the above example, the Response Code is “<tt>200 OK</tt>” and the Entity Body is the HTML content of the webpage, which is shown as the last two lines starting with “<tt>&lt;!DOCTYPE</tt>.” We’ve truncated the HTML content here to save space.
</div>
<div class="Indented">
This was a quick overview of HTTP, but if you’d like to learn more, take a look at the protocol definition found at<span class="FootOuter"><span class="SupFootMarker"> [S] </span><span class="HoverFoot"><span class="SupFootMarker"> [S] </span>http://www.ietf.org/rfc/rfc2616.txt</span></span>. We wanted to point out a few of the interesting parts of the cycle before we got into building a REST API.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-15.1.2">15.1.2</a> Defining REST<a class="Label" name="sec:What-is-REST?"> </a>
</h3>
<div class="Unindented">
Roy Fielding defined REST in his dissertation<span class="FootOuter"><span class="SupFootMarker"> [T] </span><span class="HoverFoot"><span class="SupFootMarker"> [T] </span><a class="FlexURL" href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a></span></span> and defined the main tenet of the architecture to be a uniform interface to resources. “Resources” refers to pieces of information that are named and have representations. Examples include an image, a Twitter status, or a timely item such as a stock quote or the current temperature. The uniform interface is supported by a set of constraints that include the following: 
</div>
<ul>
<li>
Statelessness of communication: This is built on top of HTTP, which is also stateless. 
</li>
<li>
Client-server–style interaction: Again, just as the Web consists of browsers talking to servers, REST discusses machines or applications talking to servers in the same way. 
</li>
<li>
Support for caching: REST uses the caching headers of HTTP to support the caching of resources. 
</li>

</ul>
<div class="Unindented">
These features are shared by both the web and by RESTful services. REST adds additional constraints regarding interacting with resources:
</div>
<ul>
<li>
Naming: As we mentioned, a resource must be identified, and this is done using URLs. 
</li>
<li>
Descriptive actions: Using the HTTP actions, GET, PUT, and DELETE makes it obvious what action is being performed on the resource. 
</li>
<li>
URL addressability: URLs should allow for the addressing of representation of a resource. 
</li>

</ul>
<div class="Unindented">
Fielding’s goal was to define a method that allowed machine-to-machine communication to mimic that of browser-to-server communication and to take advantage of HTTP as the underlying protocol.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-15.1.3">15.1.3</a> Comparing XML-RPC to REST Architectures
</h3>
<div class="Unindented">
What, then, is the difference between a RESTful architecture and a traditional RPC<span class="FootOuter"><span class="SupFootMarker"> [U] </span><span class="HoverFoot"><span class="SupFootMarker"> [U] </span>Remote Procedure Call</span></span> architecture? 
</div>
<div class="Indented">
An RPC application follows a more traditional software development pattern. It ignores most of the features offered by HTTP, such as the HTTP methods. Instead, the scoping and data to be used by the call are contained in the body of a POST request. XML-RPC works similarly to the web for <i>getting</i> resources, but breaks from the HTTP model for everything else by overloading the POST request. You will often see the term SOAP when referring to an XML-RPC setup, because SOAP permits the developer to define the action and the resource in the body of the request and ignore the HTTP methods.
</div>
<div class="Indented">
RESTful architectures embrace HTTP. We’re using the web; we may as well take advantage of it.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-15.2">15.2</a> A Simple API for PocketChange<a class="Label" name="sec:A-Simple-API-pocketchange"> </a>
</h2>
<div class="Unindented">
We’re going to start with a simple example, so we’ll only touch on some of the more complex steps of building a web service, such as authentication<a class="IndexReference" name="entry-HTTP-authentication-1" href="#index-HTTP-authentication">↓</a><a class="IndexReference" name="entry-Authentication-1" href="#index-Authentication">↓</a> and authorization. If you would like to see the code involved in performing authentication and authorization for our REST API, see Section <a class="Reference" href="#sub:HTTP-Authentication">9.9↑</a>. For the purposes of this example, we’re going to model two calls to the server: a GET request that responds with the details of an expense, and a PUT to add a new expense.The URLs will be:
</div>
<ul>
<li>
A GET request sent to URI: <pre class="LyX-Code">
http://www.pocketchangeapp.com/api/expense/&lt;expense id&gt;
</pre>

</li>
<li>
A PUT request containing a new expense sent to URI:<pre class="LyX-Code">
http://www.pocketchangeapp.com/api/account/&lt;account id&gt;
</pre>

</li>

</ul>
<div class="Unindented">
<div class="center">
<div class="Shadowbox" style="width: 75%;">
Note that a URL (Uniform Resource Locator) is a type of URI in which the URI also serves to locate the resource on the web. A URN (Uniform Resource Name) is another type of URI that provides a unique name to a resource without specifying an actual location, though it may look a lot like a URL. For more information on the distinctions among URIs, see <a class="FlexURL" href="http://en.wikipedia.org/wiki/Uniform_Resource_Name">http://en.wikipedia.org/wiki/Uniform_Resource_Name</a>.
</div>

</div>

</div>
<div class="Indented">
We would like the REST API to support both XML and JSON for this data. Additionally, we would like to support an Atom feed on an account so that people can track expenses as they’re added. The URL for the Atom feed will be a GET of the form:
</div>
<pre class="LyX-Code">
http://www.pocketchangeapp.com/api/account/&lt;account id&gt;
</pre>
<div class="Unindented">
In the next few sections we’ll show how you can easily add support for these methods and formats using Lift.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-15.3">15.3</a> Adding REST Helper Methods to our Entities
</h2>
<div class="Unindented">
In order to simplify our REST handler code, we would like to add some helper methods for our <tt>Expense</tt> entity to support generation of both XML and JSON for our consumers. We’ll add these to a new <tt>RestFormatters</tt> object inside the <tt>src/main/scala/com/pocketchangeapp/RestFormatters.scala</tt> source file. First, we add some common functionality in Listing <a class="Reference" href="#lst:Common-Expense-REST-helpers">15.3↓</a> by adding several helper methods for computing REST header values.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Common Expense REST Helpers<a class="Label" name="lst:Common-Expense-REST-helpers"> </a>
</div>
<pre class="listing brush: scala">  /* The REST timestamp format. Not threadsafe, so we create
   * a new one each time. */
  def timestamp = new SimpleDateFormat("yyyy-MM-dd’T’HH:mm:ss’Z’")
​
  // A simple helper to generate the REST ID of an Expense
  def restId (e : Expense) =
    "http://www.pocketchangeapp.com/api/expense/" + e.id
​
  // A simple helper to generate the REST timestamp of an Expense
  def restTimestamp (e : Expense) : String =
    timestamp.format(e.dateOf.is)
</pre>
</div>

</div>
<div class="Indented">
Listing <a class="Reference" href="#lst:Expense-Entity-JSON">15.3↓</a> shows a helper method for generating a proper JSON representation of a given <tt>Expense</tt> using the Lift JSON DSL. Although <tt>Expense</tt> is a <tt>Mapper</tt> entity, we don’t use the <tt>Expense.asJs<a class="IndexReference" name="entry-Mapper-asJs-0" href="#index-Mapper-asJs">↓</a></tt> method inherited from <tt>Mapper</tt> because we want to better control the format.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Expense Entity JSON Formatters<a class="Label" name="lst:Expense-Entity-JSON"> </a>
</div>
<pre class="listing brush: scala">/**
 * Generates the JSON REST representation of an Expense
 */
def toJSON (e : Expense) : JValue = {
  import net.liftweb.json.JsonDSL._
  import net.liftweb.json.JsonAST._
​
  ("expense" -&gt;
    ("id" -&gt; restId(e)) ~
    ("date" -&gt; restTimestamp(e)) ~
    ("description" -&gt; e.description.is) ~
    ("accountname" -&gt; e.accountName) ~
    ("accountid" -&gt; e.account.obj.open_!.id.is) ~
    ("amount" -&gt; e.amount.is.toString) ~
    ("tags" -&gt; e.tags.map(_.name.is).mkString(",")))
}
</pre>
</div>

</div>
<div class="Indented">
Finally, Listing <a class="Reference" href="#lst:Expense-Entity-REST-XML">15.3↓</a> shows the <tt>toXML</tt> method, which will generate properly formatted XML for a given <tt>Expense</tt>. Like <tt>toJSON</tt>, we don’t use the <tt>Expense.toXml</tt><a class="IndexReference" name="entry-Mapper-toXml-0" href="#index-Mapper-toXml">↓</a> method because we want more control over the generated format. Instead, we simply convert the result of <tt>toJSON</tt> into XML using the <tt>net.liftweb.json.Xml</tt> helper object.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Expense Entity XML REST Formatter<a class="Label" name="lst:Expense-Entity-REST-XML"> </a>
</div>
<pre class="listing brush: scala">import net.liftweb.json.Xml
/**
 * Generates the XML REST representation of an Expense
 */
def toXML (e : Expense) : Node = Xml.toXml(toJSON(e)).first
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-15.4">15.4</a> Multiple Approaches to REST Handling
</h2>
<div class="Unindented">
As Lift has evolved, two main approaches have emerged that allow you to perform RESTful operations. In Lift 1.0 and up, you can add custom dispatch (Section <a class="Reference" href="#sec:Custom-dispatch-func">3.8 on page 1↑</a>) on your API URLs to call custom handlers for your REST data. In Lift 2.0, the new <tt>net.liftweb.http.rest.RestHelper</tt> was introduced that vastly simplifies not only the dispatch for given operations, but also assists with conversion of requests and responses to both XML and JSON. Because custom dispatch is still very much a first-class feature of Lift we will cover both approaches here.
</div>
<div class="Indented">
Before we get into the details of each method, there are two last helpers we’d like to define. Listing <a class="Reference" href="#lst:Adding-an-Extractor-expense">15.4↓</a> shows an <tt>unapply</tt> method that we add to our <tt>Expense</tt> <tt>MetaMapper</tt> so that we can use <tt>Expense</tt> as an extractor in pattern matching. In this code we not only attempt to match by using a provided <tt>String</tt> as the <tt>Expense</tt>’s primary key, but we also compute whether the <tt>Expense</tt> is in a public account. This assists us in determining authorization for viewing a given <tt>Expense</tt>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Adding an Extractor for Expense<a class="Label" name="lst:Adding-an-Extractor-expense"> </a>
</div>
<pre class="listing brush: scala">import net.liftweb.util.ControlHelpers.tryo
/**
 * Define an extractor that can be used to locate an Expense based
 * on its ID. Returns a tuple of the Expense and whether the
 * Expense’s account is public.
 */
def unapply (id : String) : Option[(Expense,Boolean)] = tryo {
  find(By(Expense.id, id.toLong)).map { expense =&gt;
     (expense,
      expense.account.obj.open_!.is_public.is)
  }.toOption
} openOr None
</pre>
</div>

</div>
<div class="Indented">
Similarly, Listing <a class="Reference" href="#lst:Adding-an-Extractor-account">15.4↓</a> shows an extractor on the <tt>Account</tt> <tt>MetaMapper</tt> that matches an <tt>Account</tt> based on its primary key.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Adding an Extractor for Account<a class="Label" name="lst:Adding-an-Extractor-account"> </a>
</div>
<pre class="listing brush: scala">import net.liftweb.util.Helpers.tryo
/**
 * Define an extractor that can be used to locate an Account based
 * on its ID.
 */
def unapply (id : String) : Option[Account] = tryo {
  find(By(Account.id, id.toLong)).toOption
} openOr None
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-15.4.1">15.4.1</a> Using Custom Dispatch<a class="Label" name="sub:REST-Custom-Dispatch"> </a>
</h3>
<div class="Unindented">
Now that we’ve discussed our design, let’s see the code that will handle the routing. In the package <tt>com.pocketchangeapp.api</tt>, we have an object named <tt>DispatchRestAPI, which we’ve</tt> defined in <tt>src/main/scala/com/pocketchangeapp/api/RestAPI.scala</tt>. In <tt>DispatchRestAPI</tt>, we define a custom dispatch function to pattern match on the request and delegate to a handler method. The custom dispatch function is shown in Listing <a class="Reference" href="#lst:REST-Method-Routing">15.4.1↓</a>. You can see that we use our extractors in the matching for both <tt>Expense</tt>s and <tt>Account</tt>s. We’ll cover the processing of PUTs in Section <a class="Reference" href="#sec:Processing-Expense-PUTs">15.5↓</a>, and the Atom processing in Section <a class="Reference" href="#sec:Servicing-Atom">15.7↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
REST Method Routing<a class="Label" name="lst:REST-Method-Routing"> </a>
</div>
<pre class="listing brush: scala">// Import our methods for converting things around
import RestFormatters._
​
def dispatch: LiftRules.DispatchPF = {
  // Define our getters first
  case Req(List("api", "expense", Expense(expense,_)), _, GetRequest) =&gt;
     () =&gt; nodeSeqToResponse(toXML(expense)) // default to XML
  case Req(List("api", "expense", Expense(expense,_), "xml"), _, GetRequest) =&gt;
     () =&gt; nodeSeqToResponse(toXML(expense))
  case Req(List("api", "expense", Expense(expense,_), "json"), _, GetRequest) =&gt;
     () =&gt; JsonResponse(toJSON(expense))
  case Req(List("api", "account", Account(account)), _, GetRequest) =&gt;
     () =&gt; AtomResponse(toAtom(account))
​
  // Define the PUT handler for both XML and JSON MIME types
  case request @ Req(List("api", "account", Account(account)), _, PutRequest)
    if request.xml_? =&gt;
      () =&gt; addExpense(fromXML(request.xml,account),
                       account,
                       result =&gt; CreatedResponse(toXML(result), "text/xml"))
  case request @ Req(List("api", "account", Account(account)), _, PutRequest)
    if request.json_? =&gt;
      () =&gt; addExpense(fromJSON(request.body,account),
                       account,
                       result =&gt; JsonResponse(toJSONExp(result), Nil, Nil, 201))
​
  // Invalid API request - route to our error handler
  case Req("api" :: x :: Nil, "", _) =&gt;
    () =&gt; BadResponse() // Everything else fails
}
</pre>
</div>

</div>
<div class="Indented">
Our <tt>DispatchRestAPI</tt> object mixes in the <tt>net.liftweb.http.rest.XMLApiHelper</tt> trait, which includes several implicit conversions to simplify writing our REST API. Remember that <tt>LiftRules.DispatchPF</tt> must return a function <span class="formula">() ⇒ <i>Box</i>[<i>LiftResponse</i>]</span> (Section <a class="Reference" href="#sec:Custom-dispatch-func">3.8 on page 1↑</a>), so we’re using the implicit <tt>putResponseInBox</tt> as well as explicitly calling <tt>nodeSeqToResponse</tt> to convert our API return values into the proper format.
</div>
<div class="Indented">
The server will now service <tt>GET</tt> requests with the appropriate formatter function and will handle <tt>PUT</tt> requests with the <tt>addExpense</tt> method (which we’ll define later in this chapter). 
</div>
<div class="Indented">
We hook our new dispatch function into LiftRules by adding the code shown in Listing <a class="Reference" href="#lst:Setting-up-REST">15.4.1↓</a> to our <tt>Boot.boot</tt> method.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Setting up REST Dispatch<a class="Label" name="lst:Setting-up-REST"> </a>
</div>
<pre class="listing brush: scala">LiftRules.dispatch.prepend(DispatchRestAPI.dispatch)
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-15.4.2">15.4.2</a> Using the RestHelper Trait
</h3>
<div class="Unindented">
New in Lift 2.0 is the <tt>net.liftweb.http.rest.RestHelper</tt> trait. This trait simplifies the creation of REST APIs that support both XML and JSON. For our example, we’ll define the <tt>RestHelperAPI</tt> object in our <tt>RestAPI.scala</tt> source file.
</div>
<div class="Indented">
Before we get into the details of actual processing with <tt>RestHelper</tt>, we want to point out some useful parts of its API. First, <tt>RestHelper</tt> provides a number of built-in extractors for matching not only what HTTP verb a given request uses, but also the format of the request (JSON or XML). These extractors are:
</div>
<ul>
<li>
<tt>Get</tt>, <tt>JsonGet</tt>, <tt>XmlGet</tt> - matches a raw GET, or a GET of the specified format
</li>
<li>
<tt>Post</tt>, <tt>JsonPost</tt>, <tt>XmlPost</tt> - matches a raw POST, or a POST of the specified format
</li>
<li>
<tt>Put</tt>, <tt>JsonPut</tt>, <tt>XmlPut</tt> - matches a raw PUT, or a PUT of the specified format
</li>
<li>
<tt>Delete</tt> - matches a DELETE request
</li>
<li>
<tt>JsonReq</tt> - matches a request with the Accept header containing “application/json”, or whose Accept header contains “*/*” and whose path suffix is “json”
</li>
<li>
<tt>XmlReq</tt> - matches a request with the Accept header containing “text/xml”, or whose Accept header contains “*/*” and whose path suffix is “xml”
</li>

</ul>
<div class="Unindented">
We’ll demonstrate in the following sections how to use these extractors. Note that you can add additional rules for the <tt>JsonReq</tt> and <tt>XmlReq</tt> extractors by overriding the <tt><br/>
RestHelper.suplimentalJsonResponse_?</tt> and <tt>suplimentalXmlResponse_?</tt> (yes, those are spelled incorrectly) methods to perform additional tests on the request. For example, Listing <a class="Reference" href="#lst:Using-a-Cookie-request-type">15.4.2↓</a> shows how we can use the existence of a given header to determine whether a request is XML or JSON. 
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using a Cookie to Determine the Request Type<a class="Label" name="lst:Using-a-Cookie-request-type"> </a>
</div>
<pre class="listing brush: scala">override def suplimentalJsonResponse_? (in : Req) = 
  in.header("This-Is-A-JSON-Request").isDefined
override def suplimentalXmlResponse_? (in : Req) = 
  in.header("This-Is-A-XML-Request").isDefined
</pre>
</div>

</div>
<div class="Indented">
<div class="center">
<div class="Shadowbox" style="width: 75%;">
One important difference between <tt>RestHelper</tt> and our <tt>DispatchRestAPI</tt> examples that we want to point out is that <tt>RestHelper</tt> determines whether a request is XML or JSON based on the Accept header and/or the suffix of the path (e.g. <tt>/api/expense/1.xml</tt>), whereas our DispatchRestAPI used the last component of the path (<tt>/api/expense/1/xml</tt>). Either approach is valid, just be aware if you’re copying this example code.
</div>

</div>

</div>
<div class="Indented">
Next, like the <tt>XMLApiHelper</tt> trait, <tt>RestHelper</tt> provides a number of implicit conversions to <tt>LiftResponse</tt> from a variety of inputs. We’re not going to cover these directly here, but we’ll point out where we use them in this section.
</div>
<div class="Indented">
Similar to our <tt>DispatchRestAPI</tt> handler, we need to define a set of patterns that we can match against. Unlike <tt>DispatchRestAPI</tt>, however, <tt>RestHelper</tt> defines four <tt>PartialFunction</tt> methods where we can add our patterns: <tt>serve</tt>, <tt>serveJx</tt>, <tt>serveJxa</tt> and <tt>serveType</tt>. These functions provide increasing automation (and control) over what gets served when the request matches a pattern. We won’t be covering <tt>serveType</tt> here, since it’s essentially the generalized version that <tt>serve</tt>, <tt>serveJx</tt> and <tt>serveJxa</tt> use behind the scenes.
</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-15.4.2.1">15.4.2.1</a> The serve Method
</h4>
<div class="Unindented">
Let’s start with the <tt>serve</tt> method. This method essentially corresponds one-to-one with our <tt>DispatchRestAPI.dispatch</tt> method. Listing <a class="Reference" href="#lst:Using-RestHelper.serve">15.4.2.1↓</a> shows how we could handle Atom requests, as well as requests that don’t specify a format, using <tt>RestHelper</tt>. Note our use of the <tt>RestHelper</tt> extractors to match the HTTP Verb being used. Also note that we’re using an implicit conversion from a Box[T] to a Box[LiftResponse] when an implicit function is in scope that can convert T into a LiftResponse. In our example, <tt>Full(toXML(expense))</tt> is equivalent to <tt>boxToResp(Full(toXML(expense)))(nodeToResp)</tt>. Finally, the serve method can be invoked multiple times and the <tt>PartialFunctions</tt> will be chained together.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using RestHelper.serve<a class="Label" name="lst:Using-RestHelper.serve"> </a>
</div>
<pre class="listing brush: scala">// Service Atom and requests that don’t request a specific format
serve {
  // Default to XML
  case Get(List("api", "expense", Expense(expense,_)), _) =&gt;
    () =&gt; Full(toXML(expense))
  case Get(List("api", "account", Account(account)), _) =&gt;
    () =&gt; Full(AtomResponse(toAtom(account)))
}
</pre>
</div>

</div>
<div class="Indented">
We use similar calls to hook our PUT handlers, shown in Listing <a class="Reference" href="#lst:Using-serve-to-handle-PUT">15.4.2.1↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using serve to handle PUTs<a class="Label" name="lst:Using-serve-to-handle-PUT"> </a>
</div>
<pre class="listing brush: scala">// Hook our PUT handlers
import DispatchRestAPI.addExpense
serve {
  case XmlPut(List("api", "account", Account(account)), (body, request)) =&gt;
    () =&gt; Full(addExpense(fromXML(Full(body),account),
                          account,
                          result =&gt; CreatedResponse(toXML(result), "text/xml")))
  case JsonPut(List("api", "account", Account(account)), (_, request))  =&gt;
    () =&gt; Full(addExpense(fromJSON(request.body,account),
                          account,
                          result =&gt; JsonResponse(toJSON(result), Nil, Nil, 201)))
}
</pre>
</div>

</div>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-15.4.2.2">15.4.2.2</a> The serveJx Method
</h4>
<div class="Unindented">
Like the serve method, <tt>serveJx</tt> performs pattern matching on the request. However, <tt>serveJx</tt> allows you to specify a conversion function that matches against the requested format<br/>
(<tt>net.liftweb.http.rest.JsonSelect</tt> or <tt>net.liftweb.http.rest.XmlSelect</tt>) and perform your conversion there. Then, all you need to do is match once against a given path and <tt>serveJx</tt> will utilize your conversion function to return the proper result. Listing <a class="Reference" href="#lst:Using-RestHelper.serveJx">15.4.2.2↓</a> shows how we can use a new implicit conversion to handle our format-specific GETs. The single match in our <tt>serveJx</tt> call replaces two lines in our <tt>DispatchRestAPI.dispatch</tt> method.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using RestHelper.serveJx<a class="Label" name="lst:Using-RestHelper.serveJx"> </a>
</div>
<pre class="listing brush: scala">// Define an implicit conversion from an Expense to XML or JSON
import net.liftweb.http.rest.{JsonSelect,XmlSelect}
implicit def expenseToRestResponse : JxCvtPF[Expense] = {
  case (JsonSelect, e, _) =&gt; toJSON(e)
  case (XmlSelect, e, _) =&gt; toXML(e)
}
​
serveJx {
  case Get(List("api", "expense", Expense(expense,_)), _) =&gt; Full(expense)
}
</pre>
</div>

</div>
<div class="Indented">
In addition to providing your own conversion function, <tt>serveJx</tt> can utilize the <tt>RestHelper</tt> autoconversion functionality. To use this, simply use the <tt>auto</tt> method to wrap whatever you want to return. Listing <a class="Reference" href="#lst:Using-auto-to-convert-returns">15.4.2.2↓</a> shows an example of returning a contrived data object with <tt>auto</tt>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using auto to Convert Return Values<a class="Label" name="lst:Using-auto-to-convert-returns"> </a>
</div>
<pre class="listing brush: scala">// Just an example of autoconversion
serveJx {
  case Get(List("api", "greet", name),_) =&gt;
     auto(Map("greeting" -&gt;
              Map("who" -&gt; name,
                  "what" -&gt; ("Hello at " + new java.util.Date))))
}
</pre>
</div>

</div>
<div class="Indented">
The conversion is actually performed with the <tt>net.liftweb.json.Extraction</tt> object<a class="IndexReference" name="entry-Extraction-0" href="#index-Extraction">↓</a><a class="IndexReference" name="entry-JSON-extraction-0" href="#index-JSON-extraction">↓</a><a class="IndexReference" name="entry-Autoconversion-0" href="#index-Autoconversion">↓</a>, so you can autoconvert anything that <tt>Extraction</tt> can handle. This includes:
</div>
<ul>
<li>
Primitives
</li>
<li>
Maps
</li>
<li>
Arrays
</li>
<li>
Collections
</li>
<li>
Options
</li>
<li>
Case classes
</li>

</ul>
<h4 class="Subsubsection">
<a class="toc" name="toc-Subsubsection-15.4.2.3">15.4.2.3</a> The serveJxa Method
</h4>
<div class="Unindented">
The <tt>serveJxa</tt> method is basically the same as the <tt>serve</tt> and <tt>serveJx</tt> methods, except that anything that is returned will be automatically converted to JSON via the<br/>
<tt>net.liftweb.json.Extraction.decompose</tt> method.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-15.5">15.5</a> Processing Expense PUTs<a class="Label" name="sec:Processing-Expense-PUTs"> </a>
</h2>
<div class="Unindented">
Now that we’re handling the API calls, we’ll need to write the code to process and respond to requests. The first thing we need to do is deserialize the <tt>Expense</tt> from the either an XML or JSON request.
</div>
<div class="Indented">
In PocketChange our use of <tt>BigDecimal</tt> values to represent currency amounts means that we can’t simply use the lift-json deserialization support (Section <a class="Reference" href="#sec:JSON">C.10 on page 1↓</a>). While lift-json is very good and would make this much simpler, it parses decimal values as doubles which can lead to rounding and precision issues when working with decimal values. Instead, we will need to write our own conversion functions. 
</div>
<div class="Indented">
To simplify error handling, we break this processing up into two format-specific methods that convert to a <tt>Map</tt> representation of the data, and another method that converts the intermediate <tt>Map</tt>/<tt>List</tt> into an <tt>Expense</tt>. Listing <a class="Reference" href="#lst:Deserializing-XML-to-Expense">15.5↓</a> shows the <tt>fromXML</tt> method in the <tt>RestFormatters</tt> object. This method performs some basic validation to make sure we have the required parameters, but otherwise doesn’t validate the values of those parameters. Note that we provide the <tt>Account</tt> to <tt>fromXML</tt> so that we can resolve tag names in the <tt>fromMap</tt> method (which we’ll cover momentarily).
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Deserializing XML to an Expense<a class="Label" name="lst:Deserializing-XML-to-Expense"> </a>
</div>
<pre class="listing brush: scala">def fromXML (rootNode : Box[Elem], account : Account) : Box[Expense] = 
 rootNode match {
  case Full(&lt;expense&gt;{parameters @ _*}&lt;/expense&gt;) =&gt; {
    var data = Map[String,String]()
​
    for(parameter &lt;- parameters) {
      parameter match {
        case &lt;date&gt;{date}&lt;/date&gt; =&gt; data += "date" -&gt; date.text
        case &lt;description&gt;{description}&lt;/description&gt; =&gt;
          data += "description" -&gt; description.text
        case &lt;amount&gt;{amount}&lt;/amount&gt; =&gt; data += "amount" -&gt; amount.text
        case &lt;tags&gt;{ tags }&lt;/tags&gt; =&gt; data += "tags" -&gt; tags.text
        case _ =&gt; // Ignore (could be whitespace)
      }
    }
​
    fromMap(data, account)
  }
  case other =&gt; Failure("Missing root expense element")
}
</pre>
</div>

</div>
<div class="Indented">
Similarly, Listing <a class="Reference" href="#lst:Deserializing-JSON-to-Expense">15.5↓</a> shows our <tt>fromJSON</tt> method.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Deserializing JSON to an Expense<a class="Label" name="lst:Deserializing-JSON-to-Expense"> </a>
</div>
<pre class="listing brush: scala">def fromJSON (obj : Box[Array[Byte]], account : Account) : Box[Expense] =
 obj match {
  case Full(rawBytes) =&gt; {
    // We use the Scala util JSON parser here because we want to avoid parsing
    // numeric values into doubles. We’ll just leave them as Strings
    import scala.util.parsing.json.JSON
    JSON.perThreadNumberParser = { in : String =&gt; in }
​
    val contents = new String(rawBytes, "UTF-8")
    JSON.parseFull(contents) match {
      case Some(data : Map[String,Any]) =&gt; {
        fromMap(data.mapElements(_.toString), account)
      }
      case other =&gt; Failure("Invalid JSON submitted: \"%s\"".format(contents))
    }
  }
  case _ =&gt; Failure("Empty body submitted")
}
</pre>
</div>

</div>
<div class="Indented">
Finally, Listing <a class="Reference" href="#lst:Converting-the-Intermediate-Expense">15.5↓</a> shows our <tt>fromMap</tt> method, which takes the data parsed by <tt>fromJSON</tt> and <tt>fromXML</tt> and converts it into an actual expense.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Converting the Intermediate Data to an Expense<a class="Label" name="lst:Converting-the-Intermediate-Expense"> </a>
</div>
<pre class="listing brush: scala">def fromMap (data : scala.collection.Map[String,String],
             account : Account) : Box[Expense] = {
  val expense = Expense.create
​
  try {
    val fieldParsers : List[(String, String =&gt; Expense)] =
      ("date", (date : String) =&gt; expense.dateOf(timestamp.parse(date))) ::
      ("description", (desc : String) =&gt; expense.description(desc)) ::
      ("amount", (amount : String) =&gt; expense.amount(BigDecimal(amount))) :: Nil
​
    val missing = fieldParsers.flatMap {
      field =&gt; // We invert the flatMap here to only give us missing values
        if (data.get(field._1).map(field._2).isDefined) None else Some(field._1)
    }
 
    if (missing.isEmpty) {
      expense.account(account)
      data.get("tags").foreach {
        tags =&gt; expense.tags(tags.split(",").map(Tag.byName(account.id.is,_)).toList)
      }
      Full(expense)
    } else {
      Failure(missing.mkString("Invalid expense. Missing: ", ",", ""))
    }
  } catch {
    case pe : java.text.ParseException =&gt; Failure("Failed to parse date")
    case nfe : java.lang.NumberFormatException =&gt;
      Failure("Failed to parse amount")
  }
}
</pre>
</div>

</div>
<div class="Indented">
Now that we’ve converted the PUT data into an <tt>Expense</tt>, we need to actually perform our logic and persist the submitted <tt>Expense</tt>. Listing <a class="Reference" href="#lst:Saving-the-submitted-Expense">15.5↓</a> shows our <tt>addExpense</tt> method, which matches against the parsed <tt>Expense</tt> and either runs validation if the parse succeeded, or returns an error response to the user if something failed. If validation fails, the user is similarly notified. The <tt>success</tt> parameter is a function that can be used to generate the appropriate response based on the newly created Expense. This allows us to return the new Expense in the same format (JSON, XML) in which it was submitted (see the dispatch function, Listing <a class="Reference" href="#lst:REST-Method-Routing">15.4.1↑</a>).
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Saving the submitted Expense<a class="Label" name="lst:Saving-the-submitted-Expense"> </a>
</div>
<pre class="listing brush: scala">def addExpense(parsedExpense : Box[Expense],
               account : Account,
               success : Expense =&gt; LiftResponse): LiftResponse = 
 parsedExpense match {
  case Full(expense) =&gt; {
    val (entrySerial,entryBalance) =
      Expense.getLastExpenseData(account, expense.dateOf)
​
    expense.account(account).serialNumber(entrySerial + 1).
    currentBalance(entryBalance + expense.amount)
    expense.validate match {
      case Nil =&gt; {
        Expense.updateEntries(entrySerial + 1, expense.amount.is)
        expense.save
        account.balance(account.balance.is + expense.amount.is).save
​
        success(expense)
      }
      case errors =&gt; {
        val message = errors.mkString("Validation failed:", ",","")
        logger.error(message)
        ResponseWithReason(BadResponse(), message)
      }
    }
  }
  case Failure(msg, _, _) =&gt; {
    logger.error(msg)
    ResponseWithReason(BadResponse(), msg)
  }
  case error =&gt; {
    logger.error("Parsed expense as : " + error)
    BadResponse()
  }
}
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-15.6">15.6</a> The Request and Response Cycles for Our API
</h2>
<div class="Unindented">
At the beginning of this chapter, we showed you a request and response conversation for <tt><br/>
http://demo.liftweb.net/</tt>. Let’s see what that looks like for a request to our API. Listing <a class="Reference" href="#lst:Request-and-Response-GET">15.6↓</a> shows an XML GET request for a given expense. Note that we’re not showing the HTTP Basic authentication setup, required by our authentication configuration (Section <a class="Reference" href="#sub:HTTP-Authentication">9.9 on page 1↑</a>).
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Request and Response for XML GET<a class="Label" name="lst:Request-and-Response-GET"> </a>
</div>
<pre class="listing brush: scala">Request:
http://www.pocketchangeapp.com/api/expense/3 GET
​
Response:
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;expense&gt;
  &lt;id&gt;http://www.pocketchangeapp.com/api/expense/3&lt;/id&gt;
  &lt;accountname&gt;Test&lt;/accountname&gt;
  &lt;accountid&gt;1&lt;/accountid&gt;
  &lt;date&gt;2010-10-06T00:00:00Z&lt;/date&gt;
  &lt;description&gt;Receipt test&lt;/description&gt;
  &lt;amount&gt;12.00&lt;/amount&gt;
  &lt;tags&gt;test,receipt&lt;/tags&gt;
&lt;/expense&gt;
</pre>
</div>

</div>
<div class="Indented">
Listing <a class="Reference" href="#lst:Request-and-Response-GET-JSON">15.6↓</a> shows the same request in JSON format.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Request and Response for JSON GET<a class="Label" name="lst:Request-and-Response-GET-JSON"> </a>
</div>
<pre class="listing brush: scala">Request:
http://www.pocketchangeapp.com/api/expense/3/json GET
​
Response:
{"id":"http://www.pocketchangeapp.com/api/expense/3",
 "date":"2010-10-06T00:00:00Z",
 "description":"Receipt test",
 "accountname":"Test",
 "accountid":1,
 "amount":"12.00",
 "tags":"test,receipt"}
</pre>
</div>

</div>
<div class="Indented">
Listing <a class="Reference" href="#lst:Request-and-Response-PUT">15.6↓</a> shows the output for a PUT conversation:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Request and Response for an XML PUT<a class="Label" name="lst:Request-and-Response-PUT"> </a>
</div>
<pre class="listing brush: scala">Request:
http://www.pocketchangeapp.com/api/account/1 - PUT - addEntry(request) + XML Body
​
Request Body:
&lt;expense&gt;
  &lt;date&gt;2010-07-05T14:22:00Z&lt;/date&gt;
  &lt;description&gt;Test&lt;/description&gt;
  &lt;amount&gt;12.41&lt;/amount&gt;
  &lt;tags&gt;test,api&lt;/tags&gt;
&lt;/expense&gt;
​
Response:
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;expense&gt;
  &lt;id&gt;http://www.pocketchangeapp.com/api/expense/10&lt;/id&gt;
  &lt;accountname&gt;Test&lt;/accountname&gt;
  &lt;accountid&gt;1&lt;/accountid&gt;
  &lt;date&gt;2010-07-05T14:22:00Z&lt;/date&gt;
  &lt;description&gt;Test&lt;/description&gt;
  &lt;amount&gt;12.41&lt;/amount&gt;
  &lt;tags&gt;api,test&lt;/tags&gt;
&lt;/expense&gt;   
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-15.7">15.7</a> Extending the API to Return Atom Feeds<a class="Label" name="sec:Servicing-Atom"> </a>
</h2>
<div class="Unindented">
In addition to being able to fetch specific expenses using our API, it would be nice to be able to provide a feed of expenses for an account as they’re added. For this example, we’ll add support for Atom<span class="FootOuter"><span class="SupFootMarker"> [V] </span><span class="HoverFoot"><span class="SupFootMarker"> [V] </span><a class="FlexURL" href="http://tools.ietf.org/html/rfc4287">http://tools.ietf.org/html/rfc4287</a></span></span>, a simple publishing standard for content syndication. The first thing we need to do is write a method to generate an Atom feed for a given Account. Although Atom is XML-based, it’s sufficiently different enough from our REST API XML format that we’ll just write new methods for it. Listing <a class="Reference" href="#lst:The-toAtom-Method">15.7↓</a> shows the <tt>toAtom</tt> methods (one for <tt>Account</tt>, one for <tt>Expense</tt>) in our <tt>RestFormatters</tt> object that will handle the formatting. 
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
The toAtom Methods<a class="Label" name="lst:The-toAtom-Method"> </a>
</div>
<pre class="listing brush: scala">def toAtom (a : Account) : Elem = {
  val entries = Expense.getByAcct(a,Empty,Empty,Empty,MaxRows(10))
​
  &lt;feed xmlns="http://www.w3.org/2005/Atom"&gt;
    &lt;title&gt;{a.name}&lt;/title&gt;
    &lt;id&gt;urn:uuid:{a.id.is}&lt;/id&gt;
    &lt;updated&gt;{entries.headOption.map(restTimestamp) getOrElse
              timestamp.format(new java.util.Date)}&lt;/updated&gt;
    { entries.flatMap(toAtom) }
  &lt;/feed&gt;
}
​
def toAtom (e : Expense) : Elem =
  &lt;entry&gt;
    &lt;id&gt;urn:uuid:{restId(e)}&lt;/id&gt;
    &lt;title&gt;{e.description.is}&lt;/title&gt;
    &lt;updated&gt;{restTimestamp(e)}&lt;/updated&gt;
    &lt;content type="xhtml"&gt;
      &lt;div xmlns="http://www.w3.org/1999/xhtml"&gt;
        &lt;table&gt;
          &lt;tr&gt;&lt;th&gt;Amount&lt;/th&gt;&lt;th&gt;Tags&lt;/th&gt;&lt;th&gt;Receipt&lt;/th&gt;&lt;/tr&gt;
          &lt;tr&gt;&lt;td&gt;{e.amount.is.toString}&lt;/td&gt;
              &lt;td&gt;{e.tags.map(_.name.is).mkString(", ")}&lt;/td&gt;
              &lt;td&gt;{
                 if (e.receipt.is ne null) {
                   &lt;img src={"/image/" + e.id} /&gt;
                 } else Text("None")
               }&lt;/td&gt;&lt;/tr&gt;
        &lt;/table&gt;
      &lt;/div&gt;
    &lt;/content&gt;
  &lt;/entry&gt;
</pre>
</div>

</div>
<div class="Indented">
Now that we have the format, we simply hook into our dispatch method to match a GET request on a URL like:
</div>
<pre class="LyX-Code">
http://www.pocketchangeapp.com/api/account/&lt;accound ID&gt;
</pre>
<div class="Unindented">
Refer to Listing <a class="Reference" href="#lst:REST-Method-Routing">15.4.1↑</a> again to see this match.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-15.7.1">15.7.1</a> An Example Atom Request
</h3>
<div class="Unindented">
An example Atom reqeust/response cycle for a test account is shown in Listing <a class="Reference" href="#lst:An-Example-Atom-req-resp">15.7.1↓</a>. We’ve cut off the entries here for brevity.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
An Example Atom Request and Response<a class="Label" name="lst:An-Example-Atom-req-resp"> </a>
</div>
<pre class="listing brush: scala">Request:
http://www.pocketchangeapp.com/api/account/1
​
Response:
&lt;feed xmlns="http://www.w3.org/2005/Atom"&gt;
  &lt;title&gt;Test&lt;/title&gt;
  &lt;id&gt;urn:uuid:1&lt;/id&gt;
  &lt;updated&gt;2010-10-06T00:00:00Z&lt;/updated&gt;
  &lt;entry&gt;
      &lt;id&gt;urn:uuid:http://www.pocketchangeapp.com/api/expense/3&lt;/id&gt;
      &lt;title&gt;Receipt test&lt;/title&gt;
      &lt;updated&gt;2010-10-06T00:00:00Z&lt;/updated&gt;
      &lt;content type="xhtml"&gt;
        &lt;div xmlns="http://www.w3.org/1999/xhtml"&gt;
          &lt;table&gt;
          &lt;tr&gt;&lt;th&gt;Amount&lt;/th&gt;&lt;th&gt;Tags&lt;/th&gt;&lt;th&gt;Receipt&lt;/th&gt;&lt;/tr&gt;
          &lt;tr&gt;&lt;td&gt;12.00&lt;/td&gt;
              &lt;td&gt;test, receipt&lt;/td&gt;
              &lt;td&gt;&lt;img src="/image/3" /&gt;&lt;/td&gt;&lt;/tr&gt;
          &lt;/table&gt;
        &lt;/div&gt;
      &lt;/content&gt;
    &lt;/entry&gt;
    ...
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-15.7.2">15.7.2</a> Add a feed tag for the account page
</h3>
<div class="Unindented">
As an extra nicety, we want to add an appropriate Atom <tt>&lt;link/&gt;</tt> tag to our Account view page so that people can easily subscribe to the feed from their browser. We do this by making two modifications to our template and snippet code. Listing <a class="Reference" href="#lst:Adding-a-link-viewAcct">15.7.2↓</a> shows how we insert a new binding point in our <tt>viewAcct.html</tt> template to place the new link in the page head section.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Adding a binding to viewAcct.html<a class="Label" name="lst:Adding-a-link-viewAcct"> </a>
</div>
<pre class="listing brush: xml">...
&lt;lift:Accounts.detail eager_eval="true"&gt;
  &lt;head&gt;&lt;acct:atomLink /&gt;&lt;/head&gt;
...
</pre>
</div>

</div>
<div class="Indented">
Listing <a class="Reference" href="#lst:Binding-the-Atom-link">15.7.2↓</a> shows how we generate a new Atom link based on the current <tt>Account</tt>’s id that points to the proper URL for our API.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Binding the Atom link<a class="Label" name="lst:Binding-the-Atom-link"> </a>
</div>
<pre class="listing brush: scala">bind("acct", xhtml,
     "atomLink" -&gt; &lt;link href={"/api/account/" + acct.id} 
                      type="application/atom+xml" 
                      rel="alternate" title={acct.name + " feed"} /&gt;,
     "name" -&gt; acct.name.asHtml,
     ...
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-15.8">15.8</a> Conclusion
</h2>
<div class="Unindented">
In this chapter, we outlined a RESTful API for a web application and showed how to implement one using Lift. We then extended that API to return Atom in addition to XML and JSON.
</div>
<h1 class="Part">
<a class="toc" name="toc-Part-III">Part III.</a> Appendices
</h1>
<div class="Unindented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Appendix-A">A</a> A Brief Tour of Maven<a class="IndexReference" name="entry-Maven-1" href="#index-Maven">↓</a><a class="Label" name="cha:Maven"> </a>
</h1>
<div class="Unindented">
In this chapter we’ll discuss the Maven build tool and some of the basics of configuration and usage. Maven is what Lift uses for build management, so becoming acquainted with Maven is important to getting the most out of Lift. If you’re already familiar with Maven you can safely skip this chapter. 
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-A.1">A.1</a> What is Maven?
</h2>
<div class="Unindented">
Maven is a project management tool, as opposed to simply a build tool. The Maven site<span class="FootOuter"><span class="SupFootMarker"> [W] </span><span class="HoverFoot"><span class="SupFootMarker"> [W] </span><a class="URL" href="http://maven.apache.org/">http://maven.apache.org/</a></span></span> describes the goals of Maven as:
</div>
<ul>
<li>
Make the build process easy
</li>
<li>
Provide a uniform build system
</li>
<li>
Provide quality project information
</li>
<li>
Provide guidelines for best practices
</li>
<li>
Allow transparent migration to new features
</li>

</ul>
<div class="Unindented">
As a project management tool, Maven goes beyond just controlling compilation of your code. By default, Maven comes equipped not only to perform development-centric tasks, but it can generate documentation from your code and for your project website. Everything in Maven is controlled via the pom.xml (Project Object Model) file, which contains both information and configuration details on the project. We’ll be covering some of the basic aspects of the POM through the rest of this chapter<span class="FootOuter"><span class="SupFootMarker"> [X] </span><span class="HoverFoot"><span class="SupFootMarker"> [X] </span>A complete POM reference is available at <a class="URL" href="http://maven.apache.org/pom.html">http://maven.apache.org/pom.html</a></span></span>.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-A.2">A.2</a> Lifecycles, Phases and Goals
</h2>
<div class="Unindented">
Maven is designed around the concept of project lifecycles. While you can define your own, there are three built-in lifecycles: <tt>default, clean</tt> and <tt>site.</tt> The <tt>default</tt> lifecycle builds and deploys your project. The <tt>clean</tt> lifecycle cleans (deletes) compiled objects or anything else that needs to be removed or reset to get the project to a pristine pre-build state. Finally, the <tt>site</tt> lifecycle generates the project documentation.
</div>
<div class="Indented">
Within each lifecycle there are a number of phases that define various points in the development process. The most interesting lifecycle (from the perspective of writing code) is <tt>default</tt>. The most commonly used phases in the default lifecycle are<span class="FootOuter"><span class="SupFootMarker"> [Y] </span><span class="HoverFoot"><span class="SupFootMarker"> [Y] </span>A full listing of lifecycles and their phases is at <a class="URL" href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html">http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a></span></span>:
</div>
<ul>
<li>
<tt>compile</tt> - compiles the main source code of the project 
</li>
<li>
<tt>test</tt> - tests the main code using a suitable unit testing framework. These tests should not require that the code is packaged or deployed. This phase implicitly calls the testCompile goal to compile the test case source code
</li>
<li>
<tt>package</tt> - packages the compiled code into its distributable format, such as a JAR. The POM controls how a project is packaged through the <tt>&lt;packaging/&gt;</tt> element
</li>
<li>
<tt>install</tt> - installs the package into the local repository (see section <a class="Reference" href="#sec:Repositories">A.3↓</a>), for use as a dependency in other projects locally 
</li>
<li>
<tt>deploy</tt> - used in an integration or release environment. Copies the final package to the remote repository for sharing with other developers and projects.
</li>

</ul>
<div class="Unindented">
Maven is typically run from the command line<span class="FootOuter"><span class="SupFootMarker"> [Z] </span><span class="HoverFoot"><span class="SupFootMarker"> [Z] </span>There are IDE plugins for Maven for most major IDEs as well</span></span> by executing command “<tt>mvn &lt;phase&gt;</tt>”, where <tt>&lt;phase&gt;</tt> is one of the phases listed above. Since phases are defined in order, all phases up to the one you specify will be run. For example, if you want to package your code, simply run “<tt>mvn package</tt>” and the <tt>compile</tt> and <tt>test</tt> phases will automatically be run. You can also execute specific goals for the various plugins that Maven uses. Execution of a specific goal is done with the command “<tt>mvn &lt;plugin&gt;:&lt;goal&gt;</tt>”. For instance, the compile phase actually calls the <tt>compiler:compile</tt> goal by default. A common usage of executing a goal for Lift is the <tt>jetty:run</tt> goal, which compiles all of your code and then runs an instance of the Jetty<span class="FootOuter"><span class="SupFootMarker"> [A] </span><span class="HoverFoot"><span class="SupFootMarker"> [A] </span><a class="URL" href="http://www.mortbay.org/jetty/">http://www.mortbay.org/jetty/</a></span></span> web server so that you can exercise your app. The jetty plugin is not directly bound to any lifecycle or phase, so we have to execute the goal directly. 
</div>
<div class="Indented">
One final note is that you can specify multiple phases/goals in one command line, and Maven will execute them in order. This is useful, for instance, if you want to do a clean build of your project. Simply run “<tt>mvn clean jetty:run</tt>” and the <tt>clean</tt> lifecycle will run, followed by the <tt>jetty:run</tt> goal (and all of the prerequisites for jetty:run, such as compile).
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-A.3">A.3</a> Repositories<a class="Label" name="sec:Repositories"> </a>
</h2>
<div class="Unindented">
Repositories are one of the key features of Maven. A repository is a location that contains plugins and packages for your project to use. There are two types of repository: local and remote. Your local repository is, as the name suggests, local to your machine, and represents a cache of artifacts downloaded from remote repositories as well as packages that you’ve installed from your own projects. The default locations of your local repo will be:
</div>
<ul>
<li>
Unix: <tt>~/.m2/repository</tt>
</li>
<li>
Windows: <tt>C:\Documents and Settings\&lt;user&gt;\.m2\repository</tt>
</li>

</ul>
<div class="Unindented">
You can override the local repository location by setting the M2_REPO environment variable, or by editing the &lt;home&gt;/.m2/settings.xml file<span class="FootOuter"><span class="SupFootMarker"> [B] </span><span class="HoverFoot"><span class="SupFootMarker"> [B] </span>Details on customizing your Maven installation are available at <a class="URL" href="http://maven.apache.org/settings.html">http://maven.apache.org/settings.html</a></span></span>.
</div>
<div class="Indented">
Remote repositories are repositories that are reachable via protocols like http and ftp and are generally where you will find the dependencies needed for your projects. Repositories are defined in the POM; listing <a class="Reference" href="#sec:Repositories">A.3↑</a> shows the definition of the scala-tools.org release repository where Lift is found<span class="FootOuter"><span class="SupFootMarker"> [C] </span><span class="HoverFoot"><span class="SupFootMarker"> [C] </span>scala-tools.org also has a snapshots repository where nightly builds of the scala-tools projects are kept</span></span>. Maven has an internal default set of repositories so usually you don’t need to define too many extra repos.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Defining a repository<a class="Label" name="lst:Defining-a-repository"> </a>
</div>
<pre class="listing brush: xml">&lt;repositories&gt;
  &lt;repository&gt;
    &lt;id&gt;scala-tools.org&lt;/id&gt;
    &lt;name&gt;Scala Tools Maven2 Repository&lt;/name&gt;
    &lt;url&gt;http://scala-tools.org/repo-releases&lt;/url&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;
</pre>
</div>

</div>
<div class="Indented">
As a final note, sometimes you may not have net access or the remote repos will be offline for some reason. In this case, make sure to specify the “-o” (offline) flag so that Maven skips checking the remote repos.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-A.4">A.4</a> Plugins
</h2>
<div class="Unindented">
Plugins add functionality to the Maven build system. Lift is written in Scala, so the first plugin that we need to add is the Maven Scala Plugin; this adds the ability to compile Scala code in your project. Listing <a class="Reference" href="#lst:Configuring-the-Maven-scala">A.4↓</a> shows how we configure the plugin in the pom.xml file for a Lift application. You can see the Scala plugin adds a <tt>compile</tt> and <tt>testCompile</tt> goal for the build phase, which makes Maven execute this plugin when those goals are called (explicitly or implicitly). In addition, the configuration element allows you to set properties of the plugin executions; in this case, we’re explicitly specifying the version of Scala that should be used for compilation.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Configuring the Maven Scala Plugin<a class="Label" name="lst:Configuring-the-Maven-scala"> </a>
</div>
<pre class="listing brush: xml">&lt;plugin&gt;         
  &lt;groupId&gt;org.scala-tools&lt;/groupId&gt;         
  &lt;artifactId&gt;maven-scala-plugin&lt;/artifactId&gt;         
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;goals&gt;
        &lt;goal&gt;compile&lt;/goal&gt;               
        &lt;goal&gt;testCompile&lt;/goal&gt;             
      &lt;/goals&gt;           
    &lt;/execution&gt;         
  &lt;/executions&gt;         
  &lt;configuration&gt;           
    &lt;scalaVersion&gt;${scala.version}&lt;/scalaVersion&gt;         
  &lt;/configuration&gt;       
&lt;/plugin&gt;
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-A.5">A.5</a> Dependencies
</h2>
<div class="Unindented">
Dependency management is one of the more useful features of Maven. Listing <a class="Reference" href="#lst:Adding-a-Dependency">A.5↓</a> shows a declaration of the Jetty dependency for the default Lift application. The details of the specification are straightforward:
</div>
<ul>
<li>
The groupId and artifactId specify the artifact. A given group may have many artifacts under it; for instance, Lift uses net.liftweb for its groupId and the core artifacts are lift-core and life-util
</li>
<li>
The version is specified either directly or with a range, as we’ve used in this example. A range is defined as &lt;left&gt;min,max&lt;right&gt; where left and right indicate an inclusive or exclusive range: [ and ] are inclusive, ( and ) are exclusive. Omitting a version in a range leaves that portion of the range unbounded. Here we configure the pom so that Jetty 6.1.6 or higher is used
</li>
<li>
The scope of the dependency is optional<span class="FootOuter"><span class="SupFootMarker"> [D] </span><span class="HoverFoot"><span class="SupFootMarker"> [D] </span>Scope is discussed in detail at <a class="URL" href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html</a></span></span>, and controls exactly where the dependency is used. In this case we specify a test scope which means that the package will only be available to test phases
</li>

</ul>
<div class="Unindented">
<div class="listing">
<div class="caption">
Adding a Dependency<a class="Label" name="lst:Adding-a-Dependency"> </a>
</div>
<pre class="listing brush: xml">&lt;dependency&gt;
  &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;
  &lt;artifactId&gt;jetty&lt;/artifactId&gt;
  &lt;version&gt;[6.1.6,)&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt; 
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-A.5.1">A.5.1</a> Adding a Dependency<a class="Label" name="sub:Adding-a-Dependency"> </a>
</h3>
<div class="Unindented">
As an example, let’s say that you’d like to add a new library and you want Maven to make sure you’ve got the most up-to-date version. We’re going to add Configgy<span class="FootOuter"><span class="SupFootMarker"> [E] </span><span class="HoverFoot"><span class="SupFootMarker"> [E] </span>Configgy’s home is <a class="URL" href="http://www.lag.net/configgy/">http://www.lag.net/configgy/</a></span></span> as a dependency. Configgy is “a library for handling config files and logging for a scala daemon. The idea is that it should be simple and straightforward, allowing you to plug it in and get started quickly, writing small useful daemons without entering the shadowy world of java frameworks.”
</div>
<div class="Indented">
First we need to tell Maven where we can get Configgy, so in the <tt>&lt;repositories&gt;</tt> section add the following:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Adding the Configgy repo<a class="Label" name="lst:Adding-the-Configgy-repo"> </a>
</div>
<pre class="listing brush: xml">&lt;repository&gt; 
  &lt;id&gt;http://www.lag.net/repo/&lt;/id&gt; 
  &lt;name&gt;http://www.lag.net/repo/&lt;/name&gt; 
  &lt;url&gt;http://www.lag.net/repo/&lt;/url&gt; 
&lt;/repository&gt;
</pre>
</div>

</div>
<div class="Indented">
Then in the <tt>&lt;dependencies&gt;</tt> section add:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Adding the Configgy dependency<a class="Label" name="lst:Adding-the-Configgy-dep"> </a>
</div>
<pre class="listing brush: xml">&lt;dependency&gt; 
  &lt;groupid&gt;net.lag&lt;/groupid&gt; 
  &lt;artifactid&gt;configgy&lt;/artifactid&gt; 
  &lt;version&gt;[1.2,)&lt;/version&gt; 
&lt;/dependency&gt;
</pre>
</div>

</div>
<div class="Indented">
That’s it, you’re done. The next time you run Maven for your project, it will pull down the Configgy jars into your local repository. Maven will periodically check for new versions of dependencies when you build, but you can always force a check with the “-U” (update) flag.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-A.6">A.6</a> Further Resources
</h2>
<div class="Unindented">
Obviously we’ve only scratched the surface on what you can with Maven and how to configure it. We’ve found the following set of references useful in learning and using Maven:
</div>
<ul>
<li>
<a class="URL" href="http://maven.apache.org">http://maven.apache.org</a> - The Maven home page
</li>
<li>
<a class="URL" href="http://maven.apache.org/what-is-maven.html">http://maven.apache.org/what-is-maven.html</a> - A brief description of Maven’s goals
</li>
<li>
<a class="URL" href="http://maven.apache.org/guides/introduction/introduction-to-the-pom.html">http://maven.apache.org/guides/introduction/introduction-to-the-pom.html</a> - An introduction to the pom file
</li>
<li>
<a class="URL" href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html">http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a>- An overview of the lifecycles
</li>
<li>
<a class="URL" href="http://suereth.blogspot.com/2008/10/maven-for-beginners.html">http://suereth.blogspot.com/2008/10/maven-for-beginners.html</a>- A brief Maven usage tutorial
</li>
<li>
<a class="URL" href="http://scala-blogs.org/2008/01/maven-for-scala.html">http://scala-blogs.org/2008/01/maven-for-scala.html</a>- A brief tutorial on using Maven geared toward Scala
</li>
<li>
<a class="URL" href="http://mvnrepository.com/">http://mvnrepository.com/</a>- A website that lets you search for Maven dependencies by name. Invaluable when you’re trying to add libraries to your project
</li>

</ul>
<h2 class="Section">
<a class="toc" name="toc-Section-A.7">A.7</a> Project Layout
</h2>
<div class="Unindented">
One of the things that allows Maven to work so well is that there is a standardized layout for projects. We’re not going to cover all of the standard locations for parts of your Maven project, but we do want to highlight a few locations that are important to Lift applications specifically:
</div>
<div class="Description">
<span class="Description-entry">&lt;application_root&gt;/src/main/scala</span> This directory is where you place your Scala source, such as snippets, model objects, and any libraries you write. The subfolder structure follows the traditional Java packaging style.
</div>
<div class="Description">
<span class="Description-entry">&lt;application_root&gt;/src/main/resources</span> This directory is where you would place any resources that you want to go into the WAR file. Typically this is used if you want to add entries to the <tt>META-INF</tt> directory in the WAR, since normal web resources should be placed under the <tt>webapp/WEB-INF</tt> directory.
</div>
<div class="Description">
<span class="Description-entry">&lt;application_root&gt;/src/main/webapp</span> All of the web and static content for your application, such as images, XHTML templates, JavaScript and CSS are placed under this directory. This is also where your <tt>WEB-INF</tt> directory (and the configuration files it contains) goes. This directory is essentially what is packaged into the WAR in addition to the output from your Scala sources.
</div>
<div class="Description">
<span class="Description-entry">&lt;application_root&gt;/src/main/webapp/templates-hidden</span> This is a special location for templates. As we discuss more in sections <a class="Reference" href="#sub:snippet-tag">5.1↑</a> and <a class="Reference" href="#sub:embed-tag">4.5.7↑</a>, templates placed in this directory cannot be viewed directly by clients, but are available to other templates.
</div>
<div class="Description">
<span class="Description-entry">&lt;application_root&gt;/src/test/scala</span> This directory is where you can put all of your test code. As with <tt>src/main/scala</tt>, the subfolder structure follows the traditional Java packaging style.
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Appendix-B">B</a> Message Handling<a class="Label" name="cha:Message-Handling"> </a>
</h1>
<div class="Unindented">
When we talk about message handling in Lift, we’re talking about how you provide feedback to the users of your application. While there are already a lot of mechanisms for displaying data to the user via snippets, views, etc, properly binding and setting up HTML-level elements can get complicated, especially when you’re dealing with callback functions or error handling. Lift provides an alternate mechanism for displaying messages to users that is easy to use and allows flexibility in display on the client side.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-B.1">B.1</a> Sending Messages
</h2>
<div class="Unindented">
Messages for non-Comet requests are handled via the S object (yes, even Ajax is handled automatically); specifically, the error, notice and warning methods allow you to send a String or a NodeSeq back to the user for display, with or without an association with a particular element id. The error method also provides an overload that takes a List[FieldError], the type returned from Mapper field validation (section <a class="Reference" href="#sub:Mapper-Validation">8.2.3↑</a>). The messages that you send are held by a RequestVar (section <a class="Reference" href="#sec:Session-and-Request">3.11↑</a>) in the S object, so you can send messages from anywhere in your stateful request/response lifecycle without breaking the flow of your code. Listing <a class="Reference" href="#lst:Using-messages-in-forms">B.1↓</a> shows how you could use messages in form processing to send feedback on missing fields.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using messages in form processing<a class="Label" name="lst:Using-messages-in-forms"> </a>
</div>
<pre class="listing brush: scala">object data extends RequestVar[String]("")
​
def addNote (xhtml : NodeSeq) : NodeSeq = {
  def doAdd () = {
    //validate
    if (data.is == "") { 
      S.error("noteField", "You need to provide a note")
    } else {
      Note.create.note(data).save
      S.notice("Note added")
      redirectTo("/viewNotes")
    }
  }
  bind("form", xhtml,
       "note" -&gt; SHtml.text(data.is, data(_), "id" -&gt; "noteField"),
       "add" -&gt; SHtml.submit("Add", doAdd))
}
</pre>
</div>

</div>
<div class="Indented">
In this particular case we use two different messages. One is an error to be displayed when the form is re-shown; this error is associated with the “noteField” element. The second message is a simple notice to let the user know that the data was successfully saved.
</div>
<div class="Indented">
For Comet<a class="IndexReference" name="entry-Comet-1" href="#index-Comet">↓</a> the only difference in sending messages is that the error, notice and warning methods are defined in the CometActor class, so you just use those directly and Lift handles the rest. 
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-B.2">B.2</a> Displaying Messages
</h2>
<div class="Unindented">
The display of messages is handled by two builtin snippets, &lt;lift:Msgs/&gt; and &lt;lift:Msg/&gt;. The Msgs snippet displays all messages not associated with a particular element Id. The messages are displayed as an unordered list, but Lift allows customization of the messages via XML that you embed within the snippet. For each of the three message types, you can specify a &lt;lift:TYPE_msg&gt; and &lt;lift:TYPE_class&gt; element that controls the message label and CSS class, respectively. The default label is simply the title-case type (Error, Notice, Warning). For example, listing <a class="Reference" href="#lst:Custom-message-labels">B.2↓</a> shows how we could change the error and notice messages.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Custom message labels<a class="Label" name="lst:Custom-message-labels"> </a>
</div>
<pre class="listing brush: scala">&lt;lift:Msgs&gt;
  &lt;lift:error_msg&gt;Danger, Will Robinson! &lt;/lift:error_msg&gt;
  &lt;lift:error_class&gt;redtext&lt;/lift:error_class&gt;
  &lt;lift:notice_msg&gt;FYI: &lt;/lift:notice_msg&gt;
&lt;/lift:Msgs&gt;
</pre>
</div>

</div>
<div class="Indented">
The Msg snippet is used to display all messages associated with a particular Id by specifying the id attribute on the &lt;lift:Msg/&gt; element. With Msg, you don’t get a message label, so there’s no override mechanism for it. You do, however, have the ability to to change the message class on a per-type basis by setting the noticeClass, errorClass, or warningClass attributes on the &lt;lfit:Msg/&gt; element. Listing <a class="Reference" href="#lst:Per-id-messages">B.2↓</a> shows usage of Msg corresponding to our snippet in listing <a class="Reference" href="#lst:Using-messages-in-forms">B.1↑</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Per-id messages<a class="Label" name="lst:Per-id-messages"> </a>
</div>
<pre class="listing brush: scala">&lt;lift:Stuff.addNote form="POST"&gt;
  &lt;form:note /&gt;&lt;lift:Msg id="noteField" errorClass="redtext" /&gt;
  &lt;form:add /&gt;
&lt;/lift:Stuff.addNote&gt;
</pre>
</div>

</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Appendix-C">C</a> Lift Helpers<a class="Label" name="cha:Lift-Helpers"> </a>
</h1>
<h2 class="Section">
<a class="toc" name="toc-Section-C.1">C.1</a> Introduction<a class="Label" name="sec:Introduction"> </a>
</h2>
<div class="Unindented">
Lift provides a fairly useful collection of helper artifacts. The helpers are essentially utility functions that minimize the need for boilerplate code. This appendix is intended to introduce some of the more common utility classes and objects to you so that you’re familiar with them. If you would like more details, you can look at the API documentation for the <tt>net.liftweb.util package</tt>.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-C.2">C.2</a> Box (or Scala’s Option class on steroids)<a class="Label" name="sec:Box-(or-Scala's"> </a>
</h2>
<div class="Unindented">
<tt>net.liftweb.util.Box</tt> (or Scala’s <tt>scala.Option</tt> class on steroids) is a utility class that mimics Scala’s <tt>Option</tt> type (also heavily used inside Lift). To understand some of the underlying concepts and assumptions, let’s take a quick look at <tt>Option</tt> class first. The <tt>Option</tt> class allows a type-safe way of dealing with a situation where you may or may not have a result. <tt>Option</tt> has two values, either <tt>Some(value)</tt>, where <tt>value</tt> is actually the value, and <tt>None</tt>, which is used to represent nothing. A typical example for <tt>Option</tt> is outlined using Scala’s Map type. Listing <a class="Reference" href="#lst:Option-and-Map">C.2↓</a> shows a definition of a <tt>Map</tt>, a successful attempt to get the value of key <tt>a</tt>, and an attempt to get the value of key <tt>i</tt>. Notice that when we retrieved the existing key-value pair for <tt>a</tt>, the value returned was <tt>Some(A)</tt> and when we asked for the value of key <tt>i</tt>, we received None.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Option and Map example<a class="Label" name="lst:Option-and-Map"> </a>
</div>
<pre class="listing brush: scala">scala&gt; val cap = Map("a" -&gt; "A", "b" -&gt; "B") 
cap: scala.collection.immutable.Map[java.lang.String,java.lang.String] = 
  Map(a -&gt; A, b -&gt; B)
​
scala&gt; cap.get("a")  
res1: Option[java.lang.String] = Some(A)
​
scala&gt; cap.get("i") 
res2: Option[java.lang.String] = None
</pre>
</div>

</div>
<div class="Indented">
Getting the value out of an <tt>Option</tt> is usually handled via Scala’s matching mechanism or via the <tt>getOrElse</tt> function, as shown in Listing <a class="Reference" href="#lst:Fetch-value-from">C.2↓</a>:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Fetch value from an Option<a class="Label" name="lst:Fetch-value-from"> </a>
</div>
<pre class="listing brush: scala">def prettyPrint(foo: Option[String]): String = foo match {
  case Some(x) =&gt; x
  case None =&gt; "Nothing found."
}
​
// Which would be used in conjunction with the previous code:
scala&gt; prettyPrint(cap.get("a")) 
res7: String = A
​
scala&gt; prettyPrint(cap.get("i")) 
res8: String = Nothing found.
</pre>
</div>

</div>
<div class="Indented">
<tt>Box</tt> in Lift covers the same base functionality as <tt>Option</tt> but expands the semantics for missing values. If we have an <tt>Option</tt> that is <tt>None</tt> at some point, we can’t really tell why that <tt>Option</tt> is <tt>None</tt>, although in many situations, knowing why would be quite helpful. With <tt>Box</tt>, on the other hand, you have either have a <tt>Full</tt> instance (corresponding to <tt>Some</tt> with <tt>Option</tt>) or an instance that subclasses <tt>EmptyBox</tt> (corresponding to <tt>None</tt>). <tt>EmptyBox</tt> can either be an <tt>Empty</tt> instance or a <tt>Failure</tt> instance incorporating the cause for the failure. So you can think of <tt>Box</tt> as a container with three states: full, empty, or empty for a particular reason. The <tt>Failure</tt> case class takes three arguments: a <tt>String</tt> message to describe the failure, a <tt>Box[Throwable]</tt> for an optional exception related to the failure, and a <tt>Box[Failure]</tt> for chaining based on earlier <tt>Failure</tt>s. 
</div>
<div class="Indented">
As an example of how we can use <tt>Box</tt> instances in real code, consider the case where we have to do a bunch of null checks, perform an operation, and then perform more null checks, other operations, and so on. Listing <a class="Reference" href="#lst:Pseudocode-nested-operations">C.2↓</a> shows an example of this sort of structure.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Pseudocode nested operations example<a class="Label" name="lst:Pseudocode-nested-operations"> </a>
</div>
<pre class="listing brush: scala">    x = getSomeValue();
    if (x != null) {
      y = getSomeOtherValue();
      if (y != null) {
        compute(x, y);
      }
    }
​
</pre>
</div>

</div>
<div class="Indented">
This is tedious and error-prone in practice. Now let’s see if we can do better by combining Lift’s <tt>Box</tt> with Scala’s for comprehensions as shown in Listing <a class="Reference" href="#lst:Scala-nested-operations">C.2↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Box nested operations example<a class="Label" name="lst:Scala-nested-operations"> </a>
</div>
<pre class="listing brush: scala">​
    def getSomeValue(): Box[Int] = Full(12)     
    def getSomeOtherValue(): Box[Int] = Full(2)
    
    def compute(x: Int, y: Int) = x * y
  
    val res = for ( x &lt;- getSomeValue();
                    y &lt;- getSomeOtherValue() if x &gt; 10) yield compute(x, y)
    println(res) 
</pre>
</div>

</div>
<div class="Indented">
In Listing <a class="Reference" href="#lst:Scala-nested-operations">C.2↑</a>, we have two values, <tt>x</tt> and <tt>y</tt>, and we want to do some computation with these values. But we must ensure that computation is done on the correct data. For instance, the computation cannot be done if <tt>getSomeValue</tt> returns no value. In this context, the two functions return a <tt>Box[Int]</tt>. The interesting part is that if either or both of the two functions return an <tt>Empty</tt> Box instead of <tt>Full</tt> (<tt>Empty</tt> impersonating the nonexistence of the value), the <tt>res</tt> value will also be <tt>Empty</tt>. However, if both functions return a <tt>Full</tt> (like in Listing <a class="Reference" href="#lst:Scala-nested-operations">C.2↑</a>), the computation is called. In our example the two functions return <tt>Full(12)</tt> and <tt>Full(2)</tt>, so <tt>res</tt> will be a <tt>Full(24)</tt>.
</div>
<div class="Indented">
But we have something else interesting here: the <tt>if x &gt; 10</tt> statement (this is called a “guard” in Scala). If the call to <tt>getSomeValue</tt> returns a value less than or equal to 10, the <tt>y</tt> variable won’t be initialized, and the res value will be <tt>Empty</tt>. This is just a taste of some of the power of using <tt>Box</tt> for comprehensions; for more details on for comprehensions, see <i>The Scala Language Specification</i>, section 6.19, or one of the many Scala books available.
</div>
<div class="Indented">
Lift’s <tt>Box</tt> extends <tt>Option</tt> with a few ideas, mainly the fact that you can add a message about why a <tt>Box</tt> is <tt>Empty</tt>. <tt>Empty</tt> corresponds to <tt>Option</tt>’s <tt>None</tt> and <tt>Full</tt> to <tt>Option</tt>’s Some. So you can pattern match against a <tt>Box</tt> as shown in Listing <a class="Reference" href="#lst:Box-example">C.2↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Box example<a class="Label" name="lst:Box-example"> </a>
</div>
<pre class="listing brush: scala">a match {
  Full(author) =&gt; Text("I found the author " + author.niceName)
  Empty =&gt; Text("No author by that name.")
  // message may be something like "Database disconnected."
  Failure(message, _, _) =&gt; Text("Nothing found due to " + message) 
}
def confirmDelete {     
  (for (val id &lt;- param("id");     // get the ID           
        val user &lt;- User.find(id)) // find the user                                                                                
  yield {          
    user.delete_!                   
    notice("User deleted")          
    redirectTo("/simple/index.html")        
  }) getOrElse {error("User not found"); redirectTo("/simple/index.html")}    
}
​
</pre>
</div>

</div>
<div class="Indented">
In conjunction with Listing <a class="Reference" href="#lst:Box-example">C.2↑</a>, we can use other <tt>Box</tt> functions, such as the <tt>openOr</tt> function shown in Listing <a class="Reference" href="#lst:openOr-example">C.2↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
openOr example<a class="Label" name="lst:openOr-example"> </a>
</div>
<pre class="listing brush: scala">lazy val UserBio = UserBio.find(By(UserBio.id, id)) openOr (new UserBio)
def view (xhtml: NodeSeq): NodeSeq = passedAuthor.map({ author =&gt; 
  // do bind, etc here and return a NodeSeq
}) openOr Text("Invalid author") 
</pre>
</div>

</div>
<div class="Indented">
We won’t be detailing all of the Box functions here, but a few words on the most common function might be benficial.
</div>
<div class="Indented">
<div class="center">
<table>
<tr>
<td align="left" valign="top" style="width: 1in;">
Function name
</td>
<td align="left" valign="top" style="width: 2.75in;">
Description
</td>
<td align="left" valign="top" style="width: 2in;">
Short example. Assume myBox is a Box
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1in;">
openOr
</td>
<td align="left" valign="top" style="width: 2.75in;">
Returns the value contained by this Box. If the Box is Empty 
</td>
<td align="left" valign="top" style="width: 2in;">
myBox openOr “The box is Empty”
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1in;">
map
</td>
<td align="left" valign="top" style="width: 2.75in;">
Apply a function on the values of this Box and return something else.
</td>
<td align="left" valign="top" style="width: 2in;">
myBox map (value =&gt; value + “ suffix”)
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1in;">
dmap
</td>
<td align="left" valign="top" style="width: 2.75in;">
Equivalent with map(..) openOr default_value. The default value will be returned in case the map is Empty
</td>
<td align="left" valign="top" style="width: 2in;">
myBox dmap(“default”)(value =&gt; value + “ suffix”)
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1in;">
!!
</td>
<td align="left" valign="top" style="width: 2.75in;">
If the argument is null in will return an Empty, otherwise a Full containing the arguent’s value. Note this this is a method on the Box object, not a given Box instance.
</td>
<td align="left" valign="top" style="width: 2in;">
Box !! (&lt;a reference&gt;)
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1in;">
?~
</td>
<td align="left" valign="top" style="width: 2.75in;">
Transforms an Empty to a Failure and passing a message. If the Box is a Full it will just return <tt>this</tt>.
</td>
<td align="left" valign="top" style="width: 2in;">
myBox ?~ (“Error message”)
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1in;">
isDefined
</td>
<td align="left" valign="top" style="width: 2.75in;">
Returns true if this Box contains a value
</td>
<td align="left" valign="top" style="width: 2in;">
myBox isDefined
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1in;">
isEmpty
</td>
<td align="left" valign="top" style="width: 2.75in;">
Retun true is this Boxis empty
</td>
<td align="left" valign="top" style="width: 2in;">
myBox isEmpty
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1in;">
asA[B]
</td>
<td align="left" valign="top" style="width: 2.75in;">
Return a Full[B] if the content of this Box is of type B, otherwise return Empty 
</td>
<td align="left" valign="top" style="width: 2in;">
myBox asA[Person]
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 1in;">
isA[B]
</td>
<td align="left" valign="top" style="width: 2.75in;">
Return a Full[B] if the contents of this Box is an instance of the specified class, otherwise return Empty 
</td>
<td align="left" valign="top" style="width: 2in;">
myBox isA[Person]
</td>

</tr>

</table>

</div>

</div>
<div class="Indented">
Note that <tt>Box</tt> contains a set of implicit conversion functions from/to <tt>Option</tt> and from/to <tt>Iterable</tt>.
</div>
<div class="Indented">
Remember that Box is heavily used in Lift and most of the Lift’s API’s operates with <tt>Box</tt>es. The rationale is to avoid <tt>n</tt>ull references and to operate safely in context where values may be missing. Of course, a <tt>Box</tt> can be set to <tt>null</tt> manually but we strongly recommend against doing so. There are cases, however, where you are using some third party Java libraries with APIs that return <tt>null</tt> values. To cope with such cases in Lift you can use the <tt>!!</tt> function to <tt>Box</tt> that value. Listing <a class="Reference" href="#lst:Null-example">C.2↓</a> shows how we can deal with a possible <tt>null</tt> value.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Null example<a class="Label" name="lst:Null-example"> </a>
</div>
<pre class="listing brush: scala">​
var x = getSomeValueThatMayBeNull();
​
var boxified = Box !! x
​
</pre>
</div>

</div>
<div class="Indented">
In this case the <tt>boxified</tt> variable will be <tt>Empty</tt> if <tt>x</tt> is <tt>null</tt> or <tt>Full(x)</tt> if <tt>x</tt> is a valid value/reference..
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-C.3">C.3</a> ActorPing<a class="Label" name="sec:ActorPing"> </a>
</h2>
<div class="Unindented">
It provides convenient functionality to schedule messages to Actors. 
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
ActorPing example<a class="Label" name="lst:ActorPing-example"> </a>
</div>
<pre class="listing brush: scala">// Assume myActor an existing Actor
// And a case object MyMessage
​
// Send the MyMessage message after 15 seconds
ActorPing.schedule(myActor, MyMessage, 15 seconds)
​
// Send the MyMessage message every 15 seconds. The cycle is stopped 
// if recipient actor exits or replied back with UnSchedule message
ActorPing.scheduleAtFixedRate(myActor, MyMessage, 0 seconds, 15 seconds)
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-C.4">C.4</a> ClassHelpers<a class="Label" name="sec:ClassHelpers"> </a>
</h2>
<div class="Unindented">
Provides convenient functions for loading classes using Java reflection, instantiating dinamically loaded classes, invoking methods vis reflection etc.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
ClassHelper example<a class="Label" name="lst:ClassHelper-example"> </a>
</div>
<pre class="listing brush: scala">import _root_.net.liftweb.util.Helpers._
​
// lookup the class Bar in the three packages specified in th list
findClass("Bar", "com.foo" :: "com.bar" :: "com.baz" :: Nil)
​
invokeMethod(myClass, myInstance, "doSomething")
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-C.5">C.5</a> CodeHelpers<a class="Label" name="sec:CodeHelpers"> </a>
</h2>
<div class="Unindented">
Provides a convenient way of telling why a boolean expression failed. For instance we are seeing manytime code like:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Expression example<a class="Label" name="lst:Expression-example"> </a>
</div>
<pre class="listing brush: scala">var isTooYoung = false;
var isTooBig = false;
var isTooLazy = true;
​
var exp = isTooYoung &amp;&amp; isTooBig &amp;&amp; isTooLazy
​
</pre>
</div>

</div>
<div class="Indented">
As you can see we have no way of telling if the exp was false because of isTooYoung, isTooBig or isTooLazy unless we test them again. But let’s see this:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
CodeHelpers example<a class="Label" name="lst:CodeHelpers-example"> </a>
</div>
<pre class="listing brush: scala">​
import net.liftweb.util._
import net.liftweb.util.MonadicConversions._
​
val exp = (isTooYoung ~ "too young") &amp;&amp;  
          (isTooBad ~ "too bad") &amp;&amp;  
          (isToLazy ~ "too lazy")
​
println(exp match {  
  case False(msgs) =&gt; 
    msgs mkString("Test failed because it is ’", "’ and ’", "’.")  
  case _ =&gt; "success"  
  }) 
</pre>
</div>

</div>
<div class="Indented">
Now if exp is a False we can tell why it failed as we have the messages now.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-C.6">C.6</a> ControlHelpers<a class="Label" name="sec:ControlHelpers"> </a>
</h2>
<div class="Unindented">
Provides convenient functions for try/catch situations. For example:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
ControlHelpers example<a class="Label" name="lst:ControlHelpers-example"> </a>
</div>
<pre class="listing brush: scala">​
tryo {
  // code here. Any exception thrown here will be silently caught
}
​
 
tryo((e: Throwable) =&gt; println(e)) {
  // code here. Any exception here willbe caught add passed to 
  // the above function.
}
​
tryo(List(classOf[ClassNotFoundException], classOf[IOException])) {
  // code here. If IOException or ClassNotFoundException is thrown 
  // (or a subclass of the two) they will be ignored. Any other
  // exception will be rethrown.
}
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-C.7">C.7</a> CSSHelpers<a class="Label" name="sec:CSSHelpers"> </a>
</h2>
<div class="Unindented">
This provide a convenient functionality to fix relative root paths in CSS (Cascade Stylesheet) files. Here is an example:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
CSSHelper example<a class="Label" name="lst:CSSHelper-example"> </a>
</div>
<pre class="listing brush: scala">Assume this entry in a CSS file:
​
.boxStyle {
  background-image: url(’/img/bkg.png’)
}
​
​
//in your code you can say
​
CSSHelpers.fixCSS(reader, "/myliftapp")
​
// where reader is a java.io.Reader that provides the 
// content of the CSS file.
</pre>
</div>

</div>
<div class="Indented">
Now if your application is not deployed in the ROOT context path (“/”) and say it is deployed with the context root /myliftapp then the background picture will probably notbe found. Say <tt>http://my.domain.com/img/bkg.png</tt> is an unknown path. However <tt>http://my.domain.com/<u>myliftapp</u>/img/bkg.png </tt>is known. In the example above we are calling fixCSS so that it will automatically replace the root relative paths such that <tt>background-image: url(’/img/bkg.png’)</tt> becomes <tt>background-image: url(’/myliftapp/img/bkg.png’)</tt>. To use that in your lift application you can do:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
fixCSS example<a class="Label" name="lst:fixCSS-example"> </a>
</div>
<pre class="listing brush: scala">def boot(){
    ...
    LiftRules.fixCSS("styles" :: "theme" :: Nil, Empty)
    ...
}
</pre>
</div>

</div>
<div class="Indented">
When the <tt>/styles/theme.css</tt> file Lift will apply the prefix specified. But in this case we provided an Empty Box. This actually means that Lift will apply the context path returned by <tt>S.contextPath </tt>function which as you know returns the context path from the <tt>HttpSession</tt>.
</div>
<div class="Indented">
Internally when you call <tt>fixCSS</tt> a dispatch function is automatically created and pre-pended to <tt>LiftRules.dispatch</tt>. This is needed in order to intercept the browser request to this .css resource. Also internally we are telling Lift the this resource must be server by Lift and not by container. 
</div>
<div class="Indented">
The way it works internally is that we are using Scala combinator parsers to augment only the root relative paths with the given prefix.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-C.8">C.8</a> BindHelpers<a class="Label" name="sec:BindHelpers"> </a>
</h2>
<div class="Unindented">
Binders are extensiveley discussed in other chapters so we won’t reiterate them here. 
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Choose template XML<a class="Label" name="lst:Choose-template"> </a>
</div>
<pre class="listing brush: xml">&lt;lift:CountGame.run form="post"&gt;
  &lt;choose:guess&gt;
    Guess a number between 1 and 100.&lt;br/&gt;
    Last guess: &lt;count:last/&gt;&lt;br /&gt;
    Guess: &lt;count:input/&gt;&lt;br/&gt;
    &lt;input type="submit" value="Guess"/&gt;
  &lt;/choose:guess&gt;
  &lt;choose:win&gt;
    You Win!!&lt;br /&gt;
    You guessed &lt;count:number/&gt; after &lt;count:count/&gt; guesses.&lt;br/&gt;
  &lt;/choose:win&gt;
&lt;/lift:CountGame.run&gt;
</pre>
</div>

</div>
<div class="Indented">
You can use the <tt>Helpers.chooseTemplate</tt> method to extract portions of a given XML input:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Choose template Scala code
</div>
<pre class="listing brush: scala">import net.liftweb.util._
import Helpers._
​
class CountGame {
  def run(xhtml: NodeSeq): NodeSeq = {
    ... 
    chooseTemplate("choose", "win", xhtml);
  }
}
</pre>
</div>

</div>
<div class="Indented">
So in the snippet conditionally we can choose between parts of the snippet template. In the case above only the childs of <tt>&lt;choose:win&gt;</tt> node will be returned by the snippetfunction, hence rendered.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-C.9">C.9</a> HttpHelpers<a class="Label" name="sec:HttpHelpers"> </a>
</h2>
<div class="Unindented">
This provides helper functions for HTTP parameters manipulation, URL encoding/decoding etc. However there is some interesting functionality available that lets you choose between tags of a snippet. 
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-C.10">C.10</a> JSON<a class="Label" name="sec:JSON"> </a>
</h2>
<div class="Unindented">
Lift provides its own JSON parser if you ever need one. At a first glance it may be a bit redundant with Scala’s JSON parser but infact Scala’sparser has its own problems with large JSON objects hence List’s uses its own JSON parser implemented of course using combinator parsers.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-C.11">C.11</a> LD<a class="Label" name="sec:LD"> </a>
</h2>
<div class="Unindented">
Provides utility functions for calculating the distance between words <span class="FootOuter"><span class="SupFootMarker"> [F] </span><span class="HoverFoot"><span class="SupFootMarker"> [F] </span>http://en.wikipedia.org/wiki/Levenshtein_distance</span></span>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-C.12">C.12</a> ListHelpers<a class="Label" name="sec:ListHelpers"> </a>
</h2>
<div class="Unindented">
Provides utility functions for manipulating lists that are not provided by Scala libraries.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-C.13">C.13</a> NamedPartialFunctions<a class="Label" name="sec:NamedPartialFunctions"> </a>
</h2>
<div class="Unindented">
Provides extremly useful functions for invoking partial functions that are chained in lists of functions. 
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
NamedPF example<a class="Label" name="lst:NamedPF-example"> </a>
</div>
<pre class="listing brush: scala">var f1: PartialFunction[Int,Int] = {
  case 10 =&gt; 11
  case 12 =&gt; 14
}
​
var f2: PartialFunction[Int,Int] = {
  case 20 =&gt; 11
  case 22 =&gt; 14
}
​
​
NamedPF(10, f1 :: f2 :: Nil)
​
</pre>
</div>

</div>
<div class="Indented">
Remember that many LiftRules variable are RuleSeq-s. Meaning that most of the times we re talking about lists of partial functions. Hence internally lift uses NamedPF for invoking such functions that are ultimately provided by the user. Please see <tt>LiftRules.dispatch</tt>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-C.14">C.14</a> SecurityHelpers<a class="Label" name="sec:SecurityHelpers"> </a>
</h2>
<div class="Unindented">
Provides various functions used for random number generation, encryption/decriptions (blowfish), hash calculations (MD5, SHA, SHA-256) and so on.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-C.15">C.15</a> TimeHelpers<a class="Label" name="sec:TimeHelpers"> </a>
</h2>
<div class="Unindented">
Utility functions for time operations. For instance if also provides a set of implicit conversion functions that allow you to type “10 seconds” and returns the value in milliseconds. 
</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Appendix-D">D</a> Internationalization<a class="Label" name="cha:Internationalization"> </a><a class="IndexReference" name="entry-Internationalization---see-I18N-0" href="#index-Internationalization---see-I18N">↓</a><a class="IndexReference" name="entry-I18N-0" href="#index-I18N">↓</a>
</h1>
<div class="Unindented">
The ability to display pages to users of multiple languages is a common feature of many web frameworks. Lift builds on the underlying Java I18N foundations<span class="FootOuter"><span class="SupFootMarker"> [G] </span><span class="HoverFoot"><span class="SupFootMarker"> [G] </span>Primarily java.util.Locale and java.util.ResourceBundle</span></span> to provide a simple yet flexible means for using Locales and translated strings in your app. Locales are used to control not only what language the text is in that’s presented to the user, but also number and date formatting, among others. If you want more details on the underlying foundation of Java I18N we suggest you visit the Internationalization Homepage at <a class="FlexURL" href="http://java.sun.com/javase/technologies/core/basic/intl/">http://java.sun.com/javase/technologies/core/basic/intl/</a>.
</div>
<div class="Indented">
Another note is that languages are selected in Lift using language tags, as defined in <a class="FlexURL" href="http://www.w3.org/International/articles/language-tags/">http://www.w3.org/International/articles/language-tags/</a>. Language tags are base on the ISO 639 standard<span class="FootOuter"><span class="SupFootMarker"> [H] </span><span class="HoverFoot"><span class="SupFootMarker"> [H] </span><a class="FlexURL" href="http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes">http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes</a></span></span>. In general, you should keep language tags as short as possible and avoid adding information (such as regional specifiers) that does not provide otherwise distinguishing information. For example, if your Spanish page will be used for both Mexican and Spanish clients without modification, simply use <tt>es</tt> and not <tt>es_MX</tt> or <tt>es_ES</tt>.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-D.1">D.1</a> Localized Templates<a class="Label" name="sec:Localized-Templates"> </a><a class="IndexReference" name="entry-I18N-Localized-templates-0" href="#index-I18N-Localized-templates">↓</a>
</h2>
<div class="Unindented">
As we described in Section <a class="Reference" href="#sec:Templates">4.1 on page 1↑</a>, Lift automatically chooses the template for a request based on the current locale by appending the locale’s variants. That means that a request for <tt>/index</tt> with a calculated locale of <tt>en_US</tt> will try these filenames, in order:
</div>
<ul>
<li>
<tt>index_en_US.html</tt>
</li>
<li>
<tt>index_en.html</tt>
</li>
<li>
<tt>index.html</tt>
</li>

</ul>
<div class="Unindented">
Note that Java upper-cases the country portion of the locale, so you need to make sure you name your templates accordingly. For instance, in the above example a file named <tt>index_en_us.html</tt> wouldn’t match.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-D.2">D.2</a> Resource Bundles<a class="Label" name="sec:Resource-Bundles"> </a>
</h2>
<div class="Unindented">
Resource bundles are sets of property files<span class="FootOuter"><span class="SupFootMarker"> [I] </span><span class="HoverFoot"><span class="SupFootMarker"> [I] </span>Technically, they can have other formats, but Lift generally only deals with <tt>PropertyResourceBundles</tt></span></span> that contain keyed strings for your application to use in messages. In addition to the key/value pair contents of the files, the filename itself is significant. When a <tt>ResourceBundle</tt> is specified by name, the base name is used as the default, and additional files with names of the form “&lt;base name&gt;_&lt;language tag&gt;” can be used to specify translations of the default strings in a given language. As an example, consider listing <a class="Reference" href="#lst:Default-door-bundle">D.2↓</a>, which specifies a default resource bundle for an application that reports the status of a door (open or closed). 
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Default Door Bundle<a class="Label" name="lst:Default-door-bundle"> </a>
</div>
<pre class="listing brush: scala">openStatus=The door is open
closedStatus=The door is closed
</pre>
</div>

</div>
<div class="Indented">
Suppose this file is called “DoorMessages.properties”; we can provide an additional translation for Spanish by creating a file called “DoorMessages_es.properties”, shown in listing <a class="Reference" href="#lst:Spanish-door-bundle">D.2↓</a>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Spanish Door Bundle<a class="Label" name="lst:Spanish-door-bundle"> </a>
</div>
<pre class="listing brush: scala">openStatus=La puerta está abierta
closedStatus=La puerta está cerrada
</pre>
</div>

</div>
<div class="Indented">
When you want to retrieve a message (covered in the next two sections) Lift will check the current Locale and see if there’s a specialized ResourceBundle available for it. If so, it uses the messages in that file; otherwise, it uses the default bundle. 
</div>
<div class="Indented">
Lift supports using multiple resource bundle files so that you can break your messages up into functional groups. You specify this by setting the <tt>LiftRules.resourceNames</tt> property to a list of the base names (without a language or “.properties” extension):
</div>
<pre class="LyX-Code">
LiftRules.resourceNames = "DoorMessages" :: 
                          "DoorknobMessages" :: Nil
</pre>
<div class="Unindented">
The order that you define the resource bundle names is the order that they’ll be searched for keys. The message properties files should be located in your <tt>WEB-INF/classes</tt> folder so that they are accessible from Lift’s classloader<span class="FootOuter"><span class="SupFootMarker"> [J] </span><span class="HoverFoot"><span class="SupFootMarker"> [J] </span>The properties files are retrieved with <tt>ClassLoader.getResourceAsStream</tt></span></span>; if you’re using Maven this will happen if you put your files in the <tt>src/main/resources</tt> directory.
</div>
<div class="Indented">
<div class="center">
<div class="Shadowbox" style="width: 75%;">
Note: According to the <tt>Properties</tt> documentation<span class="FootOuter"><span class="SupFootMarker"> [K] </span><span class="HoverFoot"><span class="SupFootMarker"> [K] </span><a class="FlexURL" href="http://download.oracle.com/javase/6/docs/api/java/util/Properties.html">http://download.oracle.com/javase/6/docs/api/java/util/Properties.html</a></span></span>, keys <i>must</i> escape significant whitespace, colons or equals signs in the key itself with backslashes. For example, to specify “this = that” as a key, you would have to write it as “this\ \=\ that” in the properties file.<a class="IndexReference" name="entry-I18N-whitespace-in-keys-0" href="#index-I18N-whitespace-in-keys">↓</a>
</div>

</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-D.3">D.3</a> An Important Note on Resource Bundle Resolution<a class="IndexReference" name="entry-I18N-Resource-bundle-resolution-0" href="#index-I18N-Resource-bundle-resolution">↓</a>
</h2>
<div class="Unindented">
Per Java’s documentation on <a class="URL" href="http://java.sun.com/javase/6/docs/api/java/util/ResourceBundle.html#getBundle(java.lang.String,%20java.util.Locale,%20java.lang.ClassLoader)">ResourceBundle</a>, resolution of property files is done in this order:
</div>
<ul>
<li>
baseName + “_” + language1 + “_” + country1 + “_” + variant1
</li>
<li>
baseName + “_” + language1 + “_” + country1
</li>
<li>
baseName + “_” + language1
</li>
<li>
baseName + “_” + language2 + “_” + country2 + “_” + variant2
</li>
<li>
baseName + “_” + language2 + “_” + country2
</li>
<li>
baseName + “_” + language2
</li>
<li>
baseName
</li>

</ul>
<div class="Unindented">
where “language1”, “country1”, and “variant1” are the requested locale parameters, and “language2”, “country2”, “variant2” are the default locale parameters.
</div>
<div class="Indented">
For example, if the default locale for your computer is “en_GB”, someone requests a page for “ja”, and you have the following property files defined:
</div>
<ul>
<li>
Messages_fr_FR.properties
</li>
<li>
Messages_en_GB.properties
</li>
<li>
Messages.properties
</li>

</ul>
<div class="Unindented">
then the <b>Messages_en_GB.properties</b> file, and not <b>Messages.properties</b> will be used. If you want to change this behavior so that any undefined locales utilize the base properties file, set your default Locale to the ROOT locale in your <tt>Boot.scala</tt> with the code shown in Listing <a class="Reference" href="#lst:Setting-the-ROOT-locale">D.3↓</a>:
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:Setting-the-ROOT-locale"> </a>Setting the ROOT Default Locale
</div>
<pre class="listing brush: scala">import java.util.Locale
Locale.setDefault(Locale.ROOT)
</pre>
</div>
 
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-D.4">D.4</a> Localized Strings in Scala Code<a class="Label" name="sec:Localized-Strings-in-Scala"> </a>
</h2>
<div class="Unindented">
Retrieving localized strings in your Scala code is primarily performed using the <tt>S.?</tt> method. When invoked with one argument the resource bundles are searched for a key matching the given argument. If a matching value is found it’s returned. If it can’t be found then Lift calls <tt>LiftRules.localizationLookupFailureNotice</tt> on the (key, current Locale) pair and then simply returns the key. If you call <tt>S.?</tt> with more than one argument, the first argument is still the key to look up, but any remaining arguments are used as format parameters for <tt>String.format</tt> executed on the retrieved value. For example, listing <a class="Reference" href="#lst:Formatted-bundles">D.4↓</a> shows a sample bundle file and the associated Scala code for using message formatting.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Formatted Bundles<a class="Label" name="lst:Formatted-bundles"> </a>
</div>
<pre class="listing brush: scala">// bundle
tempMsg=The current temperature is %0.1 degrees
// code
var currentTmp : Double = getTemp()
Text(S.?("tempMsg", currentTemp))
</pre>
</div>

</div>
<div class="Indented">
Lift also provides the <tt>S.??</tt> method, which is similar to <tt>S.?</tt> but uses the <tt>ResourceBundle</tt> for internal Lift strings. Lift’s resource-bundles are located in the i18n folder with the name lift-core.properties The resource-bundle name is given by <tt>LiftRules.liftCoreResourceName</tt> variable. Generally you won’t use this method.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-D.5">D.5</a> Formatting Localized Strings
</h2>
<div class="Unindented">
While Lift provides facilities for retrieving strings from localized property bundles (Section <a class="Reference" href="#sec:Localized-Strings-in-Scala">D.4↑</a>), it does not provide direct support for localized formatting of those strings. There is an <tt>S.?</tt> method which takes additional parameters, but it uses <tt>String.format</tt> (and printf syntax) to format the strings and does not properly support date/time formatting. Instead, we recommend you use <tt>java.text.MessageFormat</tt> for localized strings that will use parameters. Listing <a class="Reference" href="#lst:A-Utility-Method-l10n">D.5↓</a> shows a utility method that you can use in your code to localize strings with parameters. Note that if you have a lot of Lift’s implicit conversions in scope you may need to explicitly type some arguments as we have in this example.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
A Utility Method for Localizing Strings<a class="Label" name="lst:A-Utility-Method-l10n"> </a>
</div>
<pre class="listing brush: scala">private def i10n(key : String, args : Object*) = {
 import java.text.{FieldPosition,MessageFormat}
 val formatter = new MessageFormat(S.?(key), S.locale)
 formatter.format(args.toArray, new StringBuffer, new FieldPosition(0)).toString
}
​
// Usage:
&lt;span&gt;{i10n("welcome", new java.util.Date, 6 : Integer)}&lt;/span&gt;
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-D.6">D.6</a> Localized Strings in Templates<a class="IndexReference" name="entry-I18N-Localized-templates-1" href="#index-I18N-Localized-templates">↓</a>
</h2>
<div class="Unindented">
You can add localized strings directly in your templates through the <tt>&lt;lift:loc /&gt;</tt> tag. You can either provide a locid attribute on the tag which is used as the lookup key, or if you don’t provide one, the contents of the tag will be used as the key. In either case, if the key can’t be found in any resource bundles, the contents of the tag will be used. Listing <a class="Reference" href="#lst:Using-the-loc-tag">D.6↓</a> shows some examples of how you could use lift:loc. In both examples, assume that we’re using the resource bundle shown in listing <a class="Reference" href="#lst:Spanish-door-bundle">D.2↑</a>. The fallthrough behavior lets us put a default text (English) directly in the template, although for consistency you should usually provide an explicit bundle for all languages.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Using the loc tag<a class="Label" name="lst:Using-the-loc-tag"> </a>
</div>
<pre class="listing brush: xml">&lt;!-- using explicit key (preferred) --&gt;
&lt;lift:loc locid="openStatus"&gt;The door is open&lt;/lift:loc&gt;
​
&lt;!-- should be the same result, but a missing bundle
     will result in the key being displayed --&gt;
&lt;lift:loc&gt;openStatus&lt;/lift:loc&gt;
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-D.7">D.7</a> Calculating Locale<a class="IndexReference" name="entry-I18N-Calculating-locale-0" href="#index-I18N-Calculating-locale">↓</a><a class="IndexReference" name="entry-Locale-calculating-0" href="#index-Locale-calculating">↓</a>
</h2>
<div class="Unindented">
The <tt>Locale</tt> for a given request is calculated by the function set in<tt> LiftRules.localeCalculator</tt>, a <span class="formula">(<i>Box</i>[<i>HttpServletRequest</i>]) ⇒ <i>Locale</i></span>. The default behavior is to call <tt>getLocale</tt> on the <tt>HTTPRequest</tt>, which allows the server to set it if your clients send locale preferences. If that call returns null, then <tt>Locale.getDefault</tt> is used. You can provide your own function for calculating locales if you desire. 
</div>
<div class="Indented">
Listing <a class="Reference" href="#lst:Calculating-Locale-Based">D.7↓</a> shows how you can use a cookie in addition to a URL query parameter to select the locale for your pages<span class="FootOuter"><span class="SupFootMarker"> [L] </span><span class="HoverFoot"><span class="SupFootMarker"> [L] </span>Thanks to Tim Perret for the original examples at <a class="FlexURL" href="http://blog.getintheloop.eu/2009/7/26/how-to-extensive-localization-with-the-liftweb-framework">http://blog.getintheloop.eu/2009/7/26/how-to-extensive-localization-with-the-liftweb-framework</a></span></span>. This code would be placed in your <tt>Boot.boot</tt> method. Lines 2-3 define some imports beyond the standard imports (see Section <a class="Reference" href="#lst:Standard-import-statements">3.3 on page 1↑</a>). Lines 6-10 define a utility function to convert a language tag string into a <tt>Locale</tt>. Line 13 defines the name of the cookie that will store your locale choice. Lines 15-34 define the partial function that will be used to compute the new <tt>Locale</tt>. First, we only do computation if the <tt>LiftRules.localeCalculator</tt> method is invoked with an <tt>HTTPRequest</tt> (line 16). Our next step is to determine the current locale by checking whether there is an existing locale cookie set (lines 18-20), or by utilizing the default Lift locale calculator (line 21). Our next check is to determine if the user has explicitly requested a locale via a query parameter (line 24). If the parameter is set (and not <tt>null</tt>), we construct a new <tt>Locale</tt> from the value (line 26), set the cookie so that the request is remembered (line 27), and return the new locale. If there is no request parameter then we use the current locale as defined on line 18.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Calculating Locale Based on Cookies and Parameters<a class="Label" name="lst:Calculating-Locale-Based"> </a>
</div>
<pre class="listing brush: scala">// Import the classes we’ll be using beyond the standard imports
import java.util.Locale
import provider.{HTTPCookie,HTTPRequest}
​
// Properly convert a language tag to a Locale
def computeLocale(tag : String) = tag.split(Array(’-’, ’_’)) match {
  case Array(lang) =&gt; new Locale(lang)
  case Array(lang, country) =&gt; new Locale(lang, country)
  case Array(lang, country, variant) =&gt; new Locale(lang, country, variant)
}
​
// Define this to be whatever name you want
val LOCALE_COOKIE_NAME = "SelectedLocale"
​
LiftRules.localeCalculator = {
  case fullReq @ Full(req) =&gt; {
    // Check against a set cookie, or the locale sent in the request 
    def currentLocale : Locale = 
      S.findCookie(LOCALE_COOKIE_NAME).flatMap { 
        cookie =&gt; cookie.value.map(computeLocale) 
      } openOr LiftRules.defaultLocaleCalculator(fullReq)
​
    // Check to see if the user explicitly requests a new locale 
    S.param("locale") match { 
      case Full(requestedLocale) if requestedLocale != null =&gt; { 
        val computedLocale = computeLocale(requestedLocale) 
        S.addCookie(HTTPCookie(LOCALE_COOKIE_NAME, requestedLocale)) 
        computedLocale 
      }
      case _ =&gt; currentLocale 
    } 
  }
  case _ =&gt; Locale.getDefault 
}
</pre>
</div>

</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Appendix-E">E</a> Logging in Lift<a class="Label" name="cha:Logging-in-Lift"> </a>
</h1>
<div class="Unindented">
Logging is a useful part of any application, Lift app or otherwise. Logging can be used to audit user actions, give insight into runtime performance and operation, and even to troubleshoot and debug issues. Lift comes with a thin logging facade that sits on top of the SLF4J library<span class="FootOuter"><span class="SupFootMarker"> [M] </span><span class="HoverFoot"><span class="SupFootMarker"> [M] </span><a class="FlexURL" href="http://www.slf4j.org/">http://www.slf4j.org/</a></span></span>. This facade provides simple access to most common logging functions and aims to be easy to use, flexible, and most important, inconspicuous. If you do decide that Lift’s logging facilities don’t meet your needs, it’s possible to use any Java logging framework you desire, but it’s still useful to understand Lift’s framework since Lift uses it internally for logging.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-E.1">E.1</a> Logging Backend<a class="Label" name="sec:Logging-Backend"> </a>
</h2>
<div class="Unindented">
The detailed configuration of SLF4J is outside the scope of this book, but we would like to highlight a few key notes concerning SLF4J. First, SLF4J splits the API from the implementation into separate JAR files. This allows you to choose the backing implementation that best suits your deployment. For example, SLF4J contains implementations for JDK logging, log4j, and more. For example, the JBoss application server version 5 and newer comes bundled with its own implementation of the SLF4J API, so you can simply deploy a Lift WAR on JBoss and use the server’s configuration and logging. Similarly, Jetty comes bundled with the SLF4J API.
</div>
<div class="Indented">
Outside of container-provided implementations, the logback logging framework<span class="FootOuter"><span class="SupFootMarker"> [N] </span><span class="HoverFoot"><span class="SupFootMarker"> [N] </span><a class="FlexURL" href="http://logback.qos.ch/">http://logback.qos.ch/</a></span></span> is a very nice implementation of the SLF4J API. It’s written by the same people who wrote log4j and has much improved performance and functionality over log4j<span class="FootOuter"><span class="SupFootMarker"> [O] </span><span class="HoverFoot"><span class="SupFootMarker"> [O] </span><a class="FlexURL" href="http://logback.qos.ch/reasonsToSwitch.html">http://logback.qos.ch/reasonsToSwitch.html</a></span></span>. Because logback-classic implements the SLF4J API, you simply need to drop the logback-classic jar into your classpath, or add it as a dependency in your WAR to use it. One particularly nice feature of logback is that if it can’t locate a configuration file (which can be written in XML, Groovy, or soon, Scala), it will default to logging everything to the console.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-E.2">E.2</a> Basic Logging
</h2>
<div class="Unindented">
Logging in Lift is performed via the <tt>net.liftweb.common.Logger</tt> object and trait. The <tt>Logger</tt> object provides a set of utility methods for configuration and instantiation of logger instances. The <tt>Logger</tt> trait can be mixed into your snippet, comet, or other classes to provide direct methods for logging (we’ll cover these in Section <a class="Reference" href="#sub:Logging-Methods">E.2.3↓</a>).
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-E.2.1">E.2.1</a> Logging Setup
</h3>
<div class="Unindented">
The first step in utilizing Lift’s logging is to configure the logger. As we mentioned in Section <a class="Reference" href="#sec:Logging-Backend">E.1↑</a>, Lift uses the SLF4J framework. The configuration of SLF4J depends on which backing implementation you use, but Lift comes with helpers for both log4j (<tt>net.liftweb.common.Log4j</tt>) and for logback (<tt>net.liftweb.common.Logback</tt>). These helpers are utilized with the <tt>Logger</tt> object’s <tt>setup</tt> var. The <tt>Log4j</tt> helpers provides methods that can be used to load a configuration from a <tt>String</tt>, a file (either XML or properties), or with Lift’s default (console) logging. The <tt>Logback</tt> helper provides a single method to load a configuration from an XML file. Listing <a class="Reference" href="#lst:Configuring-Logback-via">E.2.1↓</a> shows how you could use the <tt>Logback</tt> helper in the <tt>Boot.boot</tt> method to configure logging from the <i>logconfig.xml</i> file.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Configuring Logback via Logger.setup<a class="Label" name="lst:Configuring-Logback-via"> </a>
</div>
<pre class="listing brush: scala">def boot {
  // Get a reference to the config from our classpath
  val logUrl = LiftRules.getResource("logconfig.xml")
  
  // Apply the reference, if found
  logUrl.foreach { Logger.setup = Logback.withFile(_) }
  ...
}
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-E.2.2">E.2.2</a> Obtaining a Logger
</h3>
<div class="Unindented">
There are two basic means of obtaining a logger instance. The first is to mix the <tt>Logger</tt> trait into your class. The second is to instantiate a logger using the <tt>Logger</tt> object’s <tt>apply</tt> methods.
</div>
<div class="Indented">
Mixing the <tt>Logger</tt> trait into your class is a very simple way to add logging methods in your code, as shown in Listing. When you do this, the underlying logger will have a name derived from your class’s dynamic type. For example, Listing <a class="Reference" href="#lst:Mixing-Logger-into">E.2.2↓</a> shows the definition of our <tt>Accounts</tt> snippet object with a <tt>Logger</tt> trait mixed in. When we log in the <tt>Accounts</tt> object the name will be the fully-qualified classname, or “com.pocketchangeapp.snippet.Accounts” in our case. When you mix the Logger trait into your class, you can access the logging methods (Section <a class="Reference" href="#sub:Logging-Methods">E.2.3↓</a>) directly.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Mixing Logger into a Class<a class="Label" name="lst:Mixing-Logger-into"> </a>
</div>
<pre class="listing brush: scala">object Accounts extends DispatchSnippet with Logger {
  ...
  warn("This is a warning")
</pre>
</div>

</div>
<div class="Indented">
The second basic way to obtain a logger instance is to construct one directly via the <tt>Logger</tt> object’s <tt>apply</tt> method, as shown in Listing <a class="Reference" href="#lst:Constructing-a-Logger">E.2.2↓</a>. The <tt>apply</tt> method takes either a <tt>String</tt> or <tt>Class</tt> that will be used to determine the constructed logger’s name. In our example, we use the <tt>classOf[Boot]</tt>, so our logger will be named “bootstrap.liftweb.Boot”. When you obtain a logger via construction you need to access the logging methods via the logger instance.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Constructing a Logger instance<a class="Label" name="lst:Constructing-a-Logger"> </a>
</div>
<pre class="listing brush: scala">class Boot {
  // Set up a logger to use for startup messages
  val logger = Logger(classOf[Boot])
  ...
  logger.warn("This is a warning")
</pre>
</div>

</div>
<div class="Indented">
There is a third, hybrid, approach to obtaining a <tt>Logger</tt> that allows you to mix in the <tt>Logger</tt> trait while controlling the logger name. Listing <a class="Reference" href="#lst:Mixing-in-a-named-logger">E.2.2↓</a> shows how we can mix in th trait and then override the underlying SLF4J logger with our own named instance.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Mixing in a named Logger<a class="Label" name="lst:Mixing-in-a-named-logger"> </a>
</div>
<pre class="listing brush: scala">class AddEntry extends StatefulSnippet with Logger {
  // Use a different name for our logger
  import org.slf4j.LoggerFactory
  override val _logger = LoggerFactory.getLogger("EntryEdit") 
</pre>
</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-E.2.3">E.2.3</a> Logging Methods<a class="Label" name="sub:Logging-Methods"> </a>
</h3>
<div class="Unindented">
The <tt>Logger</tt> trait provides some basic log methods which we’ll summarize here. Each log method comes in three forms: one with just a <span class="formula"> ⇒ <i>Object</i></span> argument, one with a <span class="formula"> ⇒ <i>Object</i></span> and <tt>Throwable</tt> argument, and one with a <span class="formula"> ⇒ <i>Object</i></span>, <tt>Throwable</tt>, and <tt>Marker</tt> argument. These correspond roughly to the SLF4J log methods, although the order of the parameters is different and the parameters are passed by-name. Pass-by-name arguments are used so that computation of the log message can be deferred. This is useful to avoid processing messages for log statements below the current logging threshold, a topic we’ll cover more in Section <a class="Reference" href="#sec:Log-Levels">E.3↓</a>.
</div>
<div class="Description">
<span class="Description-entry">trace</span> This logs a message at trace level. Trace level is generally intended for very detailed “tracing” of processing, even more detailed than debug level.
</div>
<div class="Description">
<span class="Description-entry">debug</span> Logs a message at debug level. This level is usually used to output internal variable values or other information that is useful in debugging and troubleshooting an app.
</div>
<div class="Description">
<span class="Description-entry">info</span> Logs a message at info level. This level is appropriate for general information about the app.
</div>
<div class="Description">
<span class="Description-entry">warn</span> Logs a message at warning level. This level should be used for reporting issues that are in error but can be handled cleanly, such as someone trying to submit a character string for a numeric field value.
</div>
<div class="Description">
<span class="Description-entry">error</span> Logs a message at error level. This level should be used for messages relating to errors that can’t be handled cleanly, such as a failure to connect to a backing database.
</div>
<div class="Description">
<span class="Description-entry">assertLog</span> This allows you to test an assertion condition and if true, logs the assertion as well as a given message.
</div>
<div class="Unindented">
Listing <a class="Reference" href="#lst:Some-example-logging">E.2.3↓</a> shows our REST API authentication hook, which uses a few different Logging methods within the handler method.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Some example logging<a class="Label" name="lst:Some-example-logging"> </a>
</div>
<pre class="listing brush: scala">LiftRules.authentication = HttpBasicAuthentication("PocketChange") {
  case (userEmail, userPass, _) =&gt; {
    logger.debug("Authenticating: " + userEmail)
    User.find(By(User.email, userEmail)).map { user =&gt;
      if (user.password.match_?(userPass)) {
        logger.info("Auth succeeded for " + userEmail)
        User.logUserIn(user)
​
        // Set an MDC for logging purposes
        MDC.put("user", user.shortName)
​
        // Compute all of the user roles
        userRoles(user.editable.map(acct =&gt; AuthRole("editAcct:" + acct.id)) ++
                  user.allAccounts.map(acct =&gt; AuthRole("viewAcct:" + acct.id)))
        true
      } else {
        logger.warn("Auth failed for " + userEmail)
        false
      }
    } openOr false
  }
}
</pre>
</div>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-E.3">E.3</a> Log Level Guards<a class="Label" name="sec:Log-Levels"> </a>
</h2>
<div class="Unindented">
We want to provide a brief discussion on the use of log guards and why they’re usually not needed with Lift’s log framework. A log guard is a simple test to see if a given log statement will actually be processed. The Log object provides a test method (returning a boolean) for each log level:
</div>
<ul>
<li>
isDebugEnabled
</li>
<li>
isErrorEnabled
</li>
<li>
isInfoEnabled
</li>
<li>
isTraceEnabled
</li>
<li>
isWarnEnabled
</li>

</ul>
<div class="Unindented">
Log guards are fairly common in logging frameworks to avoid expensive computation of log message that won’t actually be used. This is particularly relevant with debug logging, since they often cover a large section of code and usually aren’t enabled in production. The Log object can implicitly do log guards for you because of the pass-by-name message parameters. As we showed in listing <a class="Reference" href="#lst:Some-example-logging">E.2.3↑</a>, simply converting your log message into a closure allows the Log object decide whether to execute the closure based on the current log level. You get the flexibility and simplicity of adding log statements anywhere you want without explicit log guards, without losing the performance benefit of the guards. To explain it a bit more, let’s assume for instace that the <tt>debug</tt> method would have been declared as <tt>def debug(msg:AnyRef): Unit. </tt>When <tt>debug</tt> would be called the parameter will be first evaluated and then passed to the method. Inside the method we have the test to see if the debug level is enabled to know if we actaully need to trace that message or not. Well in this case even if the debugging level is turned off we still have the evaluation of the parameters and that leads to unnecessary computing and in an application that uses logging heavily that would likely lead to a performance impact.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-E.4">E.4</a> Logging Mapper Queries<a class="Label" name="sec:Logging-Mapper-Queries"> </a>
</h2>
<div class="Unindented">
If you want to log Mapper query activity, there are two main approaches. The first is to utilize the <tt>net.liftweb.mapper.DB.addLogFunc</tt> method to add your own logging function. A logging function is of the type <span class="formula">(<i>DBLog</i>, <i>Long</i>) ⇒ <i>Any</i></span>. The <tt>DBLog</tt> trait contains two separate lists of log entries, one for meta operations (such as <tt>getFetchSize</tt>) and one for actual work statements (such as <tt>executeQuery</tt>). You can access these two log lists via either the <tt>metaEntries</tt> or <tt>statementEntries</tt> methods. You can also access the entire list of both types via the <tt>allEntries</tt> method. Listing <a class="Reference" href="#lst:Basic-Mapper-Logging">E.4↓</a> shows how we can hook a log function in the <tt>Boot.boot</tt> method to log Mapper activity for each request.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Basic Mapper Logging<a class="Label" name="lst:Basic-Mapper-Logging"> </a>
</div>
<pre class="listing brush: scala">// Add a query logger
DB.addLogFunc {
  case (log, duration) =&gt; {
    logger.debug("Total query time : %d ms".format(duration))
    log.allEntries.foreach {
      case DBLogEntry(stmt,duration) =&gt;
        logger.debug("  %s in %d ms".format(stmt, duration))
    }
  }
}
</pre>
</div>

</div>
<div class="Indented">
Another approach to logging Mapper queries is to use the <tt>DB.queryCollector</tt> logging function and then either use <tt>S.queryLog</tt> to access the query log, or hook into <tt>S.addAnalyzer</tt>. Listing <a class="Reference" href="#lst:Mapper-Logging-via-S-queryLog">E.4↓</a> shows how we could use this instead for our logging in <tt>Boot.boot</tt>.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Mapper Logging via S.queryLog<a class="Label" name="lst:Mapper-Logging-via-S-queryLog"> </a>
</div>
<pre class="listing brush: scala">// Add a query logger (via S.queryLog)
DB.addLogFunc(DB.queryCollector)
​
S.addAnalyzer {
  case (Full(req), duration, log) =&gt; {
    logger.debug(("Total request time on %s: %d ms").format(req.uri, duration))
    log.foreach {
      case (stmt,duration) =&gt;
        logger.debug("  %s in %d ms".format(stmt, duration))
    }
  }
  case _ =&gt; // we don’t log for non-requests
}
</pre>
</div>

</div>
<div class="Indented">
Note that the duration you get when your analyzer function is called is the time spent in <tt>S</tt>, not necessarily the total duration of your queries. Also, only work statements are logged via <tt>S.queryLog</tt>. If you want meta entries you’ll have to use a direct logging function as in Listing <a class="Reference" href="#lst:Basic-Mapper-Logging">E.4↑</a>.
</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Appendix-F">F</a> Sending Email<a class="Label" name="cha:Sending-Email"> </a>
</h1>
<div class="Unindented">
Sending email is a common enough task (user registration, notifications, etc) within a web application that we’ve decided to cover it here. Although email isn’t Lift’s primary focus, Lift does provide some facilities to simplify email transmission.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-F.1">F.1</a> Setup
</h2>
<div class="Unindented">
Configuration of the mailer is handled in a few different ways. The <tt>net.liftweb.util.Mailer</tt> object defines a <tt>hostFunc</tt> function var, <span class="formula">() ⇒ <i>String</i></span>, that is used to compute the hostname of your SMTP server to be used for transmission. The default value is a function that looks up the <tt>mail.smtp.host</tt> system property and uses that String. If that property isn’t defined then the mailer defaults to <tt>localhost</tt>. Setting the system property is the simplest way to change your SMTP relay, although you could also define your own function to return a custom hostname and assign it to <tt>Mailer.hostFunc</tt>.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-F.2">F.2</a> Sending Emails
</h2>
<div class="Unindented">
The mailer interface is simple but covers a wide variety of cases. The <tt>Mailer</tt> object defines a number of case classes that correspond to the components of an RFC822 email. The addressing and subject cases classes, <tt>From</tt>, <tt>To</tt>, <tt>CC</tt>, <tt>BCC</tt>, <tt>ReplyTo</tt> and <tt>Subject</tt> should all be self-explanatory. For the body of the email you have three main options:
</div>
<div class="Description">
<span class="Description-entry">PlainMailBodyType</span> Represents a plain-text email body based on a given String
</div>
<div class="Description">
<span class="Description-entry">XHTMLMailBodyType</span> Represents an XHTML email body based on a given NodeSeq
</div>
<div class="Description">
<span class="Description-entry">XHTMLPlusImages</span> Similar to XHTMLMailBodyType, but in addition to the NodeSeq, you can provide one or more PlusImageHolder instances that represent images to be attached to the email (embedded images, so to speak)
</div>
<div class="Unindented">
The <tt>Mailer.sendMail</tt> function is used to generate and send an email. It takes three arguments: the <tt>From</tt> sender address, the <tt>Subject</tt> of the email, and a varargs list of recipient addresses and body components. The mailer creates MIME/Multipart messages, so you can send more than one body (i.e. plain text and XHMTL) if you would like. Listing <a class="Reference" href="#lst:Sending-a-two-part-email">F.2↓</a> shows an example of sending an email to a group of recipients in both plain text and XHTML format. The Mailer object defines some implicit conversions to PlainMailBodyType and XHTMLMailBodyType, which we use here. We also have to do a little List trickery to be able to squeeze multiple arguments into the final vararg argument since Scala doesn’t support mixing regular values and coerced sequences in vararg arguments.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
Sending a two-part email<a class="Label" name="lst:Sending-a-two-part-email"> </a>
</div>
<pre class="listing brush: scala">import net.liftweb.util.Mailer
import Mailer._
...
val myRecips : List[String] = ...
val plainContent : String = "..."
val xhtmlContent : NodeSeq = ...
​
Mailer.sendMail(From("no-reply@foo.com"), Subject("Just a test"),
                (plainContent :: xhtmlContent :: myRecips.map(To(_))) : _*)
</pre>
</div>

</div>
<div class="Indented">
When you call <tt>sendMail</tt> you’re actually sending a message to an actor in the background that will handle actual mail delivery; because of this, you shouldn’t expect to see a synchronous relay of the message through your SMTP server.
</div>
<div class="Indented">

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Appendix-G">G</a> JPA Code Listings<a class="Label" name="cha:Code-Listings"> </a>
</h1>
<div class="Unindented">
To conserve space and preserve flow in the main text, we’ve placed full code listings for the JPA chapter in this appendix.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-G.1">G.1</a> JPA Library Demo
</h2>
<div class="Unindented">
The full library demo is available under the main Lift Git repository at <a class="FlexURL" href="http://github.com/lift/lift/tree/master/examples/JPADemo/">http://github.com/lift/lift/tree/master/examples/JPADemo/</a>. To illustrate some points, we’ve included selected listings from the project.
</div>
<div class="Indented">
<p><br/>
</p>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-G.1.1">G.1.1</a> Author Entity
</h3>
<div class="Unindented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:Author.scala"> </a>Author.scala
</div>
<pre class="listing brush: scala">package com.foo.jpaweb.model
​
import javax.persistence._
​
/**
  An author is someone who writes books.
*/
@Entity
class Author {
  @Id
  @GeneratedValue(){val strategy = GenerationType.AUTO}
  var id : Long = _
​
  @Column{val unique = true, val nullable = false}
  var name : String = ""
​
  @OneToMany(){val mappedBy = "author", val targetEntity = classOf[Book], 
               val cascade = Array(CascadeType.REMOVE)}
  var books : java.util.Set[Book] = new java.util.HashSet[Book]()
}
​
</pre>
</div>

</div>
<div class="Indented">
<p><br/>
</p>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-G.1.2">G.1.2</a> orm.xml<a class="IndexReference" name="entry-orm.xml-2" href="#index-orm.xml">↓</a> Mapping
</h3>
<div class="Unindented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:orm.xml"> </a>orm.xml
</div>
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;<pre class="listing brush: xml">&lt;entity-mappings xmlns="http://java.sun.com/xml/ns/persistence/orm"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/persistence/orm
        http://java.sun.com/xml/ns/persistence/orm_1_0.xsd" version="1.0"&gt;
​
  &lt;package&gt;com.foo.jpaweb.model&lt;/package&gt;
​
  &lt;entity class="Book"&gt;
    &lt;named-query name="findBooksByAuthor"&gt;
      &lt;query&gt;&lt;![CDATA[from Book b where b.author.id = :id order by b.title]]&gt;&lt;/query&gt;
    &lt;/named-query&gt;
    &lt;named-query name="findBooksByDate"&gt;
      &lt;query&gt;&lt;![CDATA[from Book b where b.published between :startDate and :endDate]]&gt;&lt;/query&gt;
    &lt;/named-query&gt;
    &lt;named-query name="findBooksByTitle"&gt;
      &lt;query&gt;&lt;![CDATA[from Book b where lower(b.title) like :title order by b.title]]&gt;&lt;/query&gt;
    &lt;/named-query&gt;
    &lt;named-query name="findAllBooks"&gt;
      &lt;query&gt;&lt;![CDATA[from Book b order by b.title]]&gt;&lt;/query&gt;
    &lt;/named-query&gt;
  &lt;/entity&gt;
​
  &lt;entity class="Author"&gt;
    &lt;named-query name="findAllAuthors"&gt;
      &lt;query&gt;&lt;![CDATA[from Author a order by a.name]]&gt;&lt;/query&gt;
    &lt;/named-query&gt;
  &lt;/entity&gt;
​
&lt;/entity-mappings&gt;
</pre>
</div>

</div>
<div class="Indented">
<p><br/>
</p>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-G.1.3">G.1.3</a> Enumv Trait
</h3>
<div class="Unindented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:Enumv-Trait"> </a>Enumv Trait
</div>
package com.foo.jpaweb.model<pre class="listing brush: scala">​
/* adds a valueOf function, assumes name is defined
add optional description */
trait Enumv  {
  
  this: Enumeration =&gt;
​
  private var nameDescriptionMap = scala.collection.mutable.Map[String, String]()
​
  /* store a name and description for forms */
  def Value(name: String, desc: String) : Value = {
    nameDescriptionMap += (name -&gt; desc)
    new Val(name)
  }
  
    /* get description if it exists else name */
  def getDescriptionOrName(ev: this.Value) = {
    try {
      nameDescriptionMap(""+ev)
    } catch {
      case e: NoSuchElementException =&gt; ev.toString
    }
  }
​
  /* get name description pair list for forms */
  def getNameDescriptionList =  this.elements.toList.map(v =&gt; (v.toString, getDescriptionOrName(v) ) ).toList
​
  /* get the enum given a string */
  def valueOf(str: String) = this.elements.toList.filter(_.toString == str) match {
    case Nil =&gt; null
    case x =&gt; x.head
  }
}
</pre>
</div>

</div>
<div class="Indented">
<p><br/>
</p>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-G.1.4">G.1.4</a> EnumerationType
</h3>
<div class="Unindented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:EnumvType"> </a>EnumvType class
</div>
package com.foo.jpaweb.model<pre class="listing brush: scala">​
import java.io.Serializable
import java.sql.PreparedStatement
import java.sql.ResultSet
import java.sql.SQLException
import java.sql.Types
​
import org.hibernate.HibernateException
import org.hibernate.usertype.UserType
​
/**
 * Helper class to translate enum for hibernate
 */
abstract class EnumvType(val et: Enumeration with Enumv) extends UserType {
  
  val SQL_TYPES = Array({Types.VARCHAR})
​
  override def sqlTypes() = SQL_TYPES
​
  override def returnedClass = classOf[et.Value]
​
  override def equals(x: Object, y: Object): Boolean = {
    return x == y
  }
​
  override def hashCode(x: Object) = x.hashCode
​
  override def nullSafeGet(resultSet: ResultSet, names: Array[String], owner: Object): Object = {
    val value = resultSet.getString(names(0))
    if (resultSet.wasNull()) return null
    else {
      return et.valueOf(value)
    }
  }
  
  override def nullSafeSet(statement: PreparedStatement, value: Object, index: Int): Unit = {
    if (value == null) {
      statement.setNull(index, Types.VARCHAR)
    } else {
      val en = value.toString
      statement.setString(index, en)
    }
  }
​
  override def deepCopy(value: Object): Object = value
​
  override def isMutable() = false
    
  override def disassemble(value: Object) = value.asInstanceOf[Serializable]
​
  override def assemble(cached: Serializable, owner: Object): Serializable = cached
​
  override def replace(original: Object, target: Object, owner: Object) = original
​
}
</pre>
</div>

</div>
<div class="Indented">
<p><br/>
</p>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-G.1.5">G.1.5</a> JPA web.xml<a class="IndexReference" name="entry-web.xml-2" href="#index-web.xml">↓</a>
</h3>
<div class="Unindented">
This shows the LiftFilter setup as well as the persistence-context-ref.
</div>
<div class="Indented">
<div class="listing">
<div class="caption">
<a class="Label" name="lst:JPA-web.xml"> </a>JPA web.xml
</div>
<pre class="listing brush: xml">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
​
&lt;!DOCTYPE web-app
PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
"http://java.sun.com/j2ee/dtds/web-app_2_3.dtd"&gt;
​
&lt;web-app&gt;
&lt;filter&gt;
  &lt;filter-name&gt;LiftFilter&lt;/filter-name&gt;
  &lt;display-name&gt;Lift Filter&lt;/display-name&gt;
  &lt;description&gt;The Filter that intercepts lift calls&lt;/description&gt;
  &lt;filter-class&gt;net.liftweb.http.LiftFilter&lt;/filter-class&gt;
  &lt;persistence-context-ref&gt;
    &lt;description&gt;
      Persistence context for the library app
    &lt;/description&gt;
    &lt;persistence-context-ref-name&gt;
      persistence/jpaweb
    &lt;/persistence-context-ref-name&gt;
    &lt;persistence-unit-name&gt;
      jpaweb
    &lt;/persistence-unit-name&gt;
  &lt;/persistence-context-ref&gt;
&lt;/filter&gt;
        
​
&lt;filter-mapping&gt;
  &lt;filter-name&gt;LiftFilter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
​
&lt;/web-app&gt;
​
</pre>
</div>

</div>
<a class="toc" name="Index"></a><h1 class="index">Index</h1><p class="printindex">
<a class="printindex" name="index-AJAX"></a>AJAX: 
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-AJAX-anchor-tag"></a>anchor tag: <a class="IndexArrow" href="#entry-AJAX-anchor-tag-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-Attributes"></a>Attributes: <a class="IndexArrow" href="#entry-Attributes-0">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-Attributes-%-operator"></a>% operator: <a class="IndexArrow" href="#entry-Attributes-%-operator-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Attributes--%&gt;-operator"></a>-%&gt; operator: <a class="IndexArrow" href="#entry-Attributes--%&gt;-operator-0">↑</a>, <a class="IndexArrow" href="#entry-Attributes--%&gt;-operator-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Attributes-binding"></a>binding: <a class="IndexArrow" href="#entry-Attributes-binding-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Attributes-computing-via-snippet"></a>computing via snippet: <a class="IndexArrow" href="#entry-Attributes-computing-via-snippet-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Attributes-delete-with-CSS-transform"></a>delete with CSS transform: <a class="IndexArrow" href="#entry-Attributes-delete-with-CSS-transform-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Attributes-discarded-in-bind"></a>discarded in bind: <a class="IndexArrow" href="#entry-Attributes-discarded-in-bind-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Attributes-in-form-elements"></a>in form elements: <a class="IndexArrow" href="#entry-Attributes-in-form-elements-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Attributes-retrieving-from-elements"></a>retrieving from elements: <a class="IndexArrow" href="#entry-Attributes-retrieving-from-elements-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-Authentication"></a>Authentication: <a class="IndexArrow" href="#entry-Authentication-0">↑</a>, <a class="IndexArrow" href="#entry-Authentication-1">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-Authentication-JAAS"></a>JAAS: <a class="IndexArrow" href="#entry-Authentication-JAAS-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-Autoconversion"></a>Autoconversion: <a class="IndexArrow" href="#entry-Autoconversion-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Binding"></a>Binding: <a class="IndexArrow" href="#entry-Binding-0">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-Binding-with-CSS"></a>with CSS: <a class="IndexArrow" href="#entry-Binding-with-CSS-0">↑</a>, <a class="IndexArrow" href="#entry-Binding-with-CSS-1">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-Boot"></a>Boot: <a class="IndexArrow" href="#entry-Boot-0">↑</a>, <a class="IndexArrow" href="#entry-Boot-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Bootstrap"></a>Bootstrap: <a class="IndexArrow" href="#entry-Bootstrap-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-By"></a>By: <a class="IndexArrow" href="#entry-By-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-ByList"></a>ByList: <a class="IndexArrow" href="#entry-ByList-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-ByRef"></a>ByRef: <a class="IndexArrow" href="#entry-ByRef-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-By_&gt;"></a>By_&gt;: <a class="IndexArrow" href="#entry-By_&gt;-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-By_&lt;"></a>By_&lt;: <a class="IndexArrow" href="#entry-By_&lt;-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-CGI"></a>CGI: <a class="IndexArrow" href="#entry-CGI-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-CMP"></a>CMP: <a class="IndexArrow" href="#entry-CMP-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-CSS"></a>CSS: <a class="IndexArrow" href="#entry-CSS-0">↑</a>, <a class="IndexArrow" href="#entry-CSS-1">↑</a>, <a class="IndexArrow" href="#entry-CSS-2">↑</a>, <a class="IndexArrow" href="#entry-CSS-3">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-CSS-selector-transforms"></a>selector transforms: <a class="IndexArrow" href="#entry-CSS-selector-transforms-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-CSS-Transforms"></a>CSS Transforms: <a class="IndexArrow" href="#entry-CSS-Transforms-0">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-CSS-Transforms-attribute-copying"></a>attribute copying: <a class="IndexArrow" href="#entry-CSS-Transforms-attribute-copying-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-CSS-Transforms-attribute-replacement"></a>attribute replacement: <a class="IndexArrow" href="#entry-CSS-Transforms-attribute-replacement-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-CSS-Transforms-deleting-attribute"></a>deleting attribute: <a class="IndexArrow" href="#entry-CSS-Transforms-deleting-attribute-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-Calendar"></a>Calendar: <a class="IndexArrow" href="#entry-Calendar-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Comet"></a>Comet: <a class="IndexArrow" href="#entry-Comet-0">↑</a>, <a class="IndexArrow" href="#entry-Comet-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Custom-dispatch"></a>Custom dispatch: 
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-Custom-dispatch-per-session"></a>per-session: <a class="IndexArrow" href="#entry-Custom-dispatch-per-session-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Custom-dispatch-stateful"></a>stateful: <a class="IndexArrow" href="#entry-Custom-dispatch-stateful-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Custom-dispatch-stateless"></a>stateless: <a class="IndexArrow" href="#entry-Custom-dispatch-stateless-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-Designer-friendly-templates"></a>Designer-friendly templates: <a class="IndexArrow" href="#entry-Designer-friendly-templates-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-DispatchSnippet"></a>DispatchSnippet: <a class="IndexArrow" href="#entry-DispatchSnippet-0">↑</a>, <a class="IndexArrow" href="#entry-DispatchSnippet-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-EntityManager"></a>EntityManager: <a class="IndexArrow" href="#entry-EntityManager-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Extraction"></a>Extraction: <a class="IndexArrow" href="#entry-Extraction-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-File-uploads"></a>File uploads: <a class="IndexArrow" href="#entry-File-uploads-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Forms"></a>Forms: <a class="IndexArrow" href="#entry-Forms-0">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-Forms-File-uploads"></a>File uploads: <a class="IndexArrow" href="#entry-Forms-File-uploads-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Forms-file-upload"></a>file upload: <a class="IndexArrow" href="#entry-Forms-file-upload-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Forms-multipart"></a>multipart: <a class="IndexArrow" href="#entry-Forms-multipart-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Forms-saving-file-uploads-to-disk"></a>saving file uploads to disk: <a class="IndexArrow" href="#entry-Forms-saving-file-uploads-to-disk-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Forms-snippet-tag"></a>snippet tag: <a class="IndexArrow" href="#entry-Forms-snippet-tag-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-Git"></a>Git: <a class="IndexArrow" href="#entry-Git-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-HTML"></a>HTML: 
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-HTML-Version-5"></a>Version 5: <a class="IndexArrow" href="#entry-HTML-Version-5-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-HTML5"></a>HTML5: <a class="IndexArrow" href="#entry-HTML5-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-HTTP"></a>HTTP: 
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-HTTP-authentication"></a>authentication: <a class="IndexArrow" href="#entry-HTTP-authentication-0">↑</a>, <a class="IndexArrow" href="#entry-HTTP-authentication-1">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-Hibernate"></a>Hibernate: <a class="IndexArrow" href="#entry-Hibernate-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-HttpServletRequest"></a>HttpServletRequest: <a class="IndexArrow" href="#entry-HttpServletRequest-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-I18N"></a>I18N: <a class="IndexArrow" href="#entry-I18N-0">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-I18N-Calculating-locale"></a>Calculating locale: <a class="IndexArrow" href="#entry-I18N-Calculating-locale-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-I18N-Localized-templates"></a>Localized templates: <a class="IndexArrow" href="#entry-I18N-Localized-templates-0">↑</a>, <a class="IndexArrow" href="#entry-I18N-Localized-templates-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-I18N-Resource-bundle-resolution"></a>Resource bundle resolution: <a class="IndexArrow" href="#entry-I18N-Resource-bundle-resolution-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-I18N-whitespace-in-keys"></a>whitespace in keys: <a class="IndexArrow" href="#entry-I18N-whitespace-in-keys-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-IHaveValidatedThisSQL"></a>IHaveValidatedThisSQL: <a class="IndexArrow" href="#entry-IHaveValidatedThisSQL-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-If"></a>If: <a class="IndexArrow" href="#entry-If-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-In"></a>In: <a class="IndexArrow" href="#entry-In-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-InMemoryFileParamHolder"></a>InMemoryFileParamHolder: <a class="IndexArrow" href="#entry-InMemoryFileParamHolder-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-InMemoryResponse"></a>InMemoryResponse: <a class="IndexArrow" href="#entry-InMemoryResponse-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-InRaw"></a>InRaw: <a class="IndexArrow" href="#entry-InRaw-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-IndexedField"></a>IndexedField: <a class="IndexArrow" href="#entry-IndexedField-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-InsecureLiftView"></a>InsecureLiftView: <a class="IndexArrow" href="#entry-InsecureLiftView-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Internationalization---see-I18N"></a>Internationalization | see I18N: <a class="IndexArrow" href="#entry-Internationalization---see-I18N-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-JPA"></a>JPA: <a class="IndexArrow" href="#entry-JPA-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-JPOX"></a>JPOX: <a class="IndexArrow" href="#entry-JPOX-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-JSON"></a>JSON: 
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-JSON-extraction"></a>extraction: <a class="IndexArrow" href="#entry-JSON-extraction-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-KeyedMapper"></a>KeyedMapper: <a class="IndexArrow" href="#entry-KeyedMapper-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-KeyedMetaMapper"></a>KeyedMetaMapper: <a class="IndexArrow" href="#entry-KeyedMetaMapper-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Lift-2.2"></a>Lift 2.2: <a class="IndexArrow" href="#entry-Lift-2.2-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-LiftResponse"></a>LiftResponse: <a class="IndexArrow" href="#entry-LiftResponse-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-LiftRules"></a>LiftRules: <a class="IndexArrow" href="#entry-LiftRules-0">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-LiftRules-dispatch"></a>dispatch: <a class="IndexArrow" href="#entry-LiftRules-dispatch-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-LiftRules-statelessDispatchTable"></a>statelessDispatchTable: <a class="IndexArrow" href="#entry-LiftRules-statelessDispatchTable-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-LiftView"></a>LiftView: <a class="IndexArrow" href="#entry-LiftView-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Like"></a>Like: <a class="IndexArrow" href="#entry-Like-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Locale"></a>Locale: 
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-Locale-calculating"></a>calculating: <a class="IndexArrow" href="#entry-Locale-calculating-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-MVC"></a>MVC: <a class="IndexArrow" href="#entry-MVC-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Map"></a>Map: <a class="IndexArrow" href="#entry-Map-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Mapper"></a>Mapper: <a class="IndexArrow" href="#entry-Mapper-0">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-Mapper-asJs"></a>asJs: <a class="IndexArrow" href="#entry-Mapper-asJs-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Mapper-multiple-databases"></a>multiple databases: <a class="IndexArrow" href="#entry-Mapper-multiple-databases-0">↑</a>, <a class="IndexArrow" href="#entry-Mapper-multiple-databases-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Mapper-toXml"></a>toXml: <a class="IndexArrow" href="#entry-Mapper-toXml-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-Maven"></a>Maven: <a class="IndexArrow" href="#entry-Maven-0">↑</a>, <a class="IndexArrow" href="#entry-Maven-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Menu.title"></a>Menu.title: <a class="IndexArrow" href="#entry-Menu.title-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-MetaMapper"></a>MetaMapper: <a class="IndexArrow" href="#entry-MetaMapper-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-MetaRecord"></a>MetaRecord: <a class="IndexArrow" href="#entry-MetaRecord-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-NodeSeq"></a>NodeSeq: <a class="IndexArrow" href="#entry-NodeSeq-0">↑</a>, <a class="IndexArrow" href="#entry-NodeSeq-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-NotBy"></a>NotBy: <a class="IndexArrow" href="#entry-NotBy-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-NotNullRef"></a>NotNullRef: <a class="IndexArrow" href="#entry-NotNullRef-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-NullRef"></a>NullRef: <a class="IndexArrow" href="#entry-NullRef-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-OnDiskFileParamHolder"></a>OnDiskFileParamHolder: <a class="IndexArrow" href="#entry-OnDiskFileParamHolder-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Override-form-template"></a>Override form template: <a class="IndexArrow" href="#entry-Override-form-template-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Parameters"></a>Parameters: <a class="IndexArrow" href="#entry-Parameters-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-ParsePath"></a>ParsePath: <a class="IndexArrow" href="#entry-ParsePath-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-PreCache"></a>PreCache: <a class="IndexArrow" href="#entry-PreCache-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-RESTful"></a>RESTful: <a class="IndexArrow" href="#entry-RESTful-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Record"></a>Record: <a class="IndexArrow" href="#entry-Record-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-RedirectWithState"></a>RedirectWithState: <a class="IndexArrow" href="#entry-RedirectWithState-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Reflection"></a>Reflection: <a class="IndexArrow" href="#entry-Reflection-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-RequestVar"></a>RequestVar: <a class="IndexArrow" href="#entry-RequestVar-0">↑</a>, <a class="IndexArrow" href="#entry-RequestVar-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-RewriteResponse"></a>RewriteResponse: <a class="IndexArrow" href="#entry-RewriteResponse-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-S"></a>S: <a class="IndexArrow" href="#entry-S-0">↑</a>, <a class="IndexArrow" href="#entry-S-1">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-S-addHighLevelSessionDispatcher"></a>addHighLevelSessionDispatcher: <a class="IndexArrow" href="#entry-S-addHighLevelSessionDispatcher-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-S.param"></a>S.param: <a class="IndexArrow" href="#entry-S.param-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-SHtml"></a>SHtml: <a class="IndexArrow" href="#entry-SHtml-0">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-SHtml-a"></a>a: <a class="IndexArrow" href="#entry-SHtml-a-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-Scala"></a>Scala: <a class="IndexArrow" href="#entry-Scala-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Schemifier"></a>Schemifier: <a class="IndexArrow" href="#entry-Schemifier-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-SessionVar"></a>SessionVar: <a class="IndexArrow" href="#entry-SessionVar-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-SiteMap"></a>SiteMap: <a class="IndexArrow" href="#entry-SiteMap-0">↑</a>, <a class="IndexArrow" href="#entry-SiteMap-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Snippet-parameters"></a>Snippet parameters: <a class="IndexArrow" href="#entry-Snippet-parameters-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Snippets"></a>Snippets: <a class="IndexArrow" href="#entry-Snippets-0">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-Snippets-Dispatch"></a>Dispatch: <a class="IndexArrow" href="#entry-Snippets-Dispatch-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Snippets-Explicit-Dispatch"></a>Explicit Dispatch: <a class="IndexArrow" href="#entry-Snippets-Explicit-Dispatch-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Snippets-Implicit-dispatch"></a>Implicit dispatch: <a class="IndexArrow" href="#entry-Snippets-Implicit-dispatch-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Snippets-Per-request-remapping"></a>Per-request remapping: <a class="IndexArrow" href="#entry-Snippets-Per-request-remapping-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Snippets-binding"></a>binding: <a class="IndexArrow" href="#entry-Snippets-binding-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Snippets-binding-with-CSS"></a>binding with CSS: <a class="IndexArrow" href="#entry-Snippets-binding-with-CSS-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Snippets-eager_eval"></a>eager_eval: <a class="IndexArrow" href="#entry-Snippets-eager_eval-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Snippets-explicit-dispatch-with-StatefulSnippet"></a>explicit dispatch with StatefulSnippet: <a class="IndexArrow" href="#entry-Snippets-explicit-dispatch-with-StatefulSnippet-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Snippets-invoking-via-class-attributes"></a>invoking via class attributes: <a class="IndexArrow" href="#entry-Snippets-invoking-via-class-attributes-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Snippets-stateful"></a>stateful: <a class="IndexArrow" href="#entry-Snippets-stateful-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Snippets-stateful-vs-stateless"></a>stateful vs stateless: <a class="IndexArrow" href="#entry-Snippets-stateful-vs-stateless-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-StatefulSnippet"></a>StatefulSnippet: <a class="IndexArrow" href="#entry-StatefulSnippet-0">↑</a>, <a class="IndexArrow" href="#entry-StatefulSnippet-1">↑</a>, <a class="IndexArrow" href="#entry-StatefulSnippet-2">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-StatefulSnippet-explicit-dispatch"></a>explicit dispatch: <a class="IndexArrow" href="#entry-StatefulSnippet-explicit-dispatch-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-Tags"></a>Tags: 
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-Tags-CSS"></a>CSS: <a class="IndexArrow" href="#entry-Tags-CSS-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Tags-a"></a>a: <a class="IndexArrow" href="#entry-Tags-a-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Tags-bind"></a>bind: <a class="IndexArrow" href="#entry-Tags-bind-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Tags-bind-at"></a>bind-at: <a class="IndexArrow" href="#entry-Tags-bind-at-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Tags-children"></a>children: <a class="IndexArrow" href="#entry-Tags-children-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Tags-comet"></a>comet: <a class="IndexArrow" href="#entry-Tags-comet-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Tags-embed"></a>embed: <a class="IndexArrow" href="#entry-Tags-embed-0">↑</a>, <a class="IndexArrow" href="#entry-Tags-embed-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Tags-snippet"></a>snippet: <a class="IndexArrow" href="#entry-Tags-snippet-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Tags-surround"></a>surround: <a class="IndexArrow" href="#entry-Tags-surround-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-Templates"></a>Templates: <a class="IndexArrow" href="#entry-Templates-0">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-Templates-Designer-friendly"></a>Designer-friendly: <a class="IndexArrow" href="#entry-Templates-Designer-friendly-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Templates-HTML5"></a>HTML5: <a class="IndexArrow" href="#entry-Templates-HTML5-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Templates-content-element"></a>content element: <a class="IndexArrow" href="#entry-Templates-content-element-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Templates-embedded"></a>embedded: <a class="IndexArrow" href="#entry-Templates-embedded-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-Title"></a>Title: <a class="IndexArrow" href="#entry-Title-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-TopLink"></a>TopLink: <a class="IndexArrow" href="#entry-TopLink-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Transactions"></a>Transactions: <a class="IndexArrow" href="#entry-Transactions-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Type"></a>Type: <a class="IndexArrow" href="#entry-Type-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-URL-rewriting"></a>URL rewriting: <a class="IndexArrow" href="#entry-URL-rewriting-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Unless"></a>Unless: <a class="IndexArrow" href="#entry-Unless-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Validation"></a>Validation: <a class="IndexArrow" href="#entry-Validation-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-View-First"></a>View-First: <a class="IndexArrow" href="#entry-View-First-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Views"></a>Views: <a class="IndexArrow" href="#entry-Views-0">↑</a>, <a class="IndexArrow" href="#entry-Views-1">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-Views-Explicit-dispatch"></a>Explicit dispatch: <a class="IndexArrow" href="#entry-Views-Explicit-dispatch-0">↑</a>, <a class="IndexArrow" href="#entry-Views-Explicit-dispatch-1">↑</a>, <a class="IndexArrow" href="#entry-Views-Explicit-dispatch-2">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Views-Implicit-dispatch"></a>Implicit dispatch: <a class="IndexArrow" href="#entry-Views-Implicit-dispatch-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-Views-Reflection-dispatch"></a>Reflection dispatch: <a class="IndexArrow" href="#entry-Views-Reflection-dispatch-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-XHTML"></a>XHTML: <a class="IndexArrow" href="#entry-XHTML-0">↑</a>, <a class="IndexArrow" href="#entry-XHTML-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-XML"></a>XML: <a class="IndexArrow" href="#entry-XML-0">↑</a>, <a class="IndexArrow" href="#entry-XML-1">↑</a>
</p>
<div class="indexgroup">
<p class="printindex">
<a class="printindex" name="index-XML-attribute-handling"></a>attribute handling: <a class="IndexArrow" href="#entry-XML-attribute-handling-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-XML-attributes"></a>attributes: <a class="IndexArrow" href="#entry-XML-attributes-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-XML-preserving-attributes"></a>preserving attributes: <a class="IndexArrow" href="#entry-XML-preserving-attributes-0">↑</a>
</p>

</div>
<p class="printindex">
<a class="printindex" name="index-_id_&gt;-operator"></a>_id_&gt; operator: <a class="IndexArrow" href="#entry-_id_&gt;-operator-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-anchor"></a>anchor: <a class="IndexArrow" href="#entry-anchor-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-annotations"></a>annotations: <a class="IndexArrow" href="#entry-annotations-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-bind"></a>bind: <a class="IndexArrow" href="#entry-bind-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-binding"></a>binding: <a class="IndexArrow" href="#entry-binding-0">↑</a>, <a class="IndexArrow" href="#entry-binding-1">↑</a>, <a class="IndexArrow" href="#entry-binding-2">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-bootloader"></a>bootloader: <a class="IndexArrow" href="#entry-bootloader-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-children"></a>children: <a class="IndexArrow" href="#entry-children-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-closure"></a>closure: <a class="IndexArrow" href="#entry-closure-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-cookie"></a>cookie: <a class="IndexArrow" href="#entry-cookie-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-create"></a>create: <a class="IndexArrow" href="#entry-create-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-dbColumnName"></a>dbColumnName: <a class="IndexArrow" href="#entry-dbColumnName-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-dbIndexed_?"></a>dbIndexed_?: <a class="IndexArrow" href="#entry-dbIndexed_?-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-dbTableName"></a>dbTableName: <a class="IndexArrow" href="#entry-dbTableName-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-eager-eval"></a>eager eval: <a class="IndexArrow" href="#entry-eager-eval-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-embed"></a>embed: <a class="IndexArrow" href="#entry-embed-0">↑</a>, <a class="IndexArrow" href="#entry-embed-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-entity-class"></a>entity class: <a class="IndexArrow" href="#entry-entity-class-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-entity-classes"></a>entity classes: <a class="IndexArrow" href="#entry-entity-classes-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-enumerations"></a>enumerations: <a class="IndexArrow" href="#entry-enumerations-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-fieldOrder"></a>fieldOrder: <a class="IndexArrow" href="#entry-fieldOrder-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-findAll"></a>findAll: <a class="IndexArrow" href="#entry-findAll-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-form"></a>form: <a class="IndexArrow" href="#entry-form-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-formTemplate"></a>formTemplate: <a class="IndexArrow" href="#entry-formTemplate-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-head"></a>head: <a class="IndexArrow" href="#entry-head-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-hidden-templates"></a>hidden templates: <a class="IndexArrow" href="#entry-hidden-templates-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-httpAuthProtectedResources"></a>httpAuthProtectedResources: <a class="IndexArrow" href="#entry-httpAuthProtectedResources-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-implicit-conversions"></a>implicit conversions: <a class="IndexArrow" href="#entry-implicit-conversions-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-lift:surround"></a>lift:surround: <a class="IndexArrow" href="#entry-lift:surround-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-many-to-many"></a>many-to-many: <a class="IndexArrow" href="#entry-many-to-many-0">↑</a>, <a class="IndexArrow" href="#entry-many-to-many-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-many-to-one"></a>many-to-one: <a class="IndexArrow" href="#entry-many-to-one-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-mapSnippet"></a>mapSnippet: <a class="IndexArrow" href="#entry-mapSnippet-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-master-project"></a>master project: <a class="IndexArrow" href="#entry-master-project-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-named-queries"></a>named queries: <a class="IndexArrow" href="#entry-named-queries-0">↑</a>, <a class="IndexArrow" href="#entry-named-queries-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-one-to-many"></a>one-to-many: <a class="IndexArrow" href="#entry-one-to-many-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-orm.xml"></a>orm.xml: <a class="IndexArrow" href="#entry-orm.xml-0">↑</a>, <a class="IndexArrow" href="#entry-orm.xml-1">↑</a>, <a class="IndexArrow" href="#entry-orm.xml-2">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-redirect"></a>redirect: <a class="IndexArrow" href="#entry-redirect-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-reflection"></a>reflection: <a class="IndexArrow" href="#entry-reflection-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-rendering-pipeline"></a>rendering pipeline: <a class="IndexArrow" href="#entry-rendering-pipeline-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-request-parameters"></a>request parameters: <a class="IndexArrow" href="#entry-request-parameters-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-rewriting"></a>rewriting: <a class="IndexArrow" href="#entry-rewriting-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-snippet"></a>snippet: <a class="IndexArrow" href="#entry-snippet-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-snippets"></a>snippets: <a class="IndexArrow" href="#entry-snippets-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-surround"></a>surround: <a class="IndexArrow" href="#entry-surround-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-table-name"></a>table name: <a class="IndexArrow" href="#entry-table-name-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-template"></a>template: <a class="IndexArrow" href="#entry-template-0">↑</a>, <a class="IndexArrow" href="#entry-template-1">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-toForm"></a>toForm: <a class="IndexArrow" href="#entry-toForm-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-validation"></a>validation: <a class="IndexArrow" href="#entry-validation-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-viewDispatch"></a>viewDispatch: <a class="IndexArrow" href="#entry-viewDispatch-0">↑</a>, <a class="IndexArrow" href="#entry-viewDispatch-1">↑</a>, <a class="IndexArrow" href="#entry-viewDispatch-2">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-web-service"></a>web service: <a class="IndexArrow" href="#entry-web-service-0">↑</a>
</p>
<p class="printindex">
<a class="printindex" name="index-web.xml"></a>web.xml: <a class="IndexArrow" href="#entry-web.xml-0">↑</a>, <a class="IndexArrow" href="#entry-web.xml-1">↑</a>, <a class="IndexArrow" href="#entry-web.xml-2">↑</a>
</p>
    
      <p class="bottom">(C) 2012 Lift 2.0 EditionWritten by Derek Chen-Becker, Marius Danciu and Tyler Weir</p>
    </div>
    <script type="text/javascript">SyntaxHighlighter.all()</script>
  </body>
</html>

